[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/aes.js",
    "content": "/**\n * aes.js\n */\n\nimport * as util from './util.js';\nimport * as nodeapi from './nodeapi.js';\nimport * as webapi from './webapi.js';\nimport params from './params.js';\n\n/**\n * Check if the given algorithm spec is valid.\n * @param name\n * @param iv\n * @param tagLength\n */\nfunction assertAlgorithms({name, iv, tagLength}){\n  if(Object.keys(params.ciphers).indexOf(name) < 0) throw new Error('UnsupportedAlgorithm');\n  if(params.ciphers[name].ivLength){\n    if(!(iv instanceof Uint8Array)) throw new Error('InvalidArguments');\n    if(iv.byteLength < 2 || iv.byteLength > 16) throw new Error('InvalidIVLength');\n    if(params.ciphers[name].staticIvLength && (params.ciphers[name].ivLength !== iv.byteLength)) throw new Error('InvalidIVLength');\n  }\n  if(params.ciphers[name].tagLength && tagLength){\n    if(!Number.isInteger(tagLength)) throw new Error('InvalidArguments');\n    if(tagLength < 4 || tagLength > 16) throw new Error('InvalidTagLength');\n  }\n}\n\n/**\n * Encrypt with AES\n * @param msg\n * @param key\n * @param name\n * @param iv\n * @param additionalData\n * @param tagLength\n * @return {Promise<Uint8Array>}\n */\nexport async function encrypt(msg, key, {name = 'AES-GCM', iv, additionalData=new Uint8Array([]), tagLength}){\n  // assertion and sanitizing\n  if(!(msg instanceof Uint8Array) || !(key instanceof Uint8Array)) throw new Error('InvalidArguments');\n  assertAlgorithms({name, iv, tagLength});\n  if(params.ciphers[name].tagLength && !tagLength) tagLength = params.ciphers[name].tagLength;\n\n  const webCrypto = await util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = await util.getNodeCrypto(); // node crypto\n\n  let native = true;\n  let data;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') {// for web API including IE...\n    data = await webapi.encrypt(msg, key, {name, iv, additionalData, tagLength}, webCrypto)\n      .catch(() => {\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try{\n      data = nodeapi.encrypt(msg, key, {name, iv, additionalData, tagLength}, nodeCrypto);\n    } catch(e) {\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    throw new Error('UnsupportedEnvironment');\n    // try{\n    //   keyPair = await purejs.generateKey(namedCurve);\n    // } catch (e) {throw new Error('UnsupportedEnvironment');}\n  }\n\n  return data;\n}\n\n\n/**\n * Decrypt with AES\n * @param data\n * @param key\n * @param name\n * @param iv\n * @param additionalData\n * @param tagLength\n * @return {Promise<Uint8Array>}\n */\nexport async function decrypt(data, key, {name='AES-GCM', iv, additionalData=new Uint8Array([]), tagLength}){\n  // assertion and sanitizing\n  if(!(data instanceof Uint8Array) || !(key instanceof Uint8Array)) throw new Error('InvalidArguments');\n  assertAlgorithms({name, iv, tagLength});\n  if(params.ciphers[name].tagLength && !tagLength) tagLength = params.ciphers[name].tagLength;\n\n  const webCrypto = await util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = await util.getNodeCrypto(); // node crypto\n\n  let native = true;\n  let errMsg;\n  let msg;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') {\n    msg = await webapi.decrypt(data, key, {name, iv, additionalData, tagLength}, webCrypto).catch((e) => {\n      native = false;\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined'){\n    try{\n      msg = nodeapi.decrypt(data, key, {name, iv, additionalData, tagLength}, nodeCrypto);\n    } catch(e) {\n      native = false;\n      errMsg = e.message;\n    }\n  }\n\n  if (native === false){ // fallback to native implementation\n    if(errMsg) throw new Error(errMsg);\n    else throw new Error('UnsupportedEnvironment');\n    // try{\n    //   keyPair = await purejs.generateKey(namedCurve);\n    // } catch (e) {throw new Error('UnsupportedEnvironment');}\n  }\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/aes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "function",
    "name": "assertAlgorithms",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~assertAlgorithms",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": null,
    "description": "Check if the given algorithm spec is valid.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "iv",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "tagLength",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": "{encrypt}",
    "description": "Encrypt with AES",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "iv",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "additionalData",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "tagLength",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 3,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": "{decrypt}",
    "description": "Decrypt with AES",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "iv",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "additionalData",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "tagLength",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 4,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {encrypt, decrypt} from './aes.js';\n\nexport default {encrypt, decrypt};\nexport {encrypt, decrypt};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 5,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\n\nexport function encrypt(msg, key, {name = 'AES-GCM', iv, additionalData, tagLength}, nodeCrypto){\n  let alg = params.ciphers[name].nodePrefix;\n  alg = `${alg}-${(key.byteLength*8).toString()}-`;\n  alg = alg + params.ciphers[name].nodeSuffix;\n\n  let cipher;\n  switch(name){\n  case 'AES-GCM': {\n    cipher = nodeCrypto.createCipheriv(alg, key, iv, {authTagLength: tagLength});\n    cipher.setAAD(additionalData);\n    break;\n  }\n  case 'AES-CBC': {\n    cipher = nodeCrypto.createCipheriv(alg, key, iv);\n    break;\n  }\n  default: throw new Error('UnsupportedCipher');\n  }\n\n  const body = new Uint8Array(cipher.update(msg));\n  const final = new Uint8Array(cipher.final());\n\n  let tag = new Uint8Array([]);\n  if(name === 'AES-GCM') tag = new Uint8Array(cipher.getAuthTag());\n\n  const data = new Uint8Array(body.length + final.length + tag.length);\n  data.set(body);\n  data.set(final, body.length);\n  data.set(tag, body.length + final.length);\n\n  return data;\n}\n\n\nexport function decrypt(data, key, {name='AES-GCM', iv, additionalData, tagLength}, nodeCrypto) {\n  let alg = params.ciphers[name].nodePrefix;\n  alg = `${alg}-${(key.byteLength*8).toString()}-`;\n  alg = alg + params.ciphers[name].nodeSuffix;\n\n  let decipher;\n  let body;\n  switch(name){\n  case 'AES-GCM': {\n    decipher = nodeCrypto.createDecipheriv(alg, key, iv, {authTagLength: tagLength});\n    decipher.setAAD(additionalData);\n    body = data.slice(0, data.length - tagLength);\n    const tag = data.slice(data.length - tagLength);\n    decipher.setAuthTag(tag);\n    break;\n  }\n  case 'AES-CBC': {\n    decipher = nodeCrypto.createDecipheriv(alg, key, iv);\n    body = data;\n    break;\n  }\n  default: throw new Error('UnsupportedCipher');\n  }\n\n  const decryptedBody = decipher.update(body);\n  let final;\n  try{\n    final = decipher.final();\n  } catch (e) {\n    throw new Error('DecryptionFailure');\n  }\n  const msg = new Uint8Array(final.length + decryptedBody.length);\n  msg.set(decryptedBody);\n  msg.set(final, decryptedBody.length);\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 6,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/nodeapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/nodeapi.js",
    "importStyle": "{encrypt}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"name\": *, \"iv\": *, \"additionalData\": *, \"tagLength\": *}"
        ],
        "defaultRaw": {
          "name": null,
          "iv": null,
          "additionalData": null,
          "tagLength": null
        },
        "defaultValue": "{\"name\":null,\"iv\":null,\"additionalData\":null,\"tagLength\":null}"
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/nodeapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/nodeapi.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"name\": *, \"iv\": *, \"additionalData\": *, \"tagLength\": *}"
        ],
        "defaultRaw": {
          "name": null,
          "iv": null,
          "additionalData": null,
          "tagLength": null
        },
        "defaultValue": "{\"name\":null,\"iv\":null,\"additionalData\":null,\"tagLength\":null}"
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  ciphers: {\n    'AES-GCM': {\n      nodePrefix: 'aes',\n      nodeSuffix: 'gcm',\n      ivLength: 12,  // default value of iv length, 12 bytes is recommended for AES-GCM\n      tagLength: 16,\n      staticIvLength: true // if true, IV length must be always ivLength.\n    },\n    'AES-CBC': {\n      nodePrefix: 'aes',\n      nodeSuffix: 'cbc',\n      ivLength: 16,\n      staticIvLength: true\n    }\n  }\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.msCrypto) return window.msCrypto.subtle;\n    if (window.crypto) return window.crypto.subtle;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "function",
    "name": "getWebCryptoAll",
    "memberof": "packages/js-crypto-aes/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/util.js~getWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/util.js",
    "importStyle": "{getWebCryptoAll}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-aes/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 12,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\nexport async function encrypt(msg, key, {name = 'AES-GCM', iv, additionalData, tagLength}, webCrypto) {\n  let alg;\n\n  switch(name){\n  case 'AES-GCM': {\n    alg = Object.assign({name, iv, tagLength: tagLength * 8}, (additionalData.length > 0) ? {additionalData} : {});\n    break;\n  }\n  case 'AES-CBC': alg = {name, iv};\n    break;\n  default: throw new Error('UnsupportedCipher');\n  }\n\n  if (typeof window.msCrypto === 'undefined') {\n    // modern browsers\n    const sessionKeyObj = await webCrypto.importKey('raw', key, alg, false, ['encrypt', 'decrypt']);\n    const data = await webCrypto.encrypt(alg, sessionKeyObj, msg);\n    return new Uint8Array(data);\n  }\n  else {\n    const sessionKeyObj = await msImportKey('raw', key, alg, false, ['encrypt', 'decrypt'], webCrypto);\n    const encryptedObj = await msEncrypt(alg, sessionKeyObj, msg, webCrypto);\n\n    if (name === 'AES-GCM') {\n      const data = new Uint8Array(encryptedObj.ciphertext.byteLength + encryptedObj.tag.byteLength);\n      data.set(new Uint8Array(encryptedObj.ciphertext));\n      data.set(new Uint8Array(encryptedObj.tag), encryptedObj.ciphertext.byteLength);\n      return data;\n    } else return new Uint8Array(encryptedObj);\n  }\n}\n\nexport async function decrypt(data, key, {name='AES-GCM', iv, additionalData, tagLength}, webCrypto) {\n  let alg;\n  switch(name){\n  case 'AES-GCM': {\n    alg = Object.assign({name, iv, tagLength: tagLength * 8}, (additionalData.length > 0) ? {additionalData} : {});\n    break;\n  }\n  case 'AES-CBC': alg = {name, iv};\n    break;\n  default: throw new Error('UnsupportedCipher');\n  }\n\n  if (!window.msCrypto) {\n    // modern browsers\n    const sessionKeyObj = await webCrypto.importKey('raw', key, alg, false, ['encrypt', 'decrypt']);\n    const msg = await webCrypto.decrypt(alg, sessionKeyObj, data).catch(() => {\n      throw new Error('DecryptionFailure');\n    });\n    return new Uint8Array(msg);\n  }\n  else {\n    const sessionKeyObj = await msImportKey('raw', key, alg, false, ['encrypt', 'decrypt'], webCrypto);\n    if (name === 'AES-GCM') {\n      const ciphertext = data.slice(0, data.length - tagLength);\n      const tag = data.slice(data.length - tagLength, data.length);\n      const msg = await msDecrypt(Object.assign(alg, {tag}), sessionKeyObj, ciphertext, webCrypto).catch(() => {\n        throw new Error('DecryptionFailure');\n      });\n      return new Uint8Array(msg);\n    } else{\n      const msg = await msDecrypt(alg, sessionKeyObj, data, webCrypto).catch(() => {\n        throw new Error('DecryptionFailure');\n      });\n      return new Uint8Array(msg);\n    }\n  }\n}\n\n\n// function definitions for IE\nconst msImportKey = (type, key, alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.importKey(type, key, alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyImportingFailed'); };\n});\nconst msEncrypt = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.encrypt(alg, key, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('EncryptionFailure'); };\n});\nconst msDecrypt = (alg, key, data, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.decrypt(alg, key, data);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('DecryptionFailure'); };\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 13,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": "{encrypt}",
    "description": "webapi.js",
    "lineNumber": 5,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"name\": *, \"iv\": *, \"additionalData\": *, \"tagLength\": *}"
        ],
        "defaultRaw": {
          "name": null,
          "iv": null,
          "additionalData": null,
          "tagLength": null
        },
        "defaultValue": "{\"name\":null,\"iv\":null,\"additionalData\":null,\"tagLength\":null}"
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"name\": *, \"iv\": *, \"additionalData\": *, \"tagLength\": *}"
        ],
        "defaultRaw": {
          "name": null,
          "iv": null,
          "additionalData": null,
          "tagLength": null
        },
        "defaultValue": "{\"name\":null,\"iv\":null,\"additionalData\":null,\"tagLength\":null}"
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "function",
    "name": "msImportKey",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msImportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 16,
    "kind": "function",
    "name": "msEncrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msEncrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 17,
    "kind": "function",
    "name": "msDecrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msDecrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 18,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/asn1enc.js",
    "content": "/**\n * asn1enc.js\n */\n\nimport params from './params.js';\nimport asn from 'asn1.js';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\nconst BN = asn.bignum;\n\nexport function decodeAsn1Signature(asn1sig, namedCurve){\n  const asn1sigBuffer = Buffer.from(asn1sig); // This must be Buffer object to get decoded;\n  const decoded = ECDSASignature.decode(asn1sigBuffer, 'der');\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const r = new Uint8Array(decoded.r.toArray('be', len));\n  const s = new Uint8Array(decoded.s.toArray('be', len));\n  const signature = new Uint8Array(len*2);\n  signature.set(r);\n  signature.set(s, len);\n  return signature;\n}\n\nexport function encodeAsn1Signature(signature, namedCurve){\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const r = signature.slice(0, len);\n  const s = signature.slice(len, signature.length);\n  const asn1sig = ECDSASignature.encode({\n    r: new BN(r), s: new BN(s)\n  }, 'der');\n  return new Uint8Array(asn1sig);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n// RFC5759 https://tools.ietf.org/html/rfc5759.html\nconst ECDSASignature = asn.define('ECDSASignature', function() {\n  this.seq().obj(\n    this.key('r').int(),\n    this.key('s').int()\n  );\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/asn1enc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 19,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 20,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 21,
    "kind": "function",
    "name": "decodeAsn1Signature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~decodeAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": "{decodeAsn1Signature}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "asn1sig",
        "types": [
          "*"
        ]
      },
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 22,
    "kind": "function",
    "name": "encodeAsn1Signature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~encodeAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": "{encodeAsn1Signature}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 23,
    "kind": "variable",
    "name": "ECDSASignature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~ECDSASignature",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 24,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/ec.js",
    "content": "/**\n * ec.js\n */\n\nimport * as util from './util.js';\nimport * as webapi from './webapi.js';\nimport * as nodeapi from './nodeapi.js';\nimport * as purejs from './purejs.js';\n\n/**\n * Generate elliptic curve cryptography public/private key pair\n * @param namedCurve\n * @return {Promise<void>}\n */\nexport async function generateKey(namedCurve='P-256'){\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let keyPair = {};\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.generateKey === 'function' && typeof webCrypto.exportKey === 'function') { // for web API\n    keyPair = await webapi.generateKey(namedCurve, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try{\n      keyPair = await nodeapi.generateKey(namedCurve, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    try{\n      keyPair = await purejs.generateKey(namedCurve);\n    } catch (e) {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return keyPair;\n}\n\n\n/**\n * Sign message with ECDSA\n * @param msg\n * @param privateJwk\n * @param hash\n * @param signatureFormat\n * @return {Promise<*>}\n */\nexport async function sign(msg, privateJwk, hash = 'SHA-256', signatureFormat='raw') {\n  // assertion\n  if (signatureFormat !== 'raw' && signatureFormat !== 'der') throw new Error('InvalidSignatureFormat');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let signature;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') { // for web API\n    signature = await webapi.sign(msg, privateJwk, hash, signatureFormat, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try {\n      signature = await nodeapi.sign(msg, privateJwk, hash, signatureFormat, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    try{\n      signature = await purejs.sign(msg, privateJwk, hash, signatureFormat);\n    } catch (e) {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n  return signature;\n}\n\n\n/**\n * Verify signature with ECDSA\n * @param msg\n * @param signature\n * @param publicJwk\n * @param hash\n * @param signatureFormat\n * @return {Promise<*>}\n */\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', signatureFormat='raw') {\n  // assertion\n  if (signatureFormat !== 'raw' && signatureFormat !== 'der') throw new Error('InvalidSignatureFormat');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let valid;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.verify === 'function') { // for web API\n    valid = await webapi.verify(msg, signature, publicJwk, hash, signatureFormat, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try {\n      valid = await nodeapi.verify(msg, signature, publicJwk, hash, signatureFormat, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    try{\n      valid = await purejs.verify(msg, signature, publicJwk, hash, signatureFormat);\n    } catch (e) {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return valid;\n}\n\n/**\n * Derive shared secret from my private key and destination's public key.\n * **NOTE** We SHOULD NOT use the derived secret as an encryption key directly.\n * We should employ an appropriate key derivation procedure like HKDF to use the secret for symmetric key encryption.\n * @param publicJwk\n * @param privateJwk\n * @return {Promise<*>}\n */\nexport async function deriveSecret(publicJwk, privateJwk){\n  // assertion\n  if(publicJwk.crv !== privateJwk.crv) throw new Error('UnmatchedCurveName');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let secret;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.deriveBits === 'function') { // for web API\n    secret = await webapi.deriveSecret(publicJwk, privateJwk, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try {\n      secret = await nodeapi.deriveSecret(publicJwk, privateJwk, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    try{\n      secret = await purejs.deriveSecret(publicJwk, privateJwk);\n    } catch (e) {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return secret;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 25,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{generateKey}",
    "description": "Generate elliptic curve cryptography public/private key pair",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 26,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{sign}",
    "description": "Sign message with ECDSA",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 27,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{verify}",
    "description": "Verify signature with ECDSA",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 28,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{deriveSecret}",
    "description": "Derive shared secret from my private key and destination's public key.\n**NOTE** We SHOULD NOT use the derived secret as an encryption key directly.\nWe should employ an appropriate key derivation procedure like HKDF to use the secret for symmetric key encryption.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 29,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {generateKey, sign, verify, deriveSecret} from './ec.js';\n\nexport default {generateKey, sign, verify, deriveSecret};\nexport {generateKey, sign, verify, deriveSecret};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 30,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\nimport * as asn1enc from './asn1enc.js';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\n\nexport async function generateKey(namedCurve, nodeCrypto){\n  const ecdh = nodeCrypto.ECDH(params.namedCurves[namedCurve].nodeName);\n  ecdh.generateKeys();\n  const publicOct = new Uint8Array(ecdh.getPublicKey());\n  const privateOct = new Uint8Array(ecdh.getPrivateKey());\n\n  const publicKey = new Key('oct', publicOct, {namedCurve});\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCKeyGenNode');\n  const publicJwk = await publicKey.export('jwk', {outputPublic: true});\n  const privateKey = new Key('oct', privateOct, {namedCurve});\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCKeyGenNode');\n  const privateJwk = await privateKey.export('jwk');\n\n  return {publicKey: publicJwk, privateKey: privateJwk};\n}\n\nexport async function sign(msg, privateJwk, hash, signatureFormat, nodeCrypto){\n  const privateKey = new Key('jwk', privateJwk);\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCSignNode');\n  const privatePem = await privateKey.export('pem');\n\n  const sign = nodeCrypto.createSign(params.hashes[hash].nodeName);\n  sign.update(msg);\n  const asn1sig = sign.sign(privatePem);\n  return (signatureFormat === 'raw') ? asn1enc.decodeAsn1Signature(asn1sig, privateJwk.crv) : asn1sig;\n}\n\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat, nodeCrypto){\n  const publicKey = new Key('jwk', publicJwk);\n  if (!publicKey.isPrivate) throw new Error('NotPrivateKeyForECCVerifyNode');\n  const publicPem = await publicKey.export('pem', {outputPublic: true, compact: false});\n\n  const verify = nodeCrypto.createVerify(params.hashes[hash].nodeName);\n  verify.update(msg);\n  const asn1sig = (signatureFormat === 'raw') ? asn1enc.encodeAsn1Signature(signature, publicJwk.crv) : signature;\n  return verify.verify(publicPem, asn1sig);\n}\n\nexport function deriveSecret(publicJwk, privateJwk, nodeCrypto){\n  const curve = params.namedCurves[privateJwk.crv].nodeName;\n  const payloadSize = params.namedCurves[privateJwk.crv].payloadSize;\n\n  const ecdh = nodeCrypto.createECDH(curve);\n\n  const privKeyBuf = jseu.encoder.decodeBase64Url(privateJwk.d);\n  const pubKeyBuf = new Uint8Array( payloadSize * 2 + 1 );\n  pubKeyBuf[0] = 0xFF & 0x04;\n  pubKeyBuf.set(jseu.encoder.decodeBase64Url(publicJwk.x), 1);\n  pubKeyBuf.set(jseu.encoder.decodeBase64Url(publicJwk.y), payloadSize + 1);\n  ecdh.setPrivateKey(privKeyBuf);\n  return new Uint8Array(ecdh.computeSecret(pubKeyBuf));\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 31,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{generateKey}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"publicKey\": *, \"privateKey\": *}"
      ]
    }
  },
  {
    "__docId__": 32,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{sign}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{verify}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 34,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{deriveSecret}",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  namedCurves: {\n    'P-256': {indutnyName: 'p256', nodeName: 'prime256v1', payloadSize: 32},\n    'P-384': {indutnyName: 'p384', nodeName: 'secp384r1', payloadSize: 48},\n    'P-521': {indutnyName: 'p521', nodeName: 'secp521r1', payloadSize: 66},\n    'P-256K': {indutnyName: 'secp256k1', nodeName: 'secp256k1', payloadSize: 32},\n  },\n\n  hashes: {\n    'SHA-256': {nodeName: 'sha256'}, //, hashSize: 32},\n    'SHA-384': {nodeName: 'sha384'}, //, hashSize: 48},\n    'SHA-512': {nodeName: 'sha512'}, //, hashSize: 64}\n    'SHA-1': {nodeName: 'sha1'}, //, hashSize: 20},\n  },\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 36,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/purejs.js",
    "content": "/**\n * purejs.js\n */\n\nimport params from './params.js';\nimport * as asn1enc from './asn1enc.js';\nimport random from 'js-crypto-random';\nimport jschash from 'js-crypto-hash';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\nimport elliptic from 'elliptic';\nconst Ec = elliptic.ec;\n\nexport async function generateKey(namedCurve){\n\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n  const ecKey = ec.genKeyPair({\n    entropy: jseu.encoder.arrayBufferToString(await random.getRandomBytes(32))\n  });\n\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const publicOct = new Uint8Array(ecKey.getPublic('array'));\n  const privateOct = new Uint8Array(ecKey.getPrivate().toArray('be', len));\n\n  const publicKey = new Key('oct', publicOct, {namedCurve});\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCKeyGenPureJS');\n  const publicJwk = await publicKey.export('jwk', {outputPublic: true});\n\n  const privateKey = new Key('oct', privateOct, {namedCurve});\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCKeyGenPureJS');\n  const privateJwk = await privateKey.export('jwk');\n\n  return {publicKey: publicJwk, privateKey: privateJwk};\n}\n\nexport async function sign(msg, privateJwk, hash, signatureFormat) {\n  const namedCurve = privateJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const privateKey = new Key('jwk', privateJwk);\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCSignPureJS');\n  const privateOct = await privateKey.export('oct');\n\n  const ecKey = ec.keyFromPrivate(privateOct);\n\n  // get hash\n  const md = await jschash.compute(msg, hash);\n\n  // generate signature\n  const signature = ecKey.sign(md);\n\n  // formatting\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const arrayR = new Uint8Array(signature.r.toArray('be', len));\n  const arrayS = new Uint8Array(signature.s.toArray('be', len));\n  const concat = new Uint8Array(arrayR.length + arrayS.length);\n  concat.set(arrayR);\n  concat.set(arrayS, arrayR.length);\n  return (signatureFormat === 'raw') ? concat : asn1enc.encodeAsn1Signature(concat, namedCurve);\n}\n\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat){\n  const namedCurve = publicJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const publicKey = new Key('jwk', publicJwk);\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCVerifyPureJS');\n  const publicOct = await publicKey.export('oct', {compact: false, outputPublic: true});\n\n  const ecKey = ec.keyFromPublic(publicOct);\n\n  // parse signature\n  const len = params.namedCurves[namedCurve].payloadSize;\n  if(!(signature instanceof Uint8Array)) signature = new Uint8Array(signature);\n  signature = (signatureFormat === 'raw') ? signature : asn1enc.decodeAsn1Signature(signature, namedCurve);\n  const sigR = signature.slice(0, len);\n  const sigS = signature.slice(len, len+sigR.length);\n\n  // get hash\n  const md = await jschash.compute(msg, hash);\n\n  return await ecKey.verify(md, {s: sigS, r: sigR});\n}\n\nexport async function deriveSecret(publicJwk, privateJwk){\n  const namedCurve = privateJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const priKeyObj = new Key('jwk', privateJwk);\n  if (!priKeyObj.isPrivate) throw new Error('NotPrivateKeyForECCSDeriveKeyPureJS');\n  const privateOct = await priKeyObj.export('oct');\n\n  const pubKeyObj = new Key('jwk', publicJwk);\n  if (pubKeyObj.isPrivate) throw new Error('NotPublicKeyForECCDeriveKeyPureJS');\n  const publicOct = await pubKeyObj.export('oct', {compact: false, outputPublic: true});\n\n  const privateKey = ec.keyFromPrivate(privateOct);\n  const publicKey = ec.keyFromPublic(publicOct);\n\n  // derive shared key\n  const len = params.namedCurves[namedCurve].payloadSize;\n  return new Uint8Array(privateKey.derive(publicKey.getPublic()).toArray('be', len));\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/purejs.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "name": "Ec",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~Ec",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 38,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{generateKey}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"publicKey\": *, \"privateKey\": *}"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{sign}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{verify}",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 41,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{deriveSecret}",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCrypto () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.crypto) return window.crypto.subtle;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 43,
    "kind": "function",
    "name": "getWebCrypto",
    "memberof": "packages/js-crypto-ec/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/util.js~getWebCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/util.js",
    "importStyle": "{getWebCrypto}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 44,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-ec/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 45,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport * as asn1enc from './asn1enc.js';\n\nexport async function generateKey(namedCurve, webCrypto){\n  // generate ecdsa key\n  // hash is used for signing and verification. never be used for key generation\n  const keys = await webCrypto.generateKey({ name: 'ECDSA', namedCurve, hash: {name: 'SHA-256'} }, true, ['sign', 'verify']);\n\n  // export keys in jwk format\n  const publicKey = await webCrypto.exportKey('jwk', keys.publicKey);\n  const privateKey = await webCrypto.exportKey('jwk', keys.privateKey);\n\n  // delete optional entries to export as general ecdsa/ecdh key\n  ['key_ops', 'alg', 'ext'].forEach((elem) => {\n    delete publicKey[elem];\n    delete privateKey[elem];\n  });\n\n  return {publicKey, privateKey};\n}\n\nexport async function sign(msg, privateJwk, hash, signatureFormat, webCrypto){\n  const algo = {name: 'ECDSA', namedCurve: privateJwk.crv, hash: {name: hash}};\n  const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['sign']);\n  const signature = await webCrypto.sign(algo, key, msg);\n  return (signatureFormat === 'raw')\n    ? new Uint8Array(signature)\n    : asn1enc.encodeAsn1Signature(new Uint8Array(signature), privateJwk.crv);\n}\n\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat, webCrypto){\n  const algo = {name: 'ECDSA', namedCurve: publicJwk.crv, hash: {name: hash}};\n  const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['verify']);\n  const rawSignature = (signatureFormat === 'raw')\n    ? signature\n    : asn1enc.decodeAsn1Signature(signature, publicJwk.crv);\n  return await webCrypto.verify(algo, key, rawSignature, msg);\n}\n\nexport async function deriveSecret(publicJwk, privateJwk, webCrypto){\n  const algo = {name: 'ECDH', namedCurve: privateJwk.crv};\n  const privateKey = await webCrypto.importKey('jwk', privateJwk, algo, false, ['deriveBits']);\n  const publicKey = await webCrypto.importKey('jwk', publicJwk, algo, false, []);\n  const bitLen = () => { const arr = jseu.encoder.decodeBase64Url(privateJwk.x); return 8*arr.length; };\n  return new Uint8Array(\n    await webCrypto.deriveBits(Object.assign(algo, {public: publicKey}), privateKey, bitLen())\n  );\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 46,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{generateKey}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"publicKey\": *, \"privateKey\": *}"
      ]
    }
  },
  {
    "__docId__": 47,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{sign}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{verify}",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureFormat",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{deriveSecret}",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/hash.js",
    "content": "/**\n * hash.js\n */\n\nimport * as util from './util.js';\nimport params from './params.js';\nimport md5 from 'md5';\nimport jsHash from 'hash.js';\n\n/**\n * Compute Hash\n * @param hash\n * @param msg\n * @return {Promise<Uint8Array>}\n */\nexport async function compute(msg, hash = 'SHA-256') {\n  if(Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHashAlgorithm');\n  if(!(msg instanceof Uint8Array)) throw new Error('UnsupportedMessageType');\n\n  const webCrypto = util.getWebCrypto();\n  const nodeCrypto = util.getNodeCrypto();\n  const msCrypto = util.getMsCrypto();\n\n  let msgHash;\n  let errMsg;\n  let native = true;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.digest === 'function' && typeof msCrypto === 'undefined') {\n    msgHash = await webCrypto.digest(hash, msg).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    }); // for modern browsers\n  }\n  else if (typeof nodeCrypto !== 'undefined' ){ // for node\n    try {\n      const alg = params.hashes[hash].nodeName;\n      const hashFunc = nodeCrypto.createHash(alg);\n      hashFunc.update(msg);\n      msgHash = hashFunc.digest();\n    } catch (e) {\n      errMsg = e.message;\n      native = false;\n    }\n  }\n  else if (typeof msCrypto !== 'undefined' && typeof msCrypto.digest === 'function') { // for legacy ie 11\n    // WTF IE!!!\n    const msdigest = (alg, m) => new Promise((resolve, reject) => {\n      const op = window.msCrypto.subtle.digest(alg, m);\n      op.oncomplete = (evt) => {\n        resolve(evt.target.result);\n      };\n      op.onerror = (e) => {\n        reject(e);\n      };\n    });\n\n    msgHash = await msdigest(hash, msg).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  } else native = false;\n\n  if (!native){\n    try {\n      msgHash = purejs(hash, msg);\n    }\n    catch(e){\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return new Uint8Array(msgHash);\n}\n\nfunction purejs(hash, msg){\n  let h;\n  if(hash === 'MD5'){\n    h = md5(Array.from(msg), {asBytes: true});\n  }\n  else if (Object.keys(params.hashes).indexOf(hash) >= 0){\n    h = jsHash[params.hashes[hash].nodeName]().update(msg).digest();\n  }\n  else throw new Error('UnsupportedHashInPureJs');\n\n  return new Uint8Array(h);\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/hash.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": "{compute}",
    "description": "Compute Hash",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 52,
    "kind": "function",
    "name": "purejs",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~purejs",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute} from './hash.js';\n\nexport default {compute};\nexport {compute};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 54,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20}, // SHOULD NOT USE\n    'MD5': {nodeName: 'md5', hashSize: 16} // SHOULD NOT USE\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCrypto () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.crypto) return window.crypto.subtle;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}\n\nexport function getMsCrypto(){\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.crypto) return undefined;\n    if (window.msCrypto) return window.msCrypto.subtle;\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "function",
    "name": "getWebCrypto",
    "memberof": "packages/js-crypto-hash/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/util.js~getWebCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hash/src/util.js",
    "importStyle": "{getWebCrypto}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-hash/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hash/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "getMsCrypto",
    "memberof": "packages/js-crypto-hash/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/util.js~getMsCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hash/src/util.js",
    "importStyle": "{getMsCrypto}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/hkdf.js",
    "content": "/**\n * hkdf.js\n */\n\nimport params from './params.js';\nimport * as util from './util.js';\n\nimport random from 'js-crypto-random';\nimport hmac  from 'js-crypto-hmac';\n\n/**\n * Hash-based Key Derivation Function computing from given master secret and salt.\n * If salt is not given, salt would be automatically generated inside.\n * Specification: https://tools.ietf.org/html/rfc5869\n * @param master\n * @param hash\n * @param length\n * @param info\n * @param salt\n * @return {Promise<{key: *, salt: *}>}\n */\nexport async function compute(master, hash = 'SHA-256', length = 32, info = '', salt = null){\n  if(!info) info = '';\n  const webCrypto = util.getWebCrypto(); // web crypto api\n\n  let key;\n  if(!salt) salt = await random.getRandomBytes(length);\n\n  if (typeof webCrypto !== 'undefined'\n    && typeof webCrypto.importKey === 'function'\n    && typeof webCrypto.deriveBits === 'function'\n    && typeof window.msCrypto === 'undefined') {\n    try { // modern browsers supporting HKDF\n      const masterObj = await webCrypto.subtle.importKey('raw', master, {name: 'HKDF'}, false, ['deriveKey', 'deriveBits']);\n      key = await webCrypto.subtle.deriveBits({\n        name: 'HKDF',\n        salt,\n        info: new Uint8Array(info),\n        hash\n      }, masterObj, length * 8);\n      key = new Uint8Array(key);\n    }\n    catch (e) { // fall back to pure js implementation\n      key = await rfc5869(master, salt, hash, info, length);\n    }\n  }\n  else { // node and IE\n    key = await rfc5869(master, salt, hash, info, length);\n  }\n\n  return {key, salt};\n}\n\n/**\n * Naive implementation of RFC5869 in PureJavaScript\n * @param master\n * @param salt\n * @param hash\n * @param info\n * @param length\n * @return {Promise<Uint8Array>}\n */\nasync function rfc5869(master, salt, hash, info, length){\n  const len = params.hashes[hash].hashSize;\n\n  // RFC5869 Step 1 (Extract)\n  const prk = await hmac.compute(salt, master, hash);\n\n  // RFC5869 Step 2 (Expand)\n  let t = new Uint8Array([]);\n  const okm = new Uint8Array(Math.ceil(length / len) * len);\n  const uintInfo = new Uint8Array(info);\n  for(let i = 0; i < Math.ceil(length / len); i++){\n    const concat = new Uint8Array(t.length + uintInfo.length + 1);\n    concat.set(t);\n    concat.set(uintInfo, t.length);\n    concat.set(new Uint8Array([i+1]), t.length + uintInfo.length);\n    t = await hmac.compute(prk, concat, hash);\n    okm.set(t, len * i);\n  }\n  return okm.slice(0, length);\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/hkdf.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hkdf/src/hkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hkdf/src/hkdf.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hkdf/src/hkdf.js",
    "importStyle": "{compute}",
    "description": "Hash-based Key Derivation Function computing from given master secret and salt.\nIf salt is not given, salt would be automatically generated inside.\nSpecification: https://tools.ietf.org/html/rfc5869",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "master",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "salt",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{key: *, salt: *}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 61,
    "kind": "function",
    "name": "rfc5869",
    "memberof": "packages/js-crypto-hkdf/src/hkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hkdf/src/hkdf.js~rfc5869",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hkdf/src/hkdf.js",
    "importStyle": null,
    "description": "Naive implementation of RFC5869 in PureJavaScript",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "master",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "salt",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute} from './hkdf.js';\n\nexport default {compute};\nexport {compute};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20},\n    'MD5': {nodeName: 'md5', hashSize: 16}\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCrypto () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.crypto) return window.crypto.subtle;\n  }\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "getWebCrypto",
    "memberof": "packages/js-crypto-hkdf/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hkdf/src/util.js~getWebCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hkdf/src/util.js",
    "importStyle": "{getWebCrypto}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/hmac.js",
    "content": "/**\n * hmac.js\n */\n\nimport params from './params.js';\nimport * as util from './util.js';\nimport jschash from 'js-crypto-hash';\n\n\n/**\n * Compute keyed hash value\n * @param key\n * @param data\n * @param hash\n * @return {Promise<Uint8Array>}\n */\nexport async function compute(key, data, hash = 'SHA-256'){\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // node crypto\n  // const msCrypto = util.getMsCrypto(); // ms crypto\n\n  let native = true;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') {\n    if (typeof window.msCrypto === 'undefined'){\n      try {\n        // standard web api / modern browsers supporting HMAC\n        const keyObj = await webCrypto.importKey('raw', key, { name: 'HMAC', hash: {name: hash} }, false, ['sign', 'verify']);\n        const mac = await webCrypto.sign({name: 'HMAC', hash: {name: hash}}, keyObj, data);\n        return new Uint8Array(mac);\n      } catch (e) { native = false; }\n    }\n    else {\n      try{\n      // function definitions\n        const msImportKey = (type, key, alg, ext, use) => new Promise ( (resolve, reject) => {\n          const op = webCrypto.importKey(type, key, alg, ext, use);\n          op.oncomplete = (evt) => { resolve(evt.target.result); };\n          op.onerror = () => { reject('KeyImportingFailed'); };\n        });\n        const msHmac = (hash, k, d) => new Promise ( (resolve, reject) => {\n          const op = webCrypto.sign({name: 'HMAC', hash: {name: hash}}, k, d);\n          op.oncomplete = (evt) => { resolve(new Uint8Array(evt.target.result)); };\n          op.onerror = () => { reject('ComputingHMACFailed'); };\n        });\n\n        const keyObj = await msImportKey('raw', key, {name: 'HMAC', hash: {name: hash}}, false, ['sign', 'verify']);\n        const rawPrk = await msHmac(hash, keyObj, data);\n        return new Uint8Array(rawPrk);\n      } catch (e) { native = false; }\n    }\n  }\n  else if (typeof nodeCrypto !== 'undefined'){ // for node\n    try {\n      const f = nodeCrypto.createHmac(params.hashes[hash].nodeName, key);\n      return new Uint8Array(f.update(data).digest());\n    } catch (e) { native = false; }\n  }\n  else native = false;\n\n  if (!native){\n    try {\n      return await purejs(key, data, hash);\n    } catch (e) {\n      throw new Error('UnsupportedEnvironments');\n    }\n  }\n}\n\n\n// RFC 2104 https://tools.ietf.org/html/rfc2104\nasync function purejs(key, data, hash = 'SHA-256'){\n  const B = params.hashes[hash].blockSize;\n  const L = params.hashes[hash].hashSize;\n\n  if(key.length > B) key = await jschash.compute(key, hash);\n\n  const K = new Uint8Array(B); // first the array is initialized with 0x00\n  K.set(key);\n\n  const KxorIpad = K.map( (k) => 0xFF & (0x36 ^ k));\n  const KxorOpad = K.map( (k) => 0xFF & (0x5c ^ k));\n\n  const inner = new Uint8Array(B + data.length);\n  inner.set(KxorIpad);\n  inner.set(data, B);\n  const hashedInner = await jschash.compute(inner, hash);\n\n  const outer = new Uint8Array(B + L);\n  outer.set(KxorOpad);\n  outer.set(hashedInner, B);\n\n  return await jschash.compute(outer, hash);\n}\n\n/**\n * Verify HMAC\n * @param key\n * @param data\n * @param mac\n * @param hash\n * @return {Promise<boolean>}\n */\nexport async function verify(key, data, mac, hash = 'SHA-256'){\n  if (!(mac instanceof Uint8Array)) throw new Error('InvalidInputMac');\n\n  const newMac = await compute(key, data, hash);\n  return (mac.toString() === newMac.toString());\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/hmac.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": "{compute}",
    "description": "Compute keyed hash value",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "purejs",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~purejs",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": "{verify}",
    "description": "Verify HMAC",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mac",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute, verify} from './hmac.js';\n\nexport default {compute, verify};\nexport {compute, verify};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32, blockSize: 64},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48, blockSize: 128},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64, blockSize: 128},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20, blockSize: 64},\n    'MD5': {nodeName: 'md5', hashSize: 16, blockSize: 64}\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.msCrypto) return window.msCrypto.subtle;\n    else if (window.crypto) return window.crypto.subtle;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "getWebCryptoAll",
    "memberof": "packages/js-crypto-hmac/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/util.js~getWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/util.js",
    "importStyle": "{getWebCryptoAll}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-hmac/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1def.js",
    "content": "/**\n * asn1def.js\n */\n\nimport asn from 'asn1.js';\n\n///////////////////////////////////////////////////////////////////////////////////////////\nexport const KeyStructure = asn.define('KeyStructure', function (){\n  this.choice({\n    subjectPublicKeyInfo: this.use(SubjectPublicKeyInfo),\n    oneAsymmetricKey: this.use(OneAsymmetricKey),\n    encryptedPrivateKeyInfo: this.use(EncryptedPrivateKeyInfo)\n  });\n});\n\n// https://tools.ietf.org/html/rfc5280\nexport const SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// ( old version PrivateKeyInfo https://tools.ietf.org/html/rfc5208 )\n// RFC5958 https://tools.ietf.org/html/rfc5958\nexport const OneAsymmetricKey = asn.define('OneAsymmetricKey', function () {\n  this.seq().obj(\n    this.key('version').use(Version),\n    this.key('privateKeyAlgorithm').use(AlgorithmIdentifier),\n    this.key('privateKey').octstr(),\n    this.key('attributes').implicit(0).optional().any(),\n    this.key('publicKey').implicit(1).optional().bitstr()\n  );\n});\nexport const EncryptedPrivateKeyInfo = asn.define('EncryptedPrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('encryptionAlgorithm').use(AlgorithmIdentifier),\n    this.key('encryptedData').octstr()\n  );\n});\n\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// https://tools.ietf.org/html/rfc8018\nexport const PBEParameter = asn.define('PBEParameter', function(){\n  this.seq().obj(\n    this.key('salt').octstr(8),\n    this.key('iterationCount').int()\n  );\n});\n\nexport const PBES2Params = asn.define('PBES2Params', function(){\n  this.seq().obj(\n    this.key('keyDerivationFunc').use(AlgorithmIdentifier),\n    this.key('encryptionScheme').use(AlgorithmIdentifier)\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// PBKDF2-params ::= SEQUENCE {\n//        salt CHOICE {\n//          specified OCTET STRING,\n//          otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n//        },\n//        iterationCount INTEGER (1..MAX),\n//        keyLength INTEGER (1..MAX) OPTIONAL,\n//        prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT\n//        algid-hmacWithSHA1\n//    }\nexport const PBKDF2Params = asn.define('PBKDF2Params', function(){\n  this.seq().obj(\n    this.key('salt').choice({\n      'specified': this.octstr(),\n      'otherSource': this.use(AlgorithmIdentifier)\n    }),\n    this.key('iterationCount').int(),\n    this.key('keyLength').int().optional(),\n    this.key('prf').use(AlgorithmIdentifier).def({\n      algorithm: [1, 2, 840, 113549, 2, 7], // hmacWithSHA1\n      parameters: Buffer.from([0x05, 0x00])\n    })\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\nexport const PBES2ESParams = {\n  'des-ede3-cbc': asn.define('DesEde3CbcParams', function(){\n    this.octstr();\n  }),\n  'aes128-cbc': asn.define('Aes128CbcParams', function(){\n    this.octstr();\n  }),\n  'aes192-cbc': asn.define('Aes192CbcParams', function(){\n    this.octstr();\n  }),\n  'aes256-cbc': asn.define('Aes256CbcParams', function(){\n    this.octstr();\n  })\n};\n\n\n////////////////////////////////////////////////////////////////////////////////////\n// https://tools.ietf.org/html/rfc5280\nconst AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('parameters').optional().any()\n  );\n});\n\nconst Version = asn.define('Version', function () {\n  this.int();\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1def.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "KeyStructure",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~KeyStructure",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{KeyStructure}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "SubjectPublicKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~SubjectPublicKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{SubjectPublicKeyInfo}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "name": "OneAsymmetricKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~OneAsymmetricKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{OneAsymmetricKey}",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "EncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~EncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{EncryptedPrivateKeyInfo}",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "variable",
    "name": "PBEParameter",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBEParameter",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBEParameter}",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "name": "PBES2Params",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBES2Params",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBES2Params}",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "PBKDF2Params",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBKDF2Params",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBKDF2Params}",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "PBES2ESParams",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBES2ESParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBES2ESParams}",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "{\"des-ede3-cbc\": *, \"aes128-cbc\": *, \"aes192-cbc\": *, \"aes256-cbc\": *}"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "AlgorithmIdentifier",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~AlgorithmIdentifier",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "name": "Version",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~Version",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1ec.js",
    "content": "/**\n * asn1ec.js\n */\n\nimport asn from 'asn1.js';\n\nimport params, {getAlgorithmFromOid} from './params.js';\nimport {octKeyObjToJwk, octKeyObjFromJwk} from './octenc.js';\n\n/**\n * Convert JWK to parsed ASN.1 EC key object\n * @param jwk\n * @param type\n * @param compact\n * @return {object}\n */\nexport function fromJWK(jwk, type, compact=false){\n  if (Object.keys(params.namedCurves).indexOf(jwk.crv) < 0) throw new Error('UnsupportedCurve');\n  const octkeyObj = octKeyObjFromJwk(jwk, type, compact);\n\n  const publicKeyAlgorithmOid = params.publicKeyAlgorithms['EC'].oid;\n  const publicKey = {unused: 0, data: Array.from(octkeyObj.publicKey)};//Buffer.from(octkeyObj.publicKey)};\n  const parameters = ECParameters.encode({ type: 'namedCurve', value: params.namedCurves[jwk.crv].oid }, 'der');\n  const algorithm = { algorithm: publicKeyAlgorithmOid, parameters };\n\n  const decoded = {};\n  if(type === 'public'){ // SPKI\n    decoded.subjectPublicKey = publicKey;\n    decoded.algorithm = algorithm;\n  }\n  else if (type === 'private') { // PKCS8\n    decoded.version = 0; // no public key presents for v2 (0)\n    decoded.privateKeyAlgorithm = algorithm;\n    decoded.privateKey = ECPrivateKey.encode({\n      version: 1,\n      privateKey: Array.from(octkeyObj.privateKey), //Buffer.from(octkeyObj.privateKey),\n      parameters,\n      publicKey\n    }, 'der');\n  }\n  return decoded;\n}\n\n\n/**\n * Convert parsed ASN.1 EC key object to JWK\n * @param decoded\n * @param type\n * @return {{kty, crv, x, y}}\n */\nexport function toJWK(decoded, type){\n  if (type === 'public'){ // SPKI\n    decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, 'der'); // overwrite nested binary object as parsed object\n    const octPubKey = new Uint8Array(decoded.subjectPublicKey.data); // convert oct key to jwk\n    const namedCurves = getAlgorithmFromOid(decoded.algorithm.parameters.value, params.namedCurves);\n    if(namedCurves.length < 1) throw new Error('UnsupportedCurve');\n\n    return octKeyObjToJwk({publicKey: octPubKey}, type, namedCurves[0]);\n  }\n  else if (type === 'private'){ // PKCS8\n    decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, 'der');\n    // Work around for optional private key parameter field.\n    try{ decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, 'der'); }\n    catch(e){ decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, 'der'); }\n\n    const octPubKey = new Uint8Array(decoded.privateKey.publicKey.data);\n    const octPrivKey = new Uint8Array(decoded.privateKey.privateKey);\n\n    const namedCurves = getAlgorithmFromOid(decoded.privateKeyAlgorithm.parameters.value, params.namedCurves);\n    if(namedCurves.length < 1) throw new Error('UnsupportedCurve');\n\n    return octKeyObjToJwk({publicKey: octPubKey, privateKey: octPrivKey}, type, namedCurves[0]);\n  }\n}\n\n/////////////////////////\n// https://tools.ietf.org/html/rfc5480\nconst ECParameters = asn.define('ECParameters', function() {\n  this.choice({\n    namedCurve: this.objid()\n  });\n});\n\n// https://tools.ietf.org/html/rfc5915\nconst ECPrivateKey = asn.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented\n    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented\n  );\n});\n\nconst ECPrivateKeyAlt = asn.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented\n    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "fromJWK",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~fromJWK",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": "{fromJWK}",
    "description": "Convert JWK to parsed ASN.1 EC key object",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "compact",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "toJWK",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~toJWK",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": "{toJWK}",
    "description": "Convert parsed ASN.1 EC key object to JWK",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "decoded",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{kty, crv, x, y}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 89,
    "kind": "variable",
    "name": "ECParameters",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECParameters",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "name": "ECPrivateKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECPrivateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "ECPrivateKeyAlt",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECPrivateKeyAlt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1enc.js",
    "content": "/**\n * asn1enc.js\n */\n\nimport * as asn1ec from './asn1ec.js';\nimport * as asn1rsa from './asn1rsa.js';\nimport params, {getAlgorithmFromOid} from './params.js';\nimport jseu from 'js-encoding-utils';\nimport BufferMod from 'buffer';\nimport {OneAsymmetricKey, SubjectPublicKeyInfo, KeyStructure} from './asn1def.js';\nimport {encryptEncryptedPrivateKeyInfo, decryptEncryptedPrivateKeyInfo} from './rfc8018.js';\nimport {getJwkType} from './util.js';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Convert jwk to spki/pkcs8 in string or binary format.\n * @param jwkey\n * @param outputPublic {boolean} : derive public key from private key when true\n * @param format {string} : 'pem' or 'der'\n * @param compact {boolean} : 'true' or 'false' for EC public key compressed representation in der/pem\n * @param passphrase\n * @param encOptions\n * @return {Uint8Array}\n */\nexport async function fromJwk(jwkey, format, {outputPublic, compact=false, passphrase = '', encOptions}){\n  const orgType = getJwkType(jwkey);\n  let type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  let decoded;\n  if (jwkey.kty === 'EC') {\n    decoded = asn1ec.fromJWK(jwkey, type, compact);\n  }\n  else if (jwkey.kty === 'RSA'){\n    decoded = asn1rsa.fromJwk(jwkey, type);\n  }\n\n  let binKey;\n  if (type === 'public') {\n    binKey = SubjectPublicKeyInfo.encode(decoded, 'der');\n  }\n  else {\n    binKey = OneAsymmetricKey.encode(decoded, 'der');\n    if(passphrase.length > 0){\n      binKey = await encryptEncryptedPrivateKeyInfo(binKey, passphrase, encOptions);\n      type = 'encryptedPrivate';\n    }\n  }\n  binKey = new Uint8Array(binKey);\n\n  return (format === 'pem') ? jseu.formatter.binToPem(binKey, type) : binKey;\n}\n\n/**\n * Convert spki/pkcs8 key in string or binary format to jwk.\n * @param key\n * @param format\n * @param outputPublic {boolean} (optional)\n * @param passphrase\n * @return {*|void}\n */\nexport async function toJwk(key, format, {outputPublic, passphrase}){\n  // Peel the pem strings\n  const binKey = (format === 'pem') ? jseu.formatter.pemToBin(key) : key;\n\n  // decode binary spki/pkcs8-formatted key to parsed object\n  let decoded;\n  try { decoded = KeyStructure.decode(Buffer.from(binKey), 'der'); }\n  catch (e) { throw new Error('FailedToDecodeKey'); }\n\n  let type;\n  if(decoded.type === 'subjectPublicKeyInfo'){\n    type = 'public';\n    decoded = decoded.value;\n  }\n  else {\n    type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : 'private';\n\n    if(decoded.type === 'encryptedPrivateKeyInfo') decoded = await decryptEncryptedPrivateKeyInfo(decoded.value, passphrase);\n    else if (decoded.type === 'oneAsymmetricKey') decoded = decoded.value;\n    else throw new Error('UnsupportedKeyStructure');\n  }\n\n  const keyTypes = getAlgorithmFromOid(\n    (type === 'public') ? decoded.algorithm.algorithm : decoded.privateKeyAlgorithm.algorithm,\n    params.publicKeyAlgorithms\n  );\n  if(keyTypes.length < 1) throw new Error('UnsupportedKey');\n\n  if (keyTypes[0] === 'EC') {\n    return asn1ec.toJWK(decoded, type);\n  }\n  else if (keyTypes[0] === 'RSA'){\n    return asn1rsa.toJwk(decoded, type);\n  }\n  else throw new Error('InvalidKeyType');\n}\n\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1enc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 94,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": "{fromJwk}",
    "description": "Convert jwk to spki/pkcs8 in string or binary format.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "outputPublic",
        "description": "{boolean} : derive public key from private key when true"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "{string} : 'pem' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "compact",
        "description": "{boolean} : 'true' or 'false' for EC public key compressed representation in der/pem"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "encOptions",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 95,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": "{toJwk}",
    "description": "Convert spki/pkcs8 key in string or binary format to jwk.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "outputPublic",
        "description": "{boolean} (optional)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*",
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "content": "/**\n * asn1rsa.js\n */\n\nimport asn from 'asn1.js';\nimport jseu from 'js-encoding-utils';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\nimport params from './params.js';\nimport {appendLeadingZeros, pruneLeadingZeros} from './util';\n\nexport function fromJwk(jwk, type){\n\n  const publicKeyAlgorithmOid = params.publicKeyAlgorithms['RSA'].oid;\n  // Parameters is always null Ox0500 in ASN.1 as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n  const parameters = Buffer.from([0x05, 0x00]);\n  const algorithm = { algorithm: publicKeyAlgorithmOid, parameters };\n\n  // to append leading zeros (pruned when making JWK) in order to make binary of intended bit length\n  // https://tools.ietf.org/html/rfc7518#section-6.3\n  const modulusBytes = jseu.encoder.decodeBase64Url(jwk.n);\n  const nLen = modulusBytes.length;\n  const modulusLength = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128));\n\n  const modulus = new asn.bignum(appendLeadingZeros(modulusBytes, modulusLength)); // JWA RFC\n  const publicExponent = new asn.bignum(jseu.encoder.decodeBase64Url(jwk.e));\n\n  const decoded = {};\n  if(type === 'public'){ // SPKI\n    decoded.subjectPublicKey = {\n      unused: 0,\n      data: RSAPublicKey.encode({ modulus, publicExponent  }, 'der')\n    };\n    decoded.algorithm = algorithm;\n  }\n  else if (type === 'private') { // PKCS8\n    decoded.version = 0;  // no public key presents for v2 (0)\n    decoded.privateKeyAlgorithm = algorithm;\n    decoded.privateKey = RSAPrivateKey.encode({\n      version: 0,\n      modulus,\n      publicExponent,\n      privateExponent: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.d), modulusLength)),\n      prime1: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.p), modulusLength)),\n      prime2: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.q), modulusLength)),\n      exponent1: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.dp), modulusLength)),\n      exponent2: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.dq), modulusLength)),\n      coefficient: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.qi), modulusLength))\n    }, 'der');\n  }\n  return decoded;\n}\n\n/**\n * Convert RSA spki/pkcs8 public/private keys to JWK\n * @param decoded\n * @param type\n * @return {*}\n */\nexport function toJwk(decoded, type){\n\n  if (type === 'public'){ // SPKI\n    // algorithm.algorithm.parameters is always null Ox0500 in ASN.1\n    // as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n\n    // overwrite nested binary object as parsed object\n    decoded.subjectPublicKey.data = RSAPublicKey.decode(decoded.subjectPublicKey.data, 'der');\n    let modulus = decoded.subjectPublicKey.data.modulus;\n    let publicExponent = decoded.subjectPublicKey.data.publicExponent;\n\n    // convert n and e from BN\n    // modulus n\n    const nLen = modulus.byteLength();\n    const len = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128));\n    modulus = new Uint8Array(modulus.toArray('be', len));\n\n    // // publicExponent e;\n    publicExponent = new Uint8Array(publicExponent.toArray('be', publicExponent.byteLength()));\n\n    return {\n      kty: 'RSA',\n      n: jseu.encoder.encodeBase64Url(pruneLeadingZeros(modulus)), // prune leading zeros https://tools.ietf.org/html/rfc7518#section-6.3\n      e: jseu.encoder.encodeBase64Url(pruneLeadingZeros(publicExponent))\n    };\n  }\n  else if (type === 'private'){ // PKCS8\n    // privateKeyAlgorithm.algorithm.parameters is always null Ox0500 in ASN.1\n    // as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n\n    // overwrite nested binary object as parsed object\n    decoded.privateKey = RSAPrivateKey.decode(decoded.privateKey, 'der');\n\n    const privateKeyElems = {};\n    privateKeyElems.modulus = decoded.privateKey.modulus;\n\n\n    // calculate key length from modulus n\n    const nLen = privateKeyElems.modulus.byteLength();\n    const len = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128)); // this is actual key length, e.g., 256 bytes\n\n\n    // convert BN to Uint8Array\n    privateKeyElems.modulus = new Uint8Array(privateKeyElems.modulus.toArray('be', len)); // n of length len\n    privateKeyElems.publicExponent = new Uint8Array(\n      decoded.privateKey.publicExponent.toArray( 'be', decoded.privateKey.publicExponent.byteLength() )\n    ); // e of arbitrary small length\n    privateKeyElems.privateExponent = new Uint8Array(decoded.privateKey.privateExponent.toArray('be', len)); // d of length len\n\n    const keys = ['prime1', 'prime2', 'exponent1', 'exponent2', 'coefficient']; // elements of length len/2\n    keys.forEach( (key) => {\n      privateKeyElems[key] = new Uint8Array(decoded.privateKey[key].toArray('be', (len>>1) ));\n    });\n\n    // prune leading zeros JWW RSA private key: https://tools.ietf.org/html/rfc7517\n    return {\n      kty: 'RSA',\n      n: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.modulus)),\n      e: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.publicExponent)),\n      d: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.privateExponent)),\n      p: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.prime1)),\n      q: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.prime2)),\n      dp: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.exponent1)),\n      dq: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.exponent2)),\n      qi: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.coefficient))\n    };\n  }\n}\n\n\n///////////\n// https://tools.ietf.org/html/rfc3447\nconst RSAPublicKey = asn.define('RSAPublicKey', function() {\n  this.seq().obj(\n    this.key('modulus').int(), // n\n    this.key('publicExponent').int() // e\n  );\n});\n\nconst RSAPrivateKey = asn.define('RSAPrivateKey', function(){\n  this.seq().obj(\n    this.key('version').int(), // 0\n    this.key('modulus').int(), // n\n    this.key('publicExponent').int(), // e\n    this.key('privateExponent').int(), // d\n    this.key('prime1').int(), // p\n    this.key('prime2').int(), // q\n    this.key('exponent1').int(), // d mod (p-1)\n    this.key('exponent2').int(), // d mod (q-1)\n    this.key('coefficient').int(), // (inverse of q) mod p\n    this.key('otherPrimeInfos').optional().use(OtherPrimeInfos)\n  );\n});\n\nconst OtherPrimeInfos = asn.define('OtherPrimeInfos', function(){\n  this.seqof(OtherPrimeInfo);\n});\n\nconst OtherPrimeInfo = asn.define('OtherPrimeInfo', function(){\n  this.seq().obj(\n    this.key('prime').int(),\n    this.key('exponent').int(),\n    this.key('coefficient').int()\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": "{fromJwk}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "jwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": "{toJwk}",
    "description": "Convert RSA spki/pkcs8 public/private keys to JWK",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "decoded",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 100,
    "kind": "variable",
    "name": "RSAPublicKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~RSAPublicKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 101,
    "kind": "variable",
    "name": "RSAPrivateKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~RSAPrivateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 102,
    "kind": "variable",
    "name": "OtherPrimeInfos",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~OtherPrimeInfos",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "variable",
    "name": "OtherPrimeInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~OtherPrimeInfo",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 104,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/converter.js",
    "content": "/**\n * converter.js\n */\n\nimport * as asn1enc from './asn1enc.js';\nimport * as octenc from './octenc.js';\n\n\n// ASN.1 in RFC5280 (SPKI) and RFC5208 (PKCS8) -> RSA and EC, encode='asn', format='pem' or 'der'\n// -> SPKI (in X.509): RFC5280 for public key, PKCS8: RFC5208 for private key\n// Octet Form in ANSI X9.63 -> EC, encode='oct', format='string' or 'binary', compact=true or false\n// -> Standards for Efficient Cryptography Group (SECG), \"SEC1: Elliptic Curve Cryptography\", Version 1.0, September 2000.\n/**\n * Convert JWK to ASN.1 (for RSA and EC) and Octet (for EC) encoded keys.\n * @param output : 'pem', 'der', or 'oct' (only EC JWK)\n * @param jwkey\n * @param options\n  * For EC JWK : options.compact = true or false\n  * For EC JWK with output = 'oct' : options.format = 'binary' or 'string'\n  * For both: outputPublic (optional) : boolean. derived key type. from private key, public key can be derived when true.\n * @return {Uint8Array}\n */\nexport async function fromJwkTo(output = 'pem', jwkey, options={}){\n  // assertion\n  if (['pem', 'der', 'oct'].indexOf(output) < 0) throw new Error('InvalidOutputForm');\n  if (typeof jwkey !== 'object') throw new Error('InvalidJWKAsObject');\n  if (jwkey.kty !== 'EC' && jwkey.kty !== 'RSA') throw new Error('UnsupportedKeyType');\n  if (typeof options.outputPublic !== 'undefined' && typeof options.outputPublic !== 'boolean') throw new Error('outputPublicMustBeBoolean');\n\n  // default values\n  if (jwkey.key === 'EC' && typeof options.compact !== 'boolean') options.compact = false;\n  if (output === 'oct' && options.format !== 'string') options.format = 'binary';\n  if ((output === 'der' || output === 'pem') && typeof options.passphrase === 'undefined') options.passphrase = '';\n\n  // In the case of PEM/DER\n  if (output === 'der' || output === 'pem') {\n    return await asn1enc.fromJwk(\n      jwkey, output,\n      {outputPublic: options.outputPublic, compact: options.compact, passphrase: options.passphrase, encOptions: options.encOptions }\n    );\n  }\n  // In the case of Oct\n  else if (output === 'oct' && jwkey.kty === 'EC') {\n    return octenc.fromJwk(jwkey, {outputPublic: options.outputPublic, outputFormat: options.format, compact: options.compact});\n  }\n  else throw new Error('UnsupportedConversion');\n\n}\n\n\n/**\n * Convert ASN.1 encoded (for RSA and EC) or octet formed (for EC) keys to JWK.\n * @param input\n * @param key\n * @param options\n * type (optional) derived key type. from private key, public key can be derived.\n * @return {*}\n */\nexport async function toJwkFrom(input, key, options={}){\n  // assertion\n  if (['pem', 'der', 'oct'].indexOf(input) < 0) throw new Error('InvalidInputForm');\n  if (input === 'oct' && !options.namedCurve ) throw new Error('InappropriateOptions');\n  if (typeof options.outputPublic !== 'undefined' && typeof options.outputPublic !== 'boolean') throw new Error('outputPublicMustBeBoolean');\n\n  // default values\n  if ((input === 'der' || input === 'pem') && typeof options.passphrase === 'undefined') options.passphrase = '';\n\n  // In the case of PEM\n  if (input === 'der' || input === 'pem') {\n    return await asn1enc.toJwk(key, input, {outputPublic: options.outputPublic, passphrase: options.passphrase});\n  }\n  // In the case of Oct\n  else if (input === 'oct') {\n    return octenc.toJwk(key, options.namedCurve, {oubputPublic: options.outputPublic});\n  }\n  else throw new Error('UnsupportedConversion');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/converter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 105,
    "kind": "function",
    "name": "fromJwkTo",
    "memberof": "packages/js-crypto-key-utils/src/converter.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/converter.js~fromJwkTo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/converter.js",
    "importStyle": "{fromJwkTo}",
    "description": "Convert JWK to ASN.1 (for RSA and EC) and Octet (for EC) encoded keys.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": ": 'pem', 'der', or 'oct' (only EC JWK)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "For EC JWK : options.compact = true or false\nFor EC JWK with output = 'oct' : options.format = 'binary' or 'string'\nFor both: outputPublic (optional) : boolean. derived key type. from private key, public key can be derived when true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 106,
    "kind": "function",
    "name": "toJwkFrom",
    "memberof": "packages/js-crypto-key-utils/src/converter.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/converter.js~toJwkFrom",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/converter.js",
    "importStyle": "{toJwkFrom}",
    "description": "Convert ASN.1 encoded (for RSA and EC) or octet formed (for EC) keys to JWK.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "type (optional) derived key type. from private key, public key can be derived."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/index.js",
    "content": "/**\n * index.js\n */\n\n// import {fromJwkTo, toJwkFrom} from './converter.js';\n// import {getJwkThumbprint} from './thumbprint.js';\n// import {isAsn1Encrypted} from './util.js';\nimport {Key} from './key.js';\n\n// export default {fromJwkTo, toJwkFrom, getJwkThumbprint, isAsn1Encrypted, Key};\n// export {fromJwkTo, toJwkFrom, getJwkThumbprint, isAsn1Encrypted, Key};\n\nexport default {Key};\nexport {Key};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/key.js",
    "content": "/**\n * key.js\n */\nimport {fromJwkTo, toJwkFrom} from './converter.js';\nimport {getJwkThumbprint} from './thumbprint.js';\nimport cloneDeep from 'lodash.clonedeep';\nimport jseu from 'js-encoding-utils';\nimport {getJwkType, getSec1KeyType, isAsn1Encrypted, isAsn1Public} from './util.js';\n\n/**\n * Key class\n */\nexport class Key {\n  /**\n   * @constructor\n   * @param format\n   * @param key\n   * @param options\n   */\n  constructor(format, key, options={}){\n    const localKey = cloneDeep(key);\n    const localOpt = cloneDeep(options);\n\n    this._jwk = {};\n    this._der = null;\n    this._oct = {}; // only for EC keys\n    this._current = {jwk: false, der: false, oct: false};\n\n    if(format === 'jwk'){\n      this._setJwk(localKey);\n    }\n    else if (format === 'der' || format === 'pem'){\n      if(format === 'der' && !(localKey instanceof Uint8Array)) throw new Error('DerKeyMustBeUint8Array');\n      if(format === 'pem' && (typeof localKey !== 'string')) throw new Error('PemKeyMustBeString');\n      this._setAsn1(localKey, format);\n    }\n    else if (format === 'oct'){\n      if(typeof localOpt.namedCurve !== 'string') throw new Error('namedCurveMustBeSpecified');\n      if(!(localKey instanceof Uint8Array)) throw new Error('OctetKeyMustBeUint8Array');\n      this._setSec1(localKey, localOpt.namedCurve);\n    }\n    else throw new Error('UnsupportedType');\n  }\n\n  ///////////////////////////////////////////////////////////\n  // private method handling instance variables\n  // all instance variables must be set via these methods\n  _setJwk(jwkey){\n    this._type = getJwkType(jwkey); // this also check key format\n    this._jwk = jwkey;\n    if(this._isEncrypted) this._der = null;\n    this._isEncrypted = false;\n    this._setCurrentStatus();\n  }\n\n  _setAsn1(asn1key, format){\n    this._type = (isAsn1Public(asn1key, format)) ? 'public' : 'private'; // this also check key format\n    this._isEncrypted = isAsn1Encrypted(asn1key, format);\n    this._der = (format === 'pem') ? jseu.formatter.pemToBin(asn1key): asn1key;\n    if(this._isEncrypted){\n      this._jwk = {};\n      this._oct = {};\n    }\n    this._setCurrentStatus();\n  }\n\n  _setSec1(sec1key, namedCurve){\n    this._type = getSec1KeyType(sec1key, namedCurve);  // this also check key format\n    this._oct = { namedCurve, key: sec1key };\n    if(this._isEncrypted) this._der = null;\n    this._isEncrypted = false;\n    this._setCurrentStatus();\n  }\n\n  _setCurrentStatus() {\n    this._current.jwk = (\n      typeof this._jwk.kty === 'string'\n      && (this._jwk.kty === 'RSA' || this._jwk.kty === 'EC')\n    );\n    this._current.der = (\n      typeof this._der !== 'undefined'\n      && this._der instanceof Uint8Array\n      && this._der.length > 0\n    );\n    this._current.oct = (\n      typeof this._oct.key !== 'undefined'\n      && this._oct.key instanceof Uint8Array\n      && this._oct.key.length > 0\n      && typeof this._oct.namedCurve === 'string'\n    );\n  }\n  ///////////////////////////////////////////////////////////\n  // (pseudo) public methods allowed to be accessed from outside\n  /**\n   * Wrapper of converter. Imported key must be basically decrypted except the case where the key is exported as-is.\n   * @param format {string}: 'jwk', 'pem', 'der' or 'oct'\n   * @param options {object}:\n   * - options.outputPublic {boolean}: (optional) [format = *]\n   *     derive public key from private key when options.outputPublic = true.\n   * - options.compact {boolean}: (optional) [format = 'der', 'pem' or 'oct', only for EC key]\n   *     generate compressed EC public key.\n   * - options.encryptParams {object}: (optional) [format = 'der' or 'pem'] options to generate encrypted der/pem private key.\n   *     * encryptParams.passphrase {string}: (mandatory if encOption is specified).\n   *          (re-)generate encrypted der/pem with the given passphrase\n   *     * encryptParams.algorithm {string}: (optional) 'pbes2' (default), 'pbeWithMD5AndDES-CBC' or 'pbeWithSHA1AndDES'\n   *     * encryptParams.prf {string}: (optional) [encOptions.algorithm = 'pbes2'],\n   *         'hmacWithSHA256' (default), 'hmacWithSHA384', 'hmacWithSHA512' or 'hmacWithSHA1'\n   *     * encryptParams.iterationCount {integer}: 2048 (default)\n   *     * encryptParams.cipher {string}: 'aes256-cbc' (default), 'aes128-cbc' or 'des-ede3-cbc'\n   * @return {Promise<*>}\n   */\n  async export(format = 'jwk', options={}){\n    // global assertion\n    if(['pem', 'der', 'jwk', 'oct'].indexOf(format) < 0) throw new Error('UnsupportedFormat');\n\n    // return 'as is' without passphrase when nothing is given as 'options'\n    // only for the case to export der key from der key (considering encrypted key). expect to be called from getter\n    if((format === 'der' || format === 'pem') && Object.keys(options).length === 0\n      && this._isEncrypted === true && this._type === 'private' && this._current.der)\n    {\n      return (format === 'pem') ? jseu.formatter.binToPem(this._der, 'encryptedPrivate') : this._der;\n    }\n    if(this._isEncrypted) throw new Error('DecryptionRequired');\n\n    let jwkey;\n    // first converted to jwk\n    if(this._current.jwk){\n      jwkey = this._jwk;\n    }\n    else {\n      // options.type is not specified here to import jwk\n      if(this._current.oct) {\n        jwkey = await toJwkFrom('oct', this._oct.key, {namedCurve: this._oct.namedCurve});\n      }\n      else if(this._current.der){\n        jwkey = await toJwkFrom('der', this._der);\n      }\n      else throw new Error('InvalidStatus');\n\n      this._setJwk(jwkey); // store jwk if the exiting private key is not encrypted\n    }\n\n    // then export as the key in intended format\n    if (format === 'der' || format === 'pem') {\n      if(typeof options.encryptParams === 'undefined') options.encryptParams = {};\n      return await fromJwkTo(format, jwkey, {\n        outputPublic: options.outputPublic,\n        compact: options.compact,\n        passphrase: options.encryptParams.passphrase,\n        encOptions: options.encryptParams\n      });\n    }\n    else if (format === 'oct') {\n      return await fromJwkTo(format, jwkey, {\n        outputPublic: options.outputPublic,\n        format: options.output,\n        compact: options.compact\n      });\n    }\n    else return jwkey;\n  }\n\n  /**\n   * Encrypt stored key and set the encrypted key to this instance.\n   * @param passphrase {string}\n   * @return {Promise<boolean>}\n   */\n  async encrypt (passphrase){\n    if(this._isEncrypted) throw new Error('AlreadyEncrypted');\n    const options = {encryptParams: {passphrase}};\n    this._setAsn1(await this.export('der', options), 'der');\n\n    return true;\n  }\n\n  /**\n   * Decrypted stored key and set the decrypted key in JWK to this instance.\n   * @param passphrase {string}\n   * @return {Promise<boolean>}\n   */\n  async decrypt (passphrase){\n    if(!this._isEncrypted) throw new Error('NotEncrypted');\n    let jwkey;\n    if(this._current.der && typeof passphrase === 'string'){\n      jwkey = await toJwkFrom('der', this._der, {passphrase}); // type is not specified here to import jwk\n    }\n    else throw new Error('FailedToDecrypt');\n    this._setJwk(jwkey);\n\n    return true;\n  }\n\n  async getJwkThumbprint(alg='SHA-256', output='binary'){\n    if(this._isEncrypted) throw new Error('DecryptionRequired');\n    return await getJwkThumbprint(await this.export('jwk'), alg, output);\n  }\n\n  // getters\n  get keyType(){\n    if(this._isEncrypted) throw new Error('DecryptionRequired');\n    return new Promise( async (resolve, reject) => {\n      const jwkey = await this.export('jwk').catch( (e) => {reject(e);});\n      resolve(jwkey.kty);\n    });\n  }\n\n  get jwkThumbprint(){\n    return this.getJwkThumbprint();\n  }\n\n  get isEncrypted(){ return this._isEncrypted; }\n\n  get isPrivate(){ return this._type === 'private'; }\n\n  get der(){ return this.export('der'); }\n\n  get pem(){ return this.export('pem'); }\n\n  get jwk(){ return this.export('jwk'); }\n\n  get oct(){ return this.export('oct', {output: 'string'});  }\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/key.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "class",
    "name": "Key",
    "memberof": "packages/js-crypto-key-utils/src/key.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/key.js",
    "importStyle": "{Key}",
    "description": "Key class",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 110,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_jwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_jwk",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "_der",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_der",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "_oct",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_oct",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "_current",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_current",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "{\"jwk\": *, \"der\": *, \"oct\": *}"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "_setJwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setJwk",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "jwkey",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "_type",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_type",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "_isEncrypted",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_isEncrypted",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "_setAsn1",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setAsn1",
    "access": "private",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "asn1key",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "_setSec1",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setSec1",
    "access": "private",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "sec1key",
        "types": [
          "*"
        ]
      },
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "_setCurrentStatus",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setCurrentStatus",
    "access": "private",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "export",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#export",
    "access": "public",
    "description": "Wrapper of converter. Imported key must be basically decrypted except the case where the key is exported as-is.",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "{string}: 'jwk', 'pem', 'der' or 'oct'"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "{object}:\n- options.outputPublic {boolean}: (optional) [format = *]\n    derive public key from private key when options.outputPublic = true.\n- options.compact {boolean}: (optional) [format = 'der', 'pem' or 'oct', only for EC key]\n    generate compressed EC public key.\n- options.encryptParams {object}: (optional) [format = 'der' or 'pem'] options to generate encrypted der/pem private key.\n    * encryptParams.passphrase {string}: (mandatory if encOption is specified).\n         (re-)generate encrypted der/pem with the given passphrase\n    * encryptParams.algorithm {string}: (optional) 'pbes2' (default), 'pbeWithMD5AndDES-CBC' or 'pbeWithSHA1AndDES'\n    * encryptParams.prf {string}: (optional) [encOptions.algorithm = 'pbes2'],\n        'hmacWithSHA256' (default), 'hmacWithSHA384', 'hmacWithSHA512' or 'hmacWithSHA1'\n    * encryptParams.iterationCount {integer}: 2048 (default)\n    * encryptParams.cipher {string}: 'aes256-cbc' (default), 'aes128-cbc' or 'des-ede3-cbc'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "encrypt",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#encrypt",
    "access": "public",
    "description": "Encrypt stored key and set the encrypted key to this instance.",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "decrypt",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#decrypt",
    "access": "public",
    "description": "Decrypted stored key and set the decrypted key in JWK to this instance.",
    "lineNumber": 181,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "getJwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#getJwkThumbprint",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "output",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "binary",
        "defaultValue": "binary"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "get",
    "name": "keyType",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#keyType",
    "access": "public",
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "get",
    "name": "jwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#jwkThumbprint",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "get",
    "name": "isEncrypted",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#isEncrypted",
    "access": "public",
    "description": null,
    "lineNumber": 211,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "get",
    "name": "isPrivate",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#isPrivate",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "get",
    "name": "der",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#der",
    "access": "public",
    "description": null,
    "lineNumber": 215,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "get",
    "name": "pem",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#pem",
    "access": "public",
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "get",
    "name": "jwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#jwk",
    "access": "public",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "get",
    "name": "oct",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#oct",
    "access": "public",
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/octenc.js",
    "content": "/**\n * octenc.js\n */\n\nimport params from './params.js';\nimport jseu from 'js-encoding-utils';\nimport elliptic from 'elliptic';\nimport {getJwkType, getSec1KeyType} from './util.js';\nconst Ec = elliptic.ec;\n\n\n/**\n * Convert JWK EC public/private keys to octet form\n * compressed form of ec public key: https://tools.ietf.org/html/rfc5480\n * @param jwkey\n * @param outputPublic {boolean} (optional)\n * @param outputFormat\n * @param compact\n * @return {*}\n */\nexport function fromJwk(jwkey, {outputPublic, outputFormat='binary', compact=false}){\n  // original key type\n  const orgType = getJwkType(jwkey);\n  const type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  if(type === 'public'){\n    const bufX = jseu.encoder.decodeBase64Url(jwkey.x);\n    const bufY = jseu.encoder.decodeBase64Url(jwkey.y);\n\n    let publicKey;\n    if(compact){\n      // compressed form\n      // http://www.secg.org/SEC1-Ver-1.0.pdf\n      publicKey = new Uint8Array(bufX.length + 1);\n      publicKey[0] = 0xFF & ( (0x01 & bufY.slice(-1)[0]) + 0x02 );\n      publicKey.set(bufX, 1);\n    }\n    else {\n      // uncompressed form\n      publicKey = new Uint8Array(bufX.length + bufY.length + 1);\n      publicKey[0]=0xFF & 0x04;\n      publicKey.set(bufX, 1);\n      publicKey.set(bufY, bufX.length+1);\n    }\n    return (outputFormat === 'string') ? jseu.encoder.arrayBufferToHexString(publicKey): publicKey;\n  }\n  else if (type === 'private'){\n    if (!jwkey.d) throw new Error('InvalidKey');\n    const bufD = jseu.encoder.decodeBase64Url(jwkey.d);\n    return (outputFormat === 'string') ? jseu.encoder.arrayBufferToHexString(bufD) : bufD;\n  }\n}\n\n/**\n * Convert Octet form of EC public/private keys to JWK\n * @param octkey\n * @param outputPublic {boolean} (optional)\n * @param namedCurve\n * @return {{kty: string, crv: *, x, y}}\n */\nexport function toJwk(octkey, namedCurve, {outputPublic}){\n  if (Object.keys(params.namedCurves).indexOf(namedCurve) < 0) throw new Error('UnsupportedCurve');\n\n  // original key type and check the key structure\n  const orgType = getSec1KeyType(octkey, namedCurve);\n  const type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  // format conversion\n  const binKey = (typeof octkey === 'string') ? jseu.encoder.hexStringToArrayBuffer(octkey): octkey;\n\n  // instantiation\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  // derive key object from binary key\n  const ecKey = (orgType === 'public') ? ec.keyFromPublic(binKey): ec.keyFromPrivate(binKey);\n  const publicKey = new Uint8Array(ecKey.getPublic('array'));\n  const len = params.namedCurves[namedCurve].payloadSize;\n\n  const bufX = publicKey.slice(1, len+1);\n  const bufY = publicKey.slice(len+1, len*2+1);\n\n  const jwKey = { // https://www.rfc-editor.org/rfc/rfc7518.txt\n    kty: 'EC',\n    crv: namedCurve,\n    x: jseu.encoder.encodeBase64Url(bufX), // oct to base64url\n    y: jseu.encoder.encodeBase64Url(bufY)\n    // ext: true\n  };\n\n  if(type === 'private'){\n    // octkey is exactly private key if type is private.\n    jwKey.d = jseu.encoder.encodeBase64Url(binKey);\n  }\n  return jwKey;\n}\n\n\n\nexport function octKeyObjFromJwk(jwkey, type, compact=false){\n  const octKeyObj = {};\n  octKeyObj.publicKey = fromJwk(jwkey, {outputFormat: 'binary', outputPublic: true, compact});\n  if(jwkey.d && type === 'private') octKeyObj.privateKey = fromJwk(jwkey, {outputFormat: 'binary', outputPublic: false, compact});\n\n  return octKeyObj;\n}\n\nexport function octKeyObjToJwk(octKeyObj, type, namedCurve) {\n  if (type !== 'public' && type !== 'private') throw new Error('InvalidType');\n  if (Object.keys(params.namedCurves).indexOf(namedCurve) < 0) throw new Error('UnsupportedCurve');\n\n  return (type === 'public')\n    ? toJwk(octKeyObj.publicKey, namedCurve, {outputPublic: true})\n    : toJwk(octKeyObj.privateKey, namedCurve, {outputPublic: false});\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/octenc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 145,
    "kind": "variable",
    "name": "Ec",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~Ec",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{fromJwk}",
    "description": "Convert JWK EC public/private keys to octet form\ncompressed form of ec public key: https://tools.ietf.org/html/rfc5480",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "outputPublic",
        "description": "{boolean} (optional)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "outputFormat",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "compact",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 147,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{toJwk}",
    "description": "Convert Octet form of EC public/private keys to JWK",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "octkey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "outputPublic",
        "description": "{boolean} (optional)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{kty: string, crv: *, x, y}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "octKeyObjFromJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~octKeyObjFromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{octKeyObjFromJwk}",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [
      {
        "name": "jwkey",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "compact",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "octKeyObjToJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~octKeyObjToJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{octKeyObjToJwk}",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "octKeyObj",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  // oid is referred to rfc5480 https://www.ietf.org/rfc/rfc5480.txt\n  namedCurves: {\n    'P-256': {indutnyName: 'p256', payloadSize: 32, oid: [1, 2, 840, 10045, 3, 1, 7]},\n    'P-384': {indutnyName: 'p384', payloadSize: 48, oid: [1, 3, 132, 0, 34]},\n    'P-521': {indutnyName: 'p521', payloadSize: 66, oid: [1, 3, 132, 0, 35]},\n    'P-256K': {indutnyName: 'secp256k1', payloadSize: 32, oid: [1, 3, 132, 0, 10]},\n  },\n\n  // https://tools.ietf.org/html/rfc3279\n  publicKeyAlgorithms: {\n    'EC': {oid: [1, 2, 840, 10045, 2, 1]},\n    'RSA': {oid: [1, 2, 840, 113549, 1, 1, 1]}\n  },\n\n  passwordBasedEncryptionSchemes: {\n    // PBES1\n    'pbeWithMD5AndDES-CBC': {oid: [1, 2, 840, 113549, 1, 5, 3 ], hash: 'MD5', encrypt: 'DES-CBC'},\n    'pbeWithSHA1AndDES-CBC': {oid: [1, 2, 840, 113549, 1, 5, 10 ], hash: 'SHA-1', encrypt: 'DES-CBC'},\n\n    // PBES2\n    'pbes2': {oid:  [ 1, 2, 840, 113549, 1, 5, 13 ]}\n  },\n\n  keyDerivationFunctions: {\n    'pbkdf2': {oid: [ 1, 2, 840, 113549, 1, 5, 12 ], defaultSaltLen: 8}\n  },\n\n  pbkdf2Prfs: {\n    'hmacWithSHA1': {oid: [1, 2, 840, 113549, 2, 7], hash: 'SHA-1'},\n    'hmacWithSHA256': {oid: [1, 2, 840, 113549, 2, 9], hash: 'SHA-256'},\n    'hmacWithSHA384': {oid: [1, 2, 840, 113549, 2, 10], hash: 'SHA-384'},\n    'hmacWithSHA512': {oid: [1, 2, 840, 113549, 2, 11], hash: 'SHA-512'}\n  },\n\n  encryptionSchemes: {\n    'des-ede3-cbc': {oid: [ 1, 2, 840, 113549, 3, 7 ], keyLength: 24, ivLength: 8},\n    'aes128-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 2 ], keyLength: 16, ivLength: 16},\n    'aes192-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 22 ], keyLength: 24, ivLength: 16},\n    'aes256-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 42 ], keyLength: 32, ivLength: 16}\n  },\n\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20}, // SHOULD NOT USE\n    'MD5': {hashSize: 16} // SHOULD NOT USE\n  }\n};\n\nexport function getAlgorithmFromOid(oid, oidDict){\n  return Object.keys(oidDict).filter( (k) => oidDict[k].oid.toString() === oid.toString());\n}\n\nexport const getAlgorithmFromOidStrict = (oid, dict) => {\n  const array = getAlgorithmFromOid(oid, dict);\n  if (array.length === 0) throw new Error('UnsupportedAlgorithm');\n  return array[0];\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "getAlgorithmFromOid",
    "memberof": "packages/js-crypto-key-utils/src/params.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/params.js~getAlgorithmFromOid",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/params.js",
    "importStyle": "{getAlgorithmFromOid}",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "oid",
        "types": [
          "*"
        ]
      },
      {
        "name": "oidDict",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "function",
    "name": "getAlgorithmFromOidStrict",
    "memberof": "packages/js-crypto-key-utils/src/params.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/params.js~getAlgorithmFromOidStrict",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/params.js",
    "importStyle": "{getAlgorithmFromOidStrict}",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "oid",
        "types": [
          "*"
        ]
      },
      {
        "name": "dict",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/rfc8018.js",
    "content": "/**\n * rfc8081\n */\n\nimport params, {getAlgorithmFromOidStrict} from './params.js';\nimport {PBES2ESParams, PBEParameter, PBES2Params, PBKDF2Params, OneAsymmetricKey, EncryptedPrivateKeyInfo} from './asn1def.js';\nimport des from 'des.js';\nimport BufferMod from 'buffer';\nimport asn from 'asn1.js';\nimport jseu from 'js-encoding-utils';\nimport pbkdf from 'js-crypto-pbkdf';\nimport jscaes from 'js-crypto-aes';\nimport jscrandom from 'js-crypto-random';\nconst Buffer = BufferMod.Buffer;\nconst BN = asn.bignum;\n\n///////////////////////////////////////////////////////////////////\nexport async function encryptEncryptedPrivateKeyInfo(binKey, passphrase, options = {}){\n  // default params\n  if(typeof options.algorithm === 'undefined') options.algorithm = 'pbes2';\n  if(typeof options.iterationCount === 'undefined') options.iterationCount = 2048;\n\n\n  if (options.algorithm === 'pbes2') {\n    if(typeof options.cipher === 'undefined') options.cipher = 'aes256-cbc';\n    if(typeof options.prf === 'undefined') options.prf = 'hmacWithSHA256';\n    const kdfAlgorithm = 'pbkdf2'; // TODO: currently only pbkdf2 is available\n\n    const encryptedPBES2 = await encryptPBES2(binKey, passphrase, kdfAlgorithm, options.prf, options.iterationCount, options.cipher);\n    return await encodePBES2(encryptedPBES2);\n  }\n  else {\n    const encryptedPBES1 = await encryptPBES1(binKey, passphrase, options.algorithm, options.iterationCount);\n    encryptedPBES1.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[encryptedPBES1.encryptionAlgorithm.algorithm].oid;\n    encryptedPBES1.encryptionAlgorithm.parameters = PBEParameter.encode(encryptedPBES1.encryptionAlgorithm.parameters, 'der');\n    return EncryptedPrivateKeyInfo.encode(encryptedPBES1, 'der');\n  }\n}\n\nexport async function decryptEncryptedPrivateKeyInfo(epki, passphrase){\n  const decoded = {};\n\n  // encryptionAlgorithm.algorithm\n  decoded.encryptionAlgorithm = {\n    algorithm: getAlgorithmFromOidStrict(epki.encryptionAlgorithm.algorithm, params.passwordBasedEncryptionSchemes)\n  };\n  if (decoded.encryptionAlgorithm.algorithm === 'pbes2') {\n    decoded.encryptionAlgorithm.parameters = decodePBES2(epki.encryptionAlgorithm.parameters);\n  }\n  else {\n    decoded.encryptionAlgorithm.parameters = PBEParameter.decode(epki.encryptionAlgorithm.parameters, 'der');\n  }\n\n  decoded.encryptedData = epki.encryptedData;\n\n  // decrypt\n  if(decoded.encryptionAlgorithm.algorithm === 'pbes2') {\n    return await decryptPBES2(decoded, passphrase);\n  }\n  else return await decryptPBES1(decoded, passphrase);\n}\n\n//////////////////////////////\nfunction encodePBES2(decoded){\n  const epki = { encryptionAlgorithm: {} };\n\n  // algorithm\n  epki.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].oid;\n\n  // kdf\n  const kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;\n  if(kdf.algorithm === 'pbkdf2') {\n    kdf.parameters.prf.algorithm = params.pbkdf2Prfs[kdf.parameters.prf.algorithm].oid;\n    kdf.parameters = PBKDF2Params.encode(kdf.parameters, 'der');\n  } else throw new Error('UnsupportedKDF');\n  kdf.algorithm = params.keyDerivationFunctions[kdf.algorithm].oid;\n\n  // encryptionScheme\n  const eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;\n  if(Object.keys(PBES2ESParams).indexOf(eS.algorithm) >= 0){\n    eS.parameters = PBES2ESParams[eS.algorithm].encode(eS.parameters, 'der');\n  } else throw new Error('UnsupportedCipher');\n  eS.algorithm = params.encryptionSchemes[eS.algorithm].oid;\n\n  // params\n  epki.encryptionAlgorithm.parameters = PBES2Params.encode({ keyDerivationFunc: kdf, encryptionScheme: eS }, 'der');\n\n  // encoded data\n  epki.encryptedData = decoded.encryptedData;\n  return EncryptedPrivateKeyInfo.encode(epki, 'der');\n}\n\nfunction decodePBES2(rawParams){\n  const pbes2Params = PBES2Params.decode(rawParams, 'der');\n\n  // keyDerivationFunc\n  const kdfAlgorithm = getAlgorithmFromOidStrict(pbes2Params.keyDerivationFunc.algorithm, params.keyDerivationFunctions);\n\n  let iterationCount;\n  let salt;\n  let prf;\n  if (kdfAlgorithm === 'pbkdf2') {\n    const pbkdf2Params = PBKDF2Params.decode(pbes2Params.keyDerivationFunc.parameters, 'der');\n    prf = {\n      algorithm: getAlgorithmFromOidStrict(pbkdf2Params.prf.algorithm, params.pbkdf2Prfs),\n      parameters: pbkdf2Params.prf.parameters\n    };\n    iterationCount = pbkdf2Params.iterationCount;\n    salt = {type: pbkdf2Params.salt.type, value: pbkdf2Params.salt.value};\n  } else throw new Error('UnsupportedKDF');\n\n  //encryptionScheme\n  const encryptionScheme = getAlgorithmFromOidStrict(pbes2Params.encryptionScheme.algorithm, params.encryptionSchemes);\n  let encryptionParams;\n  if(Object.keys(PBES2ESParams).indexOf(encryptionScheme) >= 0){\n    encryptionParams = PBES2ESParams[encryptionScheme].decode(pbes2Params.encryptionScheme.parameters, 'der');\n  } else throw new Error('UnsupportedCipher'); // TODO: Other Encryption Scheme\n\n  return {\n    keyDerivationFunc: {\n      algorithm: kdfAlgorithm,\n      parameters: { salt, iterationCount, prf }\n    },\n    encryptionScheme: {\n      algorithm: encryptionScheme,\n      parameters: encryptionParams\n    }\n  };\n}\n\n\n//////////////////////\n// PBES2 RFC8018 Section 6.2.1\nasync function encryptPBES2(binKey, passphrase, kdfAlgorithm, prf, iterationCount, cipher){\n  // kdf\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = await jscrandom.getRandomBytes(\n    params.keyDerivationFunctions[kdfAlgorithm].defaultSaltLen\n  ); // TODO: currently only salt length of 8 is available\n  const keyLength = params.encryptionSchemes[cipher].keyLength; // get keyLength\n\n  let key;\n  if (kdfAlgorithm === 'pbkdf2') {\n    key = await pbkdf.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash);\n  } else throw new Error('UnsupportedKDF');\n\n  // encrypt\n  let iv;\n  let encryptedData;\n  if (cipher === 'des-ede3-cbc') { // TODO other encryption schemes\n    iv = Buffer.from(await jscrandom.getRandomBytes(params.encryptionSchemes[cipher].ivLength));\n    const CBC = des.CBC.instantiate(des.EDE);\n    const ct = CBC.create({ type: 'encrypt', key: Buffer.from(key), iv });\n    encryptedData = Buffer.from(ct.update(binKey).concat(ct.final()));\n  }\n  else if (cipher === 'aes128-cbc' || cipher === 'aes192-cbc' || cipher === 'aes256-cbc'){\n    iv = await jscrandom.getRandomBytes(params.encryptionSchemes[cipher].ivLength);\n    encryptedData = Buffer.from( await jscaes.encrypt(\n      new Uint8Array(binKey), key, {name: 'AES-CBC', iv}\n    ));\n    iv = Buffer.from(iv);\n  } else throw new Error('UnsupportedCipher');\n\n  // structure\n  return {\n    encryptedData,\n    encryptionAlgorithm: {\n      algorithm: 'pbes2',\n      parameters: {\n        keyDerivationFunc: {\n          algorithm: kdfAlgorithm,\n          parameters: {\n            salt: {type: 'specified', value: Buffer.from(salt)},\n            iterationCount: new BN(iterationCount),\n            prf: {algorithm: prf, parameters: Buffer.from([0x05, 0x00])}\n          }\n        },\n        encryptionScheme: { algorithm: cipher, parameters: iv }\n      }\n    }\n  };\n}\n\n//////////////////////////////\n// PBES2 RFC8018 Section 6.2.2\nasync function decryptPBES2(decoded, passphrase){\n  const kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;\n  const eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;\n\n  // pbkdf2\n  const keyLength = params.encryptionSchemes[eS.algorithm].keyLength; // get keyLength\n  let key;\n  if(kdf.algorithm === 'pbkdf2') {\n    const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n    if (kdf.parameters.salt.type !== 'specified') throw new Error('UnsupportedSaltSource');\n    const salt = new Uint8Array(kdf.parameters.salt.value);\n    const iterationCount = kdf.parameters.iterationCount.toNumber();\n    const prf = kdf.parameters.prf.algorithm;\n    key = await pbkdf.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash);\n  }\n  else throw new Error('UnsupportedKDF');\n\n  // decryption\n  // TODO other encryption schemes\n  let out;\n  if(eS.algorithm === 'des-ede3-cbc'){\n    const iv = eS.parameters;\n    const CBC = des.CBC.instantiate(des.EDE);\n    const pt = CBC.create({ type: 'decrypt', key, iv });\n    out = Buffer.from(pt.update(decoded.encryptedData).concat(pt.final()));\n  }\n  else if (eS.algorithm === 'aes128-cbc' || eS.algorithm === 'aes192-cbc'|| eS.algorithm === 'aes256-cbc'){\n    const iv = new Uint8Array(eS.parameters);\n    out = Buffer.from( await jscaes.decrypt(\n      new Uint8Array(decoded.encryptedData), key, {name: 'AES-CBC', iv}\n    ));\n  } else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return OneAsymmetricKey.decode(out, 'der');\n}\n\n//////////////////////////////\n// PBES1 RFC8018 Section 6.1.1\nasync function encryptPBES1(binKey, passphrase, algorithm, iterationCount){\n  // pbkdf1\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = await jscrandom.getRandomBytes(8); // defined as 8 octet\n  const hash = params.passwordBasedEncryptionSchemes[algorithm].hash;\n  const keyIv = await pbkdf.pbkdf1(pBuffer, salt, iterationCount, 16, hash);\n  const key = keyIv.slice(0, 8);\n  const iv = keyIv.slice(8, 16);\n\n  // decryption\n  const encrypt = params.passwordBasedEncryptionSchemes[algorithm].encrypt;\n  let out;\n  // TODO: Other Encryption Scheme\n  if(encrypt === 'DES-CBC') {\n    const CBC = des.CBC.instantiate(des.DES);\n    const ct = CBC.create({type: 'encrypt', key, iv});\n    out = Buffer.from(ct.update(binKey).concat(ct.final()));\n  }\n  else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return {\n    encryptionAlgorithm: {\n      algorithm,\n      parameters: {\n        salt: Buffer.from(salt),\n        iterationCount: new BN(iterationCount)\n      }\n    },\n    encryptedData: out\n  };\n}\n\n//////////////////////////////\n// PBES1 RFC8018 Section 6.1.2\nasync function decryptPBES1(decoded, passphrase){\n  // pbkdf1\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = new Uint8Array(decoded.encryptionAlgorithm.parameters.salt);\n  const hash = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].hash;\n  const iterationCount = decoded.encryptionAlgorithm.parameters.iterationCount.toNumber();\n  const keyIv = await pbkdf.pbkdf1(pBuffer, salt, iterationCount, 16, hash);\n  const key = keyIv.slice(0, 8);\n  const iv = keyIv.slice(8, 16);\n\n  // decryption\n  const encrypt = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].encrypt;\n  let out;\n  // TODO: Other Encryption Scheme\n  if(encrypt === 'DES-CBC') {\n    const CBC = des.CBC.instantiate(des.DES);\n    const ct = CBC.create({type: 'decrypt', key, iv});\n    out = Buffer.from(ct.update(decoded.encryptedData).concat(ct.final()));\n  }\n  else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return OneAsymmetricKey.decode(out, 'der');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/rfc8018.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 154,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "encryptEncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptEncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": "{encryptEncryptedPrivateKeyInfo}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "binKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "function",
    "name": "decryptEncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptEncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": "{decryptEncryptedPrivateKeyInfo}",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "epki",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "function",
    "name": "encodePBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encodePBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "function",
    "name": "decodePBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decodePBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "rawParams",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"keyDerivationFunc\": *, \"encryptionScheme\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "function",
    "name": "encryptPBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptPBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "params": [
      {
        "name": "binKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      },
      {
        "name": "kdfAlgorithm",
        "types": [
          "*"
        ]
      },
      {
        "name": "prf",
        "types": [
          "*"
        ]
      },
      {
        "name": "iterationCount",
        "types": [
          "*"
        ]
      },
      {
        "name": "cipher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"encryptedData\": *, \"encryptionAlgorithm\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "decryptPBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptPBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 162,
    "kind": "function",
    "name": "encryptPBES1",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptPBES1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "binKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      },
      {
        "name": "algorithm",
        "types": [
          "*"
        ]
      },
      {
        "name": "iterationCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"encryptionAlgorithm\": *, \"encryptedData\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "decryptPBES1",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptPBES1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 258,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/thumbprint.js",
    "content": "/**\n * thumbprint.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport hash from 'js-crypto-hash';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n/**\n * Compute jwk public key thumprint specified in RFC7638\n * https://tools.ietf.org/html/rfc7638\n * @param jwkey\n * @param alg\n * @param output\n * @return {Promise<*>}\n */\nexport async function getJwkThumbprint(jwkey, alg='SHA-256', output='binary'){\n  // assertion\n  if(['hex', 'binary'].indexOf(output) < 0) throw new Error('UnsupportedOutputFormat');\n\n  let jsonString;\n  if(jwkey.kty === 'EC'){\n    jsonString = JSON.stringify({crv: jwkey.crv, kty: jwkey.kty, x: jwkey.x, y: jwkey.y});\n  }\n  else if (jwkey.kty === 'RSA'){\n    jsonString = JSON.stringify({e: jwkey.e, kty: jwkey.kty, n: jwkey.n});\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  const uint8json = new Uint8Array(Buffer.from(jsonString, 'utf8'));\n  const thumbPrintBuf = await hash.compute(uint8json, alg);\n\n  if(output === 'hex') return jseu.encoder.arrayBufferToHexString(thumbPrintBuf);\n  else if(output === 'base64') return jseu.encoder.encodeBase64(thumbPrintBuf);\n  else if (output === 'binary') return thumbPrintBuf;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/thumbprint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 165,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/thumbprint.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/thumbprint.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/thumbprint.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 166,
    "kind": "function",
    "name": "getJwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/thumbprint.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/thumbprint.js~getJwkThumbprint",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/thumbprint.js",
    "importStyle": "{getJwkThumbprint}",
    "description": "Compute jwk public key thumprint specified in RFC7638\nhttps://tools.ietf.org/html/rfc7638",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "alg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 167,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/util.js",
    "content": "/**\n * util.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport params from './params.js';\nimport {KeyStructure} from './asn1def.js';\n\n/**\n * Check if the given key is encrypted\n * @param key\n * @param format : pem or der\n * @return {boolean}\n */\nexport function isAsn1Encrypted(key, format='pem'){\n  let keyType;\n  try{ keyType = getAsn1KeyType(key, format);} catch(e) {return false;}\n  return keyType === 'encryptedPrivate';\n}\n\nexport function isAsn1Public(key, format='pem'){\n  let keyType;\n  try{ keyType = getAsn1KeyType(key, format);} catch(e) {return false;}\n  return (keyType === 'public');\n}\n\nexport function getAsn1KeyType(key, format='pem'){\n  // Peel the pem strings\n  const binKey = (format === 'pem') ? jseu.formatter.pemToBin(key, 'private') : key;\n\n  const decoded = KeyStructure.decode(Buffer.from(binKey), 'der');\n  if (decoded.type === 'encryptedPrivateKeyInfo') return 'encryptedPrivate';\n  else if (decoded.type === 'oneAsymmetricKey') return 'private';\n  else if (decoded.type === 'subjectPublicKeyInfo') return 'public';\n  else throw new Error('NotSpkiNorPkcs8Key');\n}\n\nexport function getSec1KeyType(sec1key, namedCurve){\n  let format;\n  if (sec1key instanceof Uint8Array) format = 'binary';\n  else if (typeof sec1key === 'string') format = 'string';\n  else throw new Error('InvalidObjectType');\n\n  const binKey = (format === 'string') ? jseu.encoder.hexStringToArrayBuffer(sec1key): sec1key;\n\n  const len = params.namedCurves[namedCurve].payloadSize;\n\n  // original key type\n  if (binKey.length <= len) return 'private';\n  else if (\n    (binKey.length === 2*len+1 && binKey[0] === 0x04)\n    || (binKey.length === len+1 && (binKey[0] === 0x02 || binKey[0] === 0x03))\n  ) return 'public';\n  else throw new Error('UnsupportedKeyStructure');\n}\n\nexport function getJwkType(jwkey){\n  if(jwkey.kty === 'EC'){\n    if (jwkey.x && jwkey.y && jwkey.d) return 'private';\n    else if (jwkey.x && jwkey.y) return 'public';\n    else throw new Error('InvalidECKey');\n  }\n  else if (jwkey.kty === 'RSA'){\n    if (jwkey.n && jwkey.e && jwkey.d && jwkey.p && jwkey.q && jwkey.dp && jwkey.dq && jwkey.qi) return 'private';\n    else if (jwkey.n && jwkey.e) return 'public';\n    else throw new Error('InvalidRSAKey');\n  }\n  else throw new Error('UnsupportedJWKType');\n}\n\n// for jwk formatting of RSA\n// https://tools.ietf.org/html/rfc7518#section-6.3\nexport function pruneLeadingZeros(array){\n  if(!(array instanceof Uint8Array)) throw new Error('NonUint8Array');\n\n  let offset = 0;\n  for (let i = 0; i < array.length; i++){\n    if(array[i] !== 0x00) break;\n    offset++;\n  }\n\n  const returnArray = new Uint8Array(array.length - offset);\n  returnArray.set(array.slice(offset, array.length));\n  return returnArray;\n}\n\n// for pem/oct/der formatting from jwk of RSA\nexport function appendLeadingZeros(array, len){\n  if(!(array instanceof Uint8Array)) throw new Error('NonUint8Array');\n  if(array.length > len) throw new Error('InvalidLength');\n\n  const returnArray = new Uint8Array(len); // initialized with zeros\n  returnArray.set(array, len - array.length);\n  return returnArray;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 168,
    "kind": "function",
    "name": "isAsn1Encrypted",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~isAsn1Encrypted",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{isAsn1Encrypted}",
    "description": "Check if the given key is encrypted",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ": pem or der"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "isAsn1Public",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~isAsn1Public",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{isAsn1Public}",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "pem",
        "defaultValue": "pem"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "getAsn1KeyType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getAsn1KeyType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getAsn1KeyType}",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "pem",
        "defaultValue": "pem"
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "function",
    "name": "getSec1KeyType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getSec1KeyType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getSec1KeyType}",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "sec1key",
        "types": [
          "*"
        ]
      },
      {
        "name": "namedCurve",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "function",
    "name": "getJwkType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getJwkType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getJwkType}",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "jwkey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "function",
    "name": "pruneLeadingZeros",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~pruneLeadingZeros",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{pruneLeadingZeros}",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "function",
    "name": "appendLeadingZeros",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~appendLeadingZeros",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{appendLeadingZeros}",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "len",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/index.js",
    "content": "/**\n * index.js\n */\nimport {pbkdf2, pbkdf1} from './pbkdf.js';\n\nexport default {pbkdf2, pbkdf1}; // both export and export default needs to be declared for compatibility on node and browser.\nexport {pbkdf2, pbkdf1};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20}, // SHOULD NOT USE\n    'MD5': {hashSize: 16} // SHOULD NOT USE\n  }\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "content": "/**\n * pbkdf.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport jschash from 'js-crypto-hash';\nimport jschmac from 'js-crypto-hmac';\nimport params from './params.js';\n\n/**\n * Password-based key derivation function 2\n * @param p {Uint8Array|String}: password buffer. if string, it will be converted to Uint8Array\n * @param s {Uint8Array}: salt\n * @param c {Number}: iteration count\n * @param dkLen {Number}: intended output key length in octet\n * @param hash {String}: name of underlying hash function for HMAC like 'SHA-256', used as a pseudorandom function\n * @return {Promise<Uint8Array>}: the derived key\n */\nexport async function pbkdf2(p, s, c, dkLen, hash) {\n  assertPbkdf(p, s, c, dkLen, hash);\n  if(typeof p === 'string') p = jseu.encoder.stringToArrayBuffer(p);\n\n  const hLen = params.hashes[hash].hashSize;\n  if(dkLen > (Math.pow(2, 32) - 1) * hLen) throw new Error('DerivedKeyTooLong');\n\n  const l = Math.ceil(dkLen/hLen);\n  const r = dkLen - (l-1)*hLen;\n\n  const funcF = async (i) => {\n    const seed = new Uint8Array(s.length + 4);\n    seed.set(s);\n    seed.set(nwbo(i+1, 4), s.length);\n    let u = await jschmac.compute(p, seed, hash);\n    let outputF = new Uint8Array(u);\n    for(let j = 1; j < c; j++){\n      u = await jschmac.compute(p, u, hash);\n      outputF = u.map( (elem, idx) => elem ^ outputF[idx]);\n    }\n    return {index: i, value: outputF};\n  };\n  const Tis = [];\n  const DK = new Uint8Array(dkLen);\n  for(let i = 0; i < l; i++) Tis.push(funcF(i));\n  const TisResolved = await Promise.all(Tis);\n  TisResolved.forEach( (elem) => {\n    if (elem.index !== l - 1) DK.set(elem.value, elem.index*hLen);\n    else DK.set(elem.value.slice(0, r), elem.index*hLen);\n  });\n\n  return DK;\n}\n\n// network byte order\nconst nwbo = (num, len) => {\n  const arr = new Uint8Array(len);\n  for(let i=0; i<len; i++) arr[i] = 0xFF && (num >> ((len - i - 1)*8));\n  return arr;\n};\n\n\n/**\n * Password-based key derivation function 1\n * @param p {Uint8Array|String}: password buffer. if string, it will be converted to Uint8Array\n * @param s {Uint8Array}: salt\n * @param c {Number}: iteration count\n * @param dkLen {Number}: intended output key length\n * @param hash {String}: name of underlying hash function like 'SHA-256'\n * @return {Promise<Uint8Array>}: the derived key\n */\nexport async function pbkdf1(p, s, c, dkLen, hash){\n  assertPbkdf(p, s, c, dkLen, hash);\n  if(typeof p === 'string') p = jseu.encoder.stringToArrayBuffer(p);\n\n  if(dkLen > params.hashes[hash].hashSize) throw new Error('DerivedKeyTooLong');\n\n  let seed = new Uint8Array(p.length + s.length);\n  seed.set(p);\n  seed.set(s, p.length);\n  for(let i = 0; i < c; i++){\n    seed = await jschash.compute(seed, hash);\n  }\n  return seed.slice(0, dkLen);\n}\n\n// assertion\nfunction assertPbkdf(p, s, c, dkLen, hash){\n  if (typeof p !== 'string' && !(p instanceof Uint8Array)) throw new Error('PasswordIsNotUint8ArrayNorString');\n  if (!(s instanceof Uint8Array)) throw new Error('SaltMustBeUint8Array');\n  if (typeof c !== 'number' || c <= 0)throw new Error('InvalidIterationCount');\n  if (typeof dkLen !== 'number' || dkLen <= 0) throw new Error('InvalidDerivedKeyLength');\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHashAlgorithm');\n  return true;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/pbkdf.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "pbkdf2",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~pbkdf2",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": "{pbkdf2}",
    "description": "Password-based key derivation function 2",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "{Uint8Array|String}: password buffer. if string, it will be converted to Uint8Array"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "{Uint8Array}: salt"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": "{Number}: iteration count"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dkLen",
        "description": "{Number}: intended output key length in octet"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "{String}: name of underlying hash function for HMAC like 'SHA-256', used as a pseudorandom function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{Promise<Uint8Array>}: the derived key"
    }
  },
  {
    "__docId__": 179,
    "kind": "function",
    "name": "nwbo",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~nwbo",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      },
      {
        "name": "len",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 180,
    "kind": "function",
    "name": "pbkdf1",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~pbkdf1",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": "{pbkdf1}",
    "description": "Password-based key derivation function 1",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "{Uint8Array|String}: password buffer. if string, it will be converted to Uint8Array"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "{Uint8Array}: salt"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": "{Number}: iteration count"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dkLen",
        "description": "{Number}: intended output key length"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "{String}: name of underlying hash function like 'SHA-256'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{Promise<Uint8Array>}: the derived key"
    }
  },
  {
    "__docId__": 181,
    "kind": "function",
    "name": "assertPbkdf",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~assertPbkdf",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "s",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "dkLen",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 182,
    "kind": "file",
    "name": "packages/js-crypto-random/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {getRandomBytes, getRandomAsciiString} from './random.js';\n\nexport default {getRandomBytes, getRandomAsciiString};\nexport {getRandomBytes, getRandomAsciiString};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 183,
    "kind": "file",
    "name": "packages/js-crypto-random/src/random.js",
    "content": "/**\n * random.js\n */\n\nimport * as util from './util.js';\n\n/**\n * secure random 'ASCII' string generator based on getRandomBytes;\n * @param len\n * @return {string}\n */\nexport function getRandomAsciiString(len) {\n  const array = getRandomBytes(len);\n  let finalString = '';\n\n  // Ascii code excluding control characters are in 0x20 -- 0x7e\n  for (let i = 0; i < len; i++) {\n    array[i] = (array[i] % 0x5e) + 0x20;\n    finalString += String.fromCharCode(array[i]);\n  }\n\n  return finalString;\n}\n\n\n/**\n * secure random generator that returns uint 8 array filled with cryptographically secure random bytes\n * @param len\n * @return {Uint8Array}\n */\nexport function getRandomBytes(len) {\n  const webCrypto = util.getWebCryptoAll(); // web crypto api or ms crypto\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let array;\n\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.getRandomValues === 'function') {\n    array = new Uint8Array(len);\n    webCrypto.getRandomValues(array); // for modern browsers or legacy ie 11\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    array = new Uint8Array(nodeCrypto.randomBytes(len));\n  } else {\n    throw new Error('UnsupportedEnvironment');\n  }\n\n  return array;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/src/random.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "getRandomAsciiString",
    "memberof": "packages/js-crypto-random/src/random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/random.js~getRandomAsciiString",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/random.js",
    "importStyle": "{getRandomAsciiString}",
    "description": "secure random 'ASCII' string generator based on getRandomBytes;",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "getRandomBytes",
    "memberof": "packages/js-crypto-random/src/random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/random.js~getRandomBytes",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/random.js",
    "importStyle": "{getRandomBytes}",
    "description": "secure random generator that returns uint 8 array filled with cryptographically secure random bytes",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "packages/js-crypto-random/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.crypto) return window.crypto;\n    else if (window.msCrypto) return window.msCrypto;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "getWebCryptoAll",
    "memberof": "packages/js-crypto-random/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/util.js~getWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/util.js",
    "importStyle": "{getWebCryptoAll}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-random/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {generateKey, sign, verify, encrypt, decrypt} from './rsa.js';\n\nexport default {generateKey, sign, verify, encrypt, decrypt};\nexport {generateKey, sign, verify, encrypt, decrypt};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 190,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\nimport * as oaep from './oaep.js';\nimport BN from 'bn.js';\n\n// TODO: Currently not implemented in Node.js. Will be available from Node.js v10.12.0.\nexport async function generateKey(modulusLength = 2048, publicExponent = new Uint8Array([0x01, 0x00, 0x01]), nodeCrypto){\n  const pe = new BN(publicExponent);\n  const options = {\n    modulusLength: (typeof modulusLength !== 'number') ? parseInt(modulusLength, 10) : modulusLength,\n    publicExponent: pe.toNumber(),\n    publicKeyEncoding: {type: 'spki', format: 'der'},\n    privateKeyEncoding: {type: 'pkcs8', format: 'der'}\n\n  };\n  const nodeKeyGen = () => new Promise( (resolve, reject) => {\n    nodeCrypto.generateKeyPair('rsa', options,\n      (err, publicKey, privateKey) => {\n        if (err) reject('KeyGenerationFailedNode');\n        else resolve({publicKey, privateKey});\n      });\n  });\n  const keyPairDer = await nodeKeyGen().catch( () => {throw new Error('KeyGenerationFailedNode');});\n  const publicObj = new Key('der', new Uint8Array(keyPairDer.publicKey));\n  const privateObj = new Key('der', new Uint8Array(keyPairDer.privateKey));\n  return {\n    publicKey: await publicObj.export('jwk'),\n    privateKey: await privateObj.export('jwk')\n  };\n}\n\nexport async function sign(msg, privateJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: 192}, nodeCrypto) {\n  const keyObj = new Key('jwk', privateJwk);\n  if(!keyObj.isPrivate) throw new Error('NotPrivateKeyForRSASign');\n  const privatePem = await keyObj.export('pem');\n  const sign = nodeCrypto.createSign(params.hashes[hash].nodeName);\n  sign.update(msg);\n  const opt = (algorithm.name === 'RSA-PSS') ? {saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING} : {};\n  return new Uint8Array(sign.sign(Object.assign({key: privatePem}, opt)));\n}\n\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: 192}, nodeCrypto) {\n  const keyObj = new Key('jwk', publicJwk);\n  if(keyObj.isPrivate) throw new Error('NotPublicKeyForRSAVerify');\n  const publicPem = await keyObj.export('pem', {outputPublic: true});\n  const verify = nodeCrypto.createVerify(params.hashes[hash].nodeName);\n  verify.update(msg);\n  const opt = (algorithm.name === 'RSA-PSS') ? {saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING} : {};\n  return verify.verify(Object.assign({key: publicPem}, opt), signature);\n}\n\n\nexport async function encrypt(msg, publicJwk, hash = 'SHA-256', label = new Uint8Array([]), nodeCrypto){\n  const keyObj = new Key('jwk', publicJwk);\n  if(keyObj.isPrivate) throw new Error('NotPublicKeyForRSAEncrypt');\n  const publicPem = await keyObj.export('pem', {outputPublic: true});\n\n  let encrypted;\n  if(hash === 'SHA-1') {\n    encrypted = nodeCrypto.publicEncrypt({key: publicPem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING}, msg);\n  } else {\n    // https://tools.ietf.org/html/rfc3447\n    const em = await oaep.emeOaepEncode(msg, label, jseu.encoder.decodeBase64Url(publicJwk.n).length, hash);\n    encrypted = nodeCrypto.publicEncrypt({key: publicPem, padding: nodeCrypto.constants.RSA_NO_PADDING}, em);\n  }\n  return new Uint8Array(encrypted);\n}\n\nexport async function decrypt(data, privateJwk, hash = 'SHA-256', label = new Uint8Array([]), nodeCrypto){\n  const keyObj = new Key('jwk', privateJwk);\n  if(!keyObj.isPrivate) throw new Error('NotPrivateKeyForRSADecrypt');\n  const privatePem = await keyObj.export('pem');\n\n  let decrypted;\n  if(hash === 'SHA-1') {\n    decrypted = nodeCrypto.privateDecrypt({key: privatePem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING}, data);\n  } else {\n    // https://tools.ietf.org/html/rfc3447\n    const em = nodeCrypto.privateDecrypt({key: privatePem, padding: nodeCrypto.constants.RSA_NO_PADDING}, data);\n    decrypted = await oaep.emeOaepDecode(new Uint8Array(em), label, jseu.encoder.decodeBase64Url(privateJwk.n).length, hash);\n  }\n  return new Uint8Array(decrypted);\n}\n\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 191,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{generateKey}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "modulusLength",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 2048,
        "defaultValue": "2048"
      },
      {
        "name": "publicExponent",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"publicKey\": *, \"privateKey\": *}"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{sign}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "algorithm",
        "optional": true,
        "types": [
          "{\"name\": string, \"saltLength\": number}"
        ],
        "defaultRaw": {
          "name": "RSA-PSS",
          "saltLength": 192
        },
        "defaultValue": "{\"name\":\"RSA-PSS\",\"saltLength\":192}"
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{verify}",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "algorithm",
        "optional": true,
        "types": [
          "{\"name\": string, \"saltLength\": number}"
        ],
        "defaultRaw": {
          "name": "RSA-PSS",
          "saltLength": 192
        },
        "defaultValue": "{\"name\":\"RSA-PSS\",\"saltLength\":192}"
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{encrypt}",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "label",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "label",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/oaep.js",
    "content": "/**\n * oaep.js\n */\nimport params from './params.js';\nimport jschash from 'js-crypto-hash';\nimport random from 'js-crypto-random';\n\n\n// RFC3447 https://tools.ietf.org/html/rfc3447\n/*\n      # Encryption\n      a. If the length of L is greater than the input limitation for the\n         hash function (2^61 - 1 octets for SHA-1), output \"label too\n         long\" and stop.\n\n      b. If mLen > k - 2hLen - 2, output \"message too long\" and stop.\n\n      # Decryption\n      a. If the length of L is greater than the input limitation for the\n         hash function (2^61 - 1 octets for SHA-1), output \"decryption\n         error\" and stop.\n\n      b. If the length of the ciphertext C is not k octets, output\n         \"decryption error\" and stop.\n\n      c. If k < 2hLen + 2, output \"decryption error\" and stop.\n */\nexport function checkLength(mode, {k, label, hash, mLen, cLen}){\n  if (mode === 'encrypt') {\n    if (label.length > (1 << params.hashes[hash].maxInput) - 1) throw new Error('LabelTooLong');\n    if (mLen > k - 2 * params.hashes[hash].hashSize - 2) throw new Error('MessageTooLong');\n  }\n  else if (mode === 'decrypt') {\n    if (label.length > (1 << params.hashes[hash].maxInput) - 1) throw new Error('DecryptionError');\n    if (cLen !== k || k < 2 * params.hashes[hash].hashSize + 2) throw new Error('DecryptionError');\n  }\n  else throw new Error('InvalidMode');\n}\n\n\n/*\n      a. If the label L is not provided, let L be the empty string. Let\n         lHash = Hash(L), an octet string of length hLen (see the note\n         below).\n\n      b. Generate an octet string PS consisting of k - mLen - 2hLen - 2\n         zero octets.  The length of PS may be zero.\n\n      c. Concatenate lHash, PS, a single octet with hexadecimal value\n         0x01, and the message M to form a data block DB of length k -\n         hLen - 1 octets as\n\n            DB = lHash || PS || 0x01 || M.\n\n      d. Generate a random octet string seed of length hLen.\n\n      e. Let dbMask = MGF(seed, k - hLen - 1).\n\n      f. Let maskedDB = DB \\xor dbMask.\n\n      g. Let seedMask = MGF(maskedDB, hLen).\n\n      h. Let maskedSeed = seed \\xor seedMask.\n\n      i. Concatenate a single octet with hexadecimal value 0x00,\n         maskedSeed, and maskedDB to form an encoded message EM of\n         length k octets as\n\n            EM = 0x00 || maskedSeed || maskedDB.\n */\nexport async function emeOaepEncode(msg, label, k, hash='SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n\n  let ps = new Uint8Array(k - msg.length - (2*hashSize) - 2);\n  ps = ps.map( () => 0x00);\n\n  const lHash = await jschash.compute(label, hash);\n\n  const db = new Uint8Array(k - hashSize - 1);\n  db.set(lHash);\n  db.set(ps, hashSize);\n  db.set(new Uint8Array([0x01]), k- msg.length - hashSize - 2);\n  db.set(msg, k - msg.length - hashSize - 1);\n\n  const seed = await random.getRandomBytes(hashSize);\n\n  const dbMask = await mgf1(seed, k - hashSize - 1, hash);\n\n  const maskedDb = db.map( (elem, idx) => 0xFF & (elem ^ dbMask[idx]));\n\n  const seedMask = await mgf1(maskedDb, hashSize, hash);\n\n  const maskedSeed = seed.map( (elem, idx) => 0xFF & (elem ^ seedMask[idx]));\n\n  const em = new Uint8Array(k);\n  em.set(new Uint8Array([0x00]));\n  em.set(maskedSeed, 1);\n  em.set(maskedDb, hashSize + 1);\n\n  return em;\n}\n\n\n/*\n      a. If the label L is not provided, let L be the empty string. Let\n         lHash = Hash(L), an octet string of length hLen (see the note\n         in Section 7.1.1).\n\n      b. Separate the encoded message EM into a single octet Y, an octet\n         string maskedSeed of length hLen, and an octet string maskedDB\n         of length k - hLen - 1 as\n\n            EM = Y || maskedSeed || maskedDB.\n\n      c. Let seedMask = MGF(maskedDB, hLen).\n\n      d. Let seed = maskedSeed \\xor seedMask.\n\n      e. Let dbMask = MGF(seed, k - hLen - 1).\n\n      f. Let DB = maskedDB \\xor dbMask.\n\n      g. Separate DB into an octet string lHash' of length hLen, a\n         (possibly empty) padding string PS consisting of octets with\n         hexadecimal value 0x00, and a message M as\n\n            DB = lHash' || PS || 0x01 || M.\n\n         If there is no octet with hexadecimal value 0x01 to separate PS\n         from M, if lHash does not equal lHash', or if Y is nonzero,\n         output \"decryption error\" and stop.  (See the note below.)\n */\n\nexport async function emeOaepDecode(em, label, k, hash='SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n\n  const lHash = await jschash.compute(label, hash); // must be equal to lHashPrime\n\n  const y = em[0]; // must be zero\n  if (y !== 0x00) throw new Error('DecryptionError');\n\n  const maskedSeed = em.slice(1, hashSize+1);\n  const maskedDb = em.slice(hashSize+1, em.length);\n\n  const seedMask = await mgf1(maskedDb, hashSize, hash);\n  const seed = maskedSeed.map( (elem, idx) => 0xFF & (elem ^ seedMask[idx]));\n\n  const dbMask = await mgf1(seed, k-hashSize-1, hash);\n  const db = maskedDb.map( (elem, idx) => 0xFF & (elem ^ dbMask[idx]));\n\n  const lHashPrime = db.slice(0, hashSize);\n\n  if(lHashPrime.toString() !== lHash.toString()) throw new Error('DecryptionError');\n\n  let offset;\n  for(let i = hashSize; i < db.length; i++){\n    if(db[i] !== 0x00){\n      offset = i;\n      break;\n    }\n  }\n  const separator = db[offset];\n  if(separator !== 0x01) throw new Error('DecryptionError');\n\n  return db.slice(offset+1, db.length);\n}\n\n\n/**\n * mask generation function 1 (MGF1)\n * @param seed\n * @param len\n * @param hash\n * @return {Promise<Uint8Array>}\n */\nasync function mgf1(seed, len, hash = 'SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n  const blockLen = Math.ceil(len/ hashSize);\n\n  const t = new Uint8Array(blockLen*hashSize);\n\n  for(let i = 0; i < blockLen; i++) {\n    const c = i2osp(i, 4);\n    const x = new Uint8Array(seed.length + 4);\n    x.set(seed);\n    x.set(c, seed.length);\n    const y = await jschash.compute(x, hash);\n    t.set(y, i * hashSize);\n  }\n  return t.slice(0, len);\n}\n\nfunction i2osp(x, len){\n  const r = new Uint8Array(len);\n  r.forEach( (elem, idx) => {\n    const y = 0xFF & (x >> (idx*8));\n    r[len - idx - 1] = y;\n  });\n  return r;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/oaep.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 197,
    "kind": "function",
    "name": "checkLength",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~checkLength",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{checkLength}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "mode",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"k\": *, \"label\": *, \"hash\": *, \"mLen\": *, \"cLen\": *}"
        ],
        "defaultRaw": {
          "k": null,
          "label": null,
          "hash": null,
          "mLen": null,
          "cLen": null
        },
        "defaultValue": "{\"k\":null,\"label\":null,\"hash\":null,\"mLen\":null,\"cLen\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "function",
    "name": "emeOaepEncode",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~emeOaepEncode",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{emeOaepEncode}",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "label",
        "types": [
          "*"
        ]
      },
      {
        "name": "k",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "function",
    "name": "emeOaepDecode",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~emeOaepDecode",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{emeOaepDecode}",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "params": [
      {
        "name": "em",
        "types": [
          "*"
        ]
      },
      {
        "name": "label",
        "types": [
          "*"
        ]
      },
      {
        "name": "k",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "mgf1",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~mgf1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": null,
    "description": "mask generation function 1 (MGF1)",
    "lineNumber": 176,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "seed",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "function",
    "name": "i2osp",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~i2osp",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "len",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  // maxInput: 2^maxInput - 1 octets\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32, maxInput: 61},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48, maxInput: 125},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64, maxInput: 125},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20, maxInput: 61},\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/pss.js",
    "content": "/**\n * pss.js\n */\n\nimport params from './params.js';\n\n// RFC3447 https://tools.ietf.org/html/rfc3447\n/*\n       # Sign\n       - If the length of M is greater than the input limitation for the\n       hash function (2^61 - 1 octets for SHA-1), output \"message too\n       long\" and stop.\n\n       - If emLen < hLen + sLen + 2, output \"encoding error\" and stop.\n\n       # Verify\n       - If the length of M is greater than the input limitation for the\n       hash function (2^61 - 1 octets for SHA-1), output \"inconsistent\"\n       and stop.\n\n       - If emLen < hLen + sLen + 2, output \"inconsistent\" and stop.\n */\n// emLen = Math.ceil((modBits(=k) - 1)/8), e.g., Math.ceil(2047/8) = 256, that is exactly equal to k)\nexport function checkLength(mode, {k, hash, saltLength}){\n  if(mode === 'sign'){\n    if (k > (1 << params.hashes[hash].maxInput) - 1) throw new Error('Inconsistent');\n    if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0) throw new Error('EncodingError');\n  }\n  else if (mode === 'verify') {\n    if (k > (1 << params.hashes[hash].maxInput) - 1) throw new Error('Inconsistent');\n    if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0) throw new Error('Inconsistent');\n  }\n  else throw new Error('InvalidMode');\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/pss.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 204,
    "kind": "function",
    "name": "checkLength",
    "memberof": "packages/js-crypto-rsa/src/pss.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/pss.js~checkLength",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/pss.js",
    "importStyle": "{checkLength}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "mode",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"k\": *, \"hash\": *, \"saltLength\": *}"
        ],
        "defaultRaw": {
          "k": null,
          "hash": null,
          "saltLength": null
        },
        "defaultValue": "{\"k\":null,\"hash\":null,\"saltLength\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 205,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/rsa.js",
    "content": "/**\n * rsa.js\n */\n\nimport * as util from './util.js';\nimport * as webapi from './webapi.js';\nimport * as nodeapi from './nodeapi.js';\nimport params from './params.js';\nimport {checkLength as checkOaepLength} from './oaep.js';\nimport {checkLength as checkPssLength} from './pss.js';\nimport jseu from 'js-encoding-utils';\n\n/**\n *\n * @param modulusLength\n * @param publicExponent\n * @return {Promise<void>}\n */\nexport async function generateKey(modulusLength = 2048, publicExponent = new Uint8Array([0x01, 0x00, 0x01])){\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let keyPair = {};\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.generateKey === 'function' && typeof webCrypto.exportKey === 'function') { // for web API\n    keyPair = await webapi.generateKey(modulusLength, publicExponent, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try{\n      keyPair = await nodeapi.generateKey(modulusLength, publicExponent, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to purejs implementation\n    throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    // try{\n    //   keyPair = await purejs.generateKey(namedCurve);\n    // } catch (e) { throw new Error('UnsupportedEnvironment');}\n  }\n\n  return keyPair;\n}\n\n/**\n *\n * @param msg\n * @param privateJwk\n * @param hash\n * @param algorithm\n * @return {Promise<*>}\n */\nexport async function sign(msg, privateJwk, hash = 'SHA-256', algorithm) {\n  if (typeof algorithm === 'undefined') algorithm = {name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize};\n\n  // assertion\n  if (algorithm.name !== 'RSA-PSS' && algorithm.name !== 'RSASSA-PKCS1-v1_5') throw new Error('InvalidAlgorithm');\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(msg instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (privateJwk.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  if (algorithm.name === 'RSA-PSS'){\n    checkPssLength('sign', {k: jseu.encoder.decodeBase64Url(privateJwk.n).length, hash, saltLength: algorithm.saltLength});\n  }\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let signature;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') { // for web API\n    signature = await webapi.sign(msg, privateJwk, hash, algorithm, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try {\n      signature = await nodeapi.sign(msg, privateJwk, hash, algorithm, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to purejs implementation\n    throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    // try{\n    //   signature = await purejs.sign(msg, privateJwk, hash, algorithm, signatureFormat);\n    // } catch (e) { throw new Error('UnsupportedEnvironment');}\n  }\n  return signature;\n\n}\n\n/**\n *\n * @param msg\n * @param signature\n * @param publicJwk\n * @param hash\n * @param algorithm\n * @return {Promise<*>}\n */\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', algorithm) {\n  if (typeof algorithm === 'undefined') algorithm = {name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize};\n\n  // assertion\n  if (algorithm.name !== 'RSA-PSS' && algorithm.name !== 'RSASSA-PKCS1-v1_5') throw new Error('InvalidAlgorithm');\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(signature instanceof Uint8Array)) throw new Error('InvalidSignatureFormat');\n  if (!(msg instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (publicJwk.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  if (algorithm.name === 'RSA-PSS'){\n    checkPssLength('verify', {k: jseu.encoder.decodeBase64Url(publicJwk.n).length, hash, saltLength: algorithm.saltLength});\n  }\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let valid;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.verify === 'function') { // for web API\n    valid = await webapi.verify(msg, signature, publicJwk, hash, algorithm, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    try {\n      valid = await nodeapi.verify(msg, signature, publicJwk, hash, algorithm, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to purejs implementation\n    throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    // try{\n    //   signature = await purejs.verify(msg, signature, publicJwk, hash, algorithm);\n    // } catch (e) { throw new Error('UnsupportedEnvironment');}\n  }\n  return valid;\n}\n\n/**\n *\n * @param msg\n * @param publicJwk\n * @param hash\n * @param label\n * @return {Promise<*>}\n */\nexport async function encrypt(msg, publicJwk, hash = 'SHA-256', label = new Uint8Array([])){\n  // assertion\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(msg instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (!(label instanceof Uint8Array)) throw new Error('InvalidLabelFormat');\n  if (publicJwk.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  checkOaepLength('encrypt', {k: jseu.encoder.decodeBase64Url(publicJwk.n).length, label, hash, mLen: msg.length});\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let encrypted;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') { // for web API\n    encrypted = await webapi.encrypt(msg, publicJwk, hash, label, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    try {\n      encrypted = nodeapi.encrypt(msg, publicJwk, hash, label, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to purejs implementation\n    throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n  }\n  return encrypted;\n}\n\n/**\n *\n * @param data\n * @param privateJwk\n * @param hash\n * @param label\n * @return {Promise<*>}\n */\nexport async function decrypt(data, privateJwk, hash = 'SHA-256', label = new Uint8Array([])){\n  // assertion\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(data instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (!(label instanceof Uint8Array)) throw new Error('InvalidLabelFormat');\n  if (privateJwk.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  checkOaepLength('decrypt', {k: jseu.encoder.decodeBase64Url(privateJwk.n).length, label, hash, cLen: data.length});\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let decrypted;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.decrypt === 'function') { // for web API\n    decrypted = await webapi.decrypt(data, privateJwk, hash, label, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    try {\n      decrypted = nodeapi.decrypt(data, privateJwk, hash, label, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to purejs implementation\n    throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n  }\n  return decrypted;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{generateKey}",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "modulusLength",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicExponent",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{sign}",
    "description": "",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 208,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{verify}",
    "description": "",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 209,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{encrypt}",
    "description": "",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 210,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{decrypt}",
    "description": "",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 211,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport function getWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.msCrypto) return window.msCrypto.subtle;\n    if (window.crypto) return window.crypto.subtle;\n  }\n}\n\nexport function getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "function",
    "name": "getWebCryptoAll",
    "memberof": "packages/js-crypto-rsa/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/util.js~getWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/util.js",
    "importStyle": "{getWebCryptoAll}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-rsa/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/util.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/util.js",
    "importStyle": "{getNodeCrypto}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\nimport jseu from 'js-encoding-utils';\n\nexport async function generateKey(modulusLength = 2048, publicExponent = new Uint8Array([0x01, 0x00, 0x01]), webCrypto){\n  // generate rsa key\n  // hash is used for signing and verification. never be used for key generation\n  let publicKey;\n  let privateKey;\n  const alg = {name: 'RSA-OAEP', modulusLength, publicExponent, hash: {name: 'SHA-256'}};\n\n  if(typeof window.msCrypto === 'undefined') {\n    const keys = await webCrypto.generateKey(alg, true, ['encrypt', 'decrypt']);\n    publicKey = await webCrypto.exportKey('jwk', keys.publicKey); // export keys in jwk format\n    privateKey = await webCrypto.exportKey('jwk', keys.privateKey); // export keys in jwk format\n  }\n  else {\n    const keys = await msGenerateKey(alg, true, ['encrypt', 'decrypt'], webCrypto);\n    publicKey = await msExportKey('jwk', keys.publicKey, webCrypto);\n    privateKey = await msExportKey('jwk', keys.privateKey, webCrypto);\n  }\n\n  // delete optional entries to export as general rsa sign/encrypt key\n  ['key_ops', 'alg', 'ext'].forEach((elem) => {\n    delete publicKey[elem];\n    delete privateKey[elem];\n  });\n\n  return {publicKey, privateKey};\n}\n\nexport async function sign(msg, privateJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: 192}, webCrypto) {\n  const algo = {name: algorithm.name, hash: {name: hash}, saltLength: algorithm.saltLength};\n\n  let signature;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['sign']);\n    signature = await webCrypto.sign(algo, key, msg);\n  }\n  else {\n    if(algorithm.name === 'RSA-PSS') throw new Error('IE does not support RSA-PSS. Use RSASSA-PKCS1-v1_5.')\n    const key = await msImportKey('jwk', privateJwk, algo, false, ['sign'], webCrypto);\n    signature = await msSign(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(signature);\n}\n\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: 192}, webCrypto){\n  const algo = {name: algorithm.name, hash: {name: hash}, saltLength: algorithm.saltLength};\n\n  let valid;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['verify']);\n    valid = await webCrypto.verify(algo, key, signature, msg);\n  }\n  else {\n    if(algorithm.name === 'RSA-PSS') throw new Error('IE does not support RSA-PSS. Use RSASSA-PKCS1-v1_5.');\n    const key = await msImportKey('jwk', publicJwk, algo, false, ['verify'], webCrypto);\n    valid = await msVerify(algo, key, signature, msg, webCrypto);\n  }\n  return valid;\n}\n\nexport async function encrypt(msg, publicJwk, hash = 'SHA-256', label = new Uint8Array([]), webCrypto){\n  const algo = {name: 'RSA-OAEP', hash: {name: hash}, label};\n\n  let encrypted;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['encrypt']);\n    encrypted = await webCrypto.encrypt(algo, key, msg);\n  }\n  else {\n    if (label.toString() !== (new Uint8Array()).toString()) throw new Error('IE does not support RSA-OAEP label.');\n    const key = await msImportKey('jwk', publicJwk, algo, false, ['encrypt'], webCrypto);\n    encrypted = await msEncrypt(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(encrypted);\n}\n\nexport async function decrypt(msg, privateJwk, hash = 'SHA-256', label = new Uint8Array([]), webCrypto){\n  const algo = {name: 'RSA-OAEP', hash: {name: hash}, label};\n\n  let decrypted;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['decrypt']);\n    decrypted = await webCrypto.decrypt(algo, key, msg);\n  }\n  else {\n    if (label.toString() !== (new Uint8Array()).toString()) throw new Error('IE does not support RSA-OAEP label.');\n    const key = await msImportKey('jwk', privateJwk, algo, false, ['decrypt'], webCrypto);\n    decrypted = await msDecrypt(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(decrypted);\n}\n\n// function definitions for IE\nconst msGenerateKey = (alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.generateKey(alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyGenerationFailed'); };\n});\nconst msImportKey = (type, key, alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  let inputKey = key;\n  if(type === 'jwk'){\n    inputKey = JSON.stringify(key);\n    inputKey = jseu.encoder.stringToArrayBuffer(inputKey);\n  }\n  const op = webCrypto.importKey(type, inputKey, alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyImportingFailed'); };\n});\nconst msExportKey = (type, key, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.exportKey(type, key);\n  op.oncomplete = (evt) => {\n    let output = evt.target.result;\n    if(type === 'jwk'){\n      output = jseu.encoder.arrayBufferToString(new Uint8Array(output));\n      output = JSON.parse(output);\n    }\n    resolve(output);\n  };\n  op.onerror = () => { reject('KeyExportingFailed'); };\n});\nconst msEncrypt = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  delete alg.label; // if exists, the MSCrypto doesn't work...wtf\n  const op = webCrypto.encrypt(alg, key, msg);\n  op.oncomplete = (evt) => {resolve(evt.target.result); };\n  op.onerror = () => { reject('EncryptionFailure'); };\n});\nconst msDecrypt = (alg, key, data, webCrypto) => new Promise ( (resolve, reject) => {\n  delete alg.label; // if exists, the MSCrypto doesn't work...wtf\n  const op = webCrypto.decrypt(alg, key, data);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('DecryptionFailure'); };\n});\nconst msSign = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.sign(alg, key, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('SigningFailed'); };\n});\nconst msVerify = (alg, key, sig, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.verify(alg, key, sig, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('VerificationFailed'); };\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 215,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{generateKey}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "modulusLength",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 2048,
        "defaultValue": "2048"
      },
      {
        "name": "publicExponent",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"publicKey\": *, \"privateKey\": *}"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{sign}",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "algorithm",
        "optional": true,
        "types": [
          "{\"name\": string, \"saltLength\": number}"
        ],
        "defaultRaw": {
          "name": "RSA-PSS",
          "saltLength": 192
        },
        "defaultValue": "{\"name\":\"RSA-PSS\",\"saltLength\":192}"
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{verify}",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "algorithm",
        "optional": true,
        "types": [
          "{\"name\": string, \"saltLength\": number}"
        ],
        "defaultRaw": {
          "name": "RSA-PSS",
          "saltLength": 192
        },
        "defaultValue": "{\"name\":\"RSA-PSS\",\"saltLength\":192}"
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{encrypt}",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "label",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "SHA-256",
        "defaultValue": "SHA-256"
      },
      {
        "name": "label",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "msGenerateKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msGenerateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 221,
    "kind": "function",
    "name": "msImportKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msImportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 222,
    "kind": "function",
    "name": "msExportKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msExportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 223,
    "kind": "function",
    "name": "msEncrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msEncrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 126,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 224,
    "kind": "function",
    "name": "msDecrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msDecrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "function",
    "name": "msSign",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msSign",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "function",
    "name": "msVerify",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msVerify",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "sig",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 227,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/index.js",
    "content": "/**\n * index.js\n * Structure of API\n * ---- Key (Key object with methods handling EC and RSA public keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA) // TODO: Encrypt/decrypt with ECDH standardized procedure\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509 // TODO verify self-signed certificate in single line\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n\nimport aes from 'js-crypto-aes';\nimport random from 'js-crypto-random';\nimport hash from 'js-crypto-hash';\nimport hmac from 'js-crypto-hmac';\nimport hkdf from 'js-crypto-hkdf';\nimport x509 from 'js-x509-utils';\nimport pbkdf from 'js-crypto-pbkdf';\n\nimport {Key} from 'js-crypto-key-utils';\nimport * as pkc from './pkc.js';\n\nexport {\n  Key,\n  pkc,\n  x509,\n  aes,\n  random,\n  hash,\n  hmac,\n  hkdf,\n  pbkdf\n};\n\nexport default {\n  Key,\n  pkc,\n  x509,\n  aes,\n  random,\n  hash,\n  hmac,\n  hkdf,\n  pbkdf\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 228,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  ciphers: {\n    'AES-GCM': {ivLength: 12}  // 12 bytes is recommended for AES-GCM\n  },\n\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20},\n  },\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 229,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/pkc.js",
    "content": "/**\n * pkc.js\n */\n\nimport ec from 'js-crypto-ec';\nimport rsa from 'js-crypto-rsa';\nimport { Key } from 'js-crypto-key-utils/dist/key';\nimport cloneDeep from 'lodash.clonedeep';\nimport * as pkcec from './pkcec.js';\nimport params from './params.js';\n\n/**\n * Generate key pair in JWK format\n * @param keyType\n * @param options\n * @return {Promise<{publicKey: *, privateKey: *}>}\n */\nexport async function generateKey(keyType = 'EC', options = {}){\n  const localOpt = cloneDeep(options);\n\n  let kp;\n  if (keyType === 'EC'){\n    if(typeof localOpt.namedCurve === 'undefined') localOpt.namedCurve = 'P-256';\n    kp = await ec.generateKey(localOpt.namedCurve);\n  }\n  else if (keyType === 'RSA') {\n    if(typeof localOpt.modulusLength === 'undefined') localOpt.modulusLength = 2048;\n    if(typeof localOpt.publicExponent === 'undefined') localOpt.publicExponent = new Uint8Array([0x01, 0x00, 0x01]);\n    kp = await rsa.generateKey(localOpt.modulusLength, localOpt.publicExponent);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return {\n    publicKey: new Key('jwk', kp.publicKey),\n    privateKey: new Key('jwk', kp.privateKey)\n  };\n}\n\n\n/**\n * Sign message with given private key in jwk\n * @param privateKey\n * @param msg\n * @param hash\n * @param options\n * @return {Promise<ArrayBuffer>}\n */\nexport async function sign(msg, privateKey, hash = 'SHA-256', options = {}){\n  if(!(privateKey instanceof Key)) throw new Error('NonKeyObject');\n  const privateJwk = await privateKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let signature;\n  if (privateJwk.kty === 'EC'){\n    if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';\n    signature = await ec.sign(msg, privateJwk, hash, localOpt.format);\n  }\n  else if (privateJwk.kty === 'RSA') {\n    if(typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';\n    if(typeof localOpt.saltLength === 'undefined') localOpt.saltLength = params.hashes[hash].hashSize;\n    signature = await rsa.sign(msg, privateJwk, hash, localOpt);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return signature;\n}\n\n/**\n * Verify message with given public key in jwk\n * @param msg\n * @param sig\n * @param publicKey\n * @param hash\n * @param options\n * @return {Promise<boolean>}\n */\nexport async function verify(msg, sig, publicKey, hash = 'SHA-256', options = {}){\n  if(!(publicKey instanceof Key)) throw new Error('NonKeyObject');\n  const publicJwk = await publicKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let valid;\n  if (publicJwk.kty === 'EC'){\n    if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';\n    valid = await ec.verify(msg, sig, publicJwk, hash, localOpt.format);\n  }\n  else if (publicJwk.kty === 'RSA') {\n    if(typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';\n    if(typeof localOpt.saltLength === 'undefined') localOpt.saltLength = params.hashes[hash].hashSize;\n    valid = await rsa.verify(msg, sig, publicJwk, hash, localOpt);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return valid;\n}\n\n\n\n/**\n * Encryption with public key algorithm. in case of ECDH.\n * Session key is derived from HKDF and the data itself will be encrypted by symmetric cipher.\n * @param msg\n * @param publicKey\n * @param options\n * @return {Promise<{data: Uint8Array, salt: Uint8Array, iv: Uint8Array}>}\n */\nexport async function encrypt(msg, publicKey, options = {}){\n  if(!(publicKey instanceof Key)) throw new Error('NonKeyObject');\n  const publicJwk = await publicKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let ciphertext = {};\n  if (publicJwk.kty === 'EC'){\n    if(!localOpt.privateKey || !(localOpt.privateKey instanceof Key)) throw new Error('MissingOrInvalidPrivateKeyForECDH');\n    localOpt.privateKey = await localOpt.privateKey.export('jwk');\n    ciphertext = await pkcec.encrypt(msg, publicJwk, localOpt);\n  }\n  else if (publicJwk.kty === 'RSA') {\n    if(typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';\n    if(typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);\n    ciphertext.data = await rsa.encrypt(msg, publicJwk, localOpt.hash, localOpt.label);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return ciphertext;\n}\n\n\n/**\n * Decryption with public key algorithm. in case of ECDH\n * Session key is derived from HKDF and the data itself will be decrypted by symmetric cipher.\n * @param data\n * @param privateKey\n * @param options\n * @return {Promise<Uint8Array>}\n */\nexport async function decrypt(data, privateKey, options = {}){\n  if(!(privateKey instanceof Key)) throw new Error('NonKeyObject');\n  const privateJwk = await privateKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let msg;\n  if (privateJwk.kty === 'EC'){\n    if(!localOpt.publicKey) throw new Error('MissingPublicKeyForECDH');\n    localOpt.publicKey = await localOpt.publicKey.export('jwk');\n    msg = await pkcec.decrypt(data, privateJwk, localOpt);\n  }\n  else if (privateJwk.kty === 'RSA') {\n    if(typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';\n    if(typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);\n    msg = await rsa.decrypt(data, privateJwk, localOpt.hash, localOpt.label);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return msg;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/pkc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 230,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{generateKey}",
    "description": "Generate key pair in JWK format",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keyType",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: *, privateKey: *}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 231,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{sign}",
    "description": "Sign message with given private key in jwk",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<ArrayBuffer>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 232,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{verify}",
    "description": "Verify message with given public key in jwk",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "sig",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 233,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{encrypt}",
    "description": "Encryption with public key algorithm. in case of ECDH.\nSession key is derived from HKDF and the data itself will be encrypted by symmetric cipher.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{data: Uint8Array, salt: Uint8Array, iv: Uint8Array}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 234,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{decrypt}",
    "description": "Decryption with public key algorithm. in case of ECDH\nSession key is derived from HKDF and the data itself will be decrypted by symmetric cipher.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 235,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/pkcec.js",
    "content": "/**\n * pkcec.js\n */\n\nimport random from 'js-crypto-random';\nimport ec from 'js-crypto-ec';\nimport hkdf from 'js-crypto-hkdf';\nimport aes from 'js-crypto-aes';\n\nimport params from './params.js';\n\nexport async function encrypt(\n  msg, publicKey,\n  { privateKey, hash='SHA-256', encrypt='AES-GCM', keyLength=32, iv=null, info='' }\n) {\n  const sharedSecret = await ec.deriveSecret(publicKey, privateKey);\n  const sessionKeySalt = await hkdf.compute(sharedSecret, hash, keyLength, info);\n\n  // TODO: other iv-required algorithms\n  switch (encrypt) {\n  case 'AES-GCM': {\n    iv = (!iv)\n      ? await random.getRandomBytes(params.ciphers[encrypt].ivLength)\n      : iv;\n    break;\n  }\n  default:\n    throw new Error('UnsupportedSessionKeyAlgorithm');\n  }\n\n  const data = await aes.encrypt(msg, sessionKeySalt.key, {name: encrypt, iv}); // no specification of tagLength and additionalData\n\n  return {data, salt: sessionKeySalt.salt, iv};\n}\n\n\nexport async function decrypt(\n  data, privateKey,\n  { publicKey, hash='SHA-256', encrypt='AES-GCM', keyLength=32, info='', salt=null, iv=null }\n) {\n  const sharedSecret = await ec.deriveSecret(publicKey, privateKey);\n  const sessionKeySalt = await hkdf.compute(sharedSecret, hash, keyLength, info, salt);\n\n  let msg;\n  if(Object.keys(params.ciphers).indexOf(encrypt) >= 0){\n    msg = await aes.decrypt(data, sessionKeySalt.key, {name: encrypt, iv}); // no specification of tagLength and additionalData\n  }\n  else throw new Error('UnsupportedSessionKeyAlgorithm');\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/pkcec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 236,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-utils/src/pkcec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkcec.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkcec.js",
    "importStyle": "{encrypt}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"privateKey\": *, \"hash\": *, \"encrypt\": *, \"keyLength\": *, \"iv\": *, \"info\": *}"
        ],
        "defaultRaw": {
          "privateKey": null,
          "hash": null,
          "encrypt": null,
          "keyLength": null,
          "iv": null,
          "info": null
        },
        "defaultValue": "{\"privateKey\":null,\"hash\":null,\"encrypt\":null,\"keyLength\":null,\"iv\":null,\"info\":null}"
      }
    ],
    "return": {
      "types": [
        "{\"data\": *, \"salt\": *, \"iv\": *}"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-utils/src/pkcec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkcec.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkcec.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"publicKey\": *, \"hash\": *, \"encrypt\": *, \"keyLength\": *, \"info\": *, \"salt\": *, \"iv\": *}"
        ],
        "defaultRaw": {
          "publicKey": null,
          "hash": null,
          "encrypt": null,
          "keyLength": null,
          "info": null,
          "salt": null,
          "iv": null
        },
        "defaultValue": "{\"publicKey\":null,\"hash\":null,\"encrypt\":null,\"keyLength\":null,\"info\":null,\"salt\":null,\"iv\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "packages/js-x509-utils/src/ec.js",
    "content": "/**\n * ec.js\n */\n\nimport params from './params.js';\nimport ec from 'js-crypto-ec';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\nexport async function getAsn1Signature(encodedTbsCertificate, privateJwk, signatureAlgorithm){\n  const asn1sig = await ec.sign(\n    encodedTbsCertificate,\n    privateJwk,\n    params.signatureAlgorithms[signatureAlgorithm].hash,\n    'der'\n  );\n  return {unused: 0, data: Buffer.from(asn1sig)};\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/ec.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/ec.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/ec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "getAsn1Signature",
    "memberof": "packages/js-x509-utils/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/ec.js~getAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/ec.js",
    "importStyle": "{getAsn1Signature}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "encodedTbsCertificate",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatureAlgorithm",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"unused\": *, \"data\": *}"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "packages/js-x509-utils/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {fromJwk, toJwk, parse} from './x509.js';\n\nexport default {fromJwk, toJwk, parse};\nexport {fromJwk, toJwk, parse};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "file",
    "name": "packages/js-x509-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n// oid is referred to\n// rfc7427 https://tools.ietf.org/html/rfc7427\n// http://www.umich.edu/~x509/ssleay/asn1-oids.html\n  signatureAlgorithms: {\n    // ECDSA\n    'ecdsa-with-sha256': {oid: [1, 2, 840, 10045, 4, 3, 2], hash: 'SHA-256'},\n    'ecdsa-with-sha384': {oid: [1, 2, 840, 10045, 4, 3, 3], hash: 'SHA-384'},\n    'ecdsa-with-sha512': {oid: [1, 2, 840, 10045, 4, 3, 4], hash: 'SHA-512'},\n    'ecdsa-with-sha1': {oid: [1, 2, 840, 10045, 4, 3, 1], hash: 'SHA-1'},\n\n    // RSASSA-PKCS1-v1_5\n    'sha256WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 11], hash: 'SHA-256'},\n    'sha384WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 12], hash: 'SHA-384'},\n    'sha512WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 13], hash: 'SHA-512'},\n    'sha1WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 5], hash: 'SHA-1'},\n\n    // RSA-PSS\n    'rsassaPss': {oid: [1, 2, 840, 113549, 1, 1, 10]}, // default params are sha-1...\n  },\n\n  maskGeneratorFunctions: {\n    'MGF1': {oid: [1, 2, 840, 113549, 1, 1, 8]}\n  },\n\n  hashes: {\n    'SHA-1': {oid: [1, 3, 14, 3, 2, 26]},\n    'SHA-256': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 1]},\n    'SHA-384': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 2]},\n    'SHA-512': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 3]},\n  },\n\n  ans1null: [0x05, 0x00]\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 243,
    "kind": "file",
    "name": "packages/js-x509-utils/src/rsa.js",
    "content": "/**\n * rsa.js\n */\n\nimport params from './params.js';\nimport * as util from './util.js';\nimport rsa from 'js-crypto-rsa';\nimport asn from 'asn1.js';\nconst BN = asn.bignum;\nimport rfc5280 from 'asn1.js-rfc5280';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n\nexport async function getSignature(encodedTbsCertificate, privateJwk, algorithm, hash, saltLength){\n  let signature;\n  if(algorithm === 'rsassaPss'){\n    signature = await rsa.sign( encodedTbsCertificate, privateJwk, hash, { name: 'RSA-PSS', saltLength });\n  }\n  else {\n    signature = await rsa.sign( encodedTbsCertificate, privateJwk, params.signatureAlgorithms[algorithm].hash, { name: 'RSASSA-PKCS1-v1_5' });\n  }\n  return {unused: 0, data: Buffer.from(signature)};\n}\n\nexport function encodeRsassaPssParams(options){\n  if (options.hash === 'SHA-1' && options.saltLength === 20 && options.explicit === false) return Buffer.from([0x30, 0x00]);\n  else {\n    const pssParams = {\n      hashAlgorithm: {\n        algorithm: params.hashes[options.hash].oid,\n        parameters: Buffer.from(params.ans1null)\n      },\n      maskGenAlgorithm: {\n        algorithm: params.maskGeneratorFunctions.MGF1.oid, // only MGF1 is available\n        parameters: rfc5280.AlgorithmIdentifier.encode({\n          algorithm: params.hashes[options.hash].oid,\n          parameters: Buffer.from(params.ans1null)\n        }, 'der')\n      },\n      saltLength: new BN(options.saltLength),\n      trailerField: new BN(1) // default\n    };\n\n    return RSASSAPSSParams.encode(pssParams, 'der');\n  }\n}\n\n\nexport function decodeRsassaPssParams(pssParams){\n  let returnParams;\n  if((new Uint8Array(pssParams)).toString() !== (new Uint8Array([0x30, 0x00]).toString())){\n    // non empty params\n    const decodedParams = RSASSAPSSParams.decode(pssParams, 'der');\n    decodedParams.maskGenAlgorithm.parameters\n      = rfc5280.AlgorithmIdentifier.decode(decodedParams.maskGenAlgorithm.parameters, 'der');\n    decodedParams.saltLength = decodedParams.saltLength.toNumber();\n    decodedParams.trailerField = decodedParams.trailerField.toNumber();\n\n    const hash = util.getKeyFromOid(decodedParams.hashAlgorithm.algorithm, params.hashes);\n    const mgf = util.getKeyFromOid(decodedParams.maskGenAlgorithm.algorithm, params.maskGeneratorFunctions);\n    const hashForMgf = util.getKeyFromOid(decodedParams.maskGenAlgorithm.parameters.algorithm, params.hashes);\n    if(hash.length === 0 || mgf.length === 0 || hashForMgf === 0) throw new Error('InvalidCertificateFormat');\n\n    returnParams = {hash: hash[0], mgf: mgf[0], hashForMgf: hashForMgf[0], saltLength: decodedParams.saltLength};\n  }\n  else {\n    // if empty, defaults are SHA-1 for Sign and MGF1 with SHA-1, using salt of length 20\n    returnParams = {hash: 'SHA-1', mgf: 'MGF1', hashForMgf: 'SHA-1', saltLength: 20};\n  }\n\n  return returnParams;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n// RFC4055 https://tools.ietf.org/html/rfc4055\n// RFC7427 https://tools.ietf.org/html/rfc7427\n// RSASSA-PSS-params  ::=  SEQUENCE  {\n//          hashAlgorithm      [0] HashAlgorithm DEFAULT\n//                                    sha1Identifier,\n//          maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\n//                                    mgf1SHA1Identifier,\n//          saltLength         [2] INTEGER DEFAULT 20,\n//          trailerField       [3] INTEGER DEFAULT 1  }\nconst RSASSAPSSParams = asn.define('rsassaPssParams', function() {\n  this.seq().obj(\n    this.key('hashAlgorithm').explicit(0).use(rfc5280.AlgorithmIdentifier),\n    this.key('maskGenAlgorithm').explicit(1).use(rfc5280.AlgorithmIdentifier),\n    this.key('saltLength').explicit(2).int(),\n    this.key('trailerField').explicit(3).int()\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 244,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 245,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "function",
    "name": "getSignature",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~getSignature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{getSignature}",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "encodedTbsCertificate",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateJwk",
        "types": [
          "*"
        ]
      },
      {
        "name": "algorithm",
        "types": [
          "*"
        ]
      },
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "saltLength",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"unused\": *, \"data\": *}"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "function",
    "name": "encodeRsassaPssParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~encodeRsassaPssParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{encodeRsassaPssParams}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "function",
    "name": "decodeRsassaPssParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~decodeRsassaPssParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{decodeRsassaPssParams}",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "pssParams",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "variable",
    "name": "RSASSAPSSParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~RSASSAPSSParams",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 250,
    "kind": "file",
    "name": "packages/js-x509-utils/src/util.js",
    "content": "/**\n * util.js\n */\n\nexport const getKeyFromOid = (oid, dict) => Object.keys(dict).filter(\n  (key) => dict[key].oid.toString() === oid.toString()\n);",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "function",
    "name": "getKeyFromOid",
    "memberof": "packages/js-x509-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/util.js~getKeyFromOid",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/util.js",
    "importStyle": "{getKeyFromOid}",
    "description": "util.js",
    "lineNumber": 5,
    "params": [
      {
        "name": "oid",
        "types": [
          "*"
        ]
      },
      {
        "name": "dict",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 252,
    "kind": "file",
    "name": "packages/js-x509-utils/src/x509.js",
    "content": "/**\n * x509.js\n */\n\nimport params from './params.js';\nimport * as rsa from './rsa.js';\nimport * as ecdsa from './ec.js';\nimport BN from 'bn.js';\nimport rfc5280 from 'asn1.js-rfc5280';\nimport jseu from 'js-encoding-utils';\nimport random from 'js-crypto-random';\nimport {Key} from 'js-crypto-key-utils';\n\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Convert jwk to X509 pem\n * @param publicJwk\n * @param privateJwk\n * @param format\n * @param options\n * @return {Promise<*>}\n */\nexport async function fromJwk(publicJwk, privateJwk, format = 'pem', options = {}) {\n  // default values\n  if (typeof options.signature === 'undefined') options.signature = 'ecdsa-with-sha256';\n  if (typeof options.days === 'undefined') options.days = 3650;\n  if (typeof options.issuer === 'undefined') options.issuer = {organizationName: 'Self'};\n  if (typeof options.subject === 'undefined') options.subject = {organizationName: 'Self'};\n\n  // default params for RSA-PSS\n  if (typeof options.saltLength === 'undefined' && options.signature === 'rsassaPss') options.saltLength = 20;\n  if (typeof options.hash === 'undefined' && options.signature === 'rsassaPss') options.hash = 'SHA-1';\n  if (typeof options.explicit === 'undefined' && options.signature === 'rsassaPss') options.explicit = true;\n\n  ///////////////////////////////\n  // elements of TBSCertificate\n  ///////////////////////////////\n\n  const version = 0; // default, TODO: other versions?\n\n  // random serial numbers\n  const rand = await random.getRandomBytes(20); // max 20 octets\n  const serialNumber = new BN(rand);\n\n  // TODO: throw exception if private jwk keytype doesn't match signatureAlgorithm\n  const signature = { algorithm: params.signatureAlgorithms[options.signature].oid };\n  if (options.signature === 'rsassaPss') {\n    signature.parameters = rsa.encodeRsassaPssParams(options);\n  } else signature.parameters = Buffer.from(params.ans1null);\n\n  const issuer = {type: 'rdnSequence', value: setRDNSequence(options.issuer)};\n\n  const current = (Date.now() / 1000) * 1000;\n  const validity = {\n    notBefore: {type: 'utcTime', value: current},\n    notAfter: {type: 'utcTime', value: (current + options.days * 86400 * 1000)}\n  };\n\n  const subject = {type: 'rdnSequence', value: setRDNSequence(options.subject)};\n\n  const publicObj = new Key('jwk', publicJwk);\n  const spkiDer = Buffer.from(await publicObj.export('der', {compact: false, outputPublic: true})); // {compact: false} is active only for ecc keys\n  const subjectPublicKeyInfo = rfc5280.SubjectPublicKeyInfo.decode(spkiDer, 'der');\n\n  // elements of Certificate\n  const tbsCertificate = {version, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo};\n  const signatureAlgorithm = tbsCertificate.signature; // This must be the same as tbsCertificate.signature field (as specified in RFC).\n\n  // generate signature value\n  const encodedTbsCertificate = rfc5280.TBSCertificate.encode(tbsCertificate, 'der');\n  let signatureValue;\n  if (privateJwk.kty === 'EC'){\n    signatureValue = await ecdsa.getAsn1Signature(encodedTbsCertificate, privateJwk, options.signature);\n  } else if (privateJwk.kty === 'RSA') {\n    signatureValue = await rsa.getSignature(\n      encodedTbsCertificate, privateJwk, options.signature, options.hash, options.saltLength\n    );\n  } else throw new Error ('UnsupportedKeyType');\n\n  // construct Certificate\n  const certBin = rfc5280.Certificate.encode({tbsCertificate, signatureAlgorithm, signature: signatureValue}, 'der');\n\n  if (format === 'pem') {\n    return jseu.formatter.binToPem(certBin, 'certificate');\n  }\n  else if (format === 'der') {\n    return certBin;\n  }\n  else {\n    throw new Error('InvalidFormatSpecification');\n  }\n}\n\n/**\n * Convert X.509 certificate to JWK\n * @param certX509\n * @param format\n * @return {Promise<void>}\n */\nexport async function toJwk(certX509, format = 'pem'){\n  let x509bin;\n  if (format === 'pem') x509bin = jseu.formatter.pemToBin(certX509);\n  else if (format === 'der') x509bin = certX509;\n  else throw new Error('InvalidFormatSpecification');\n\n  const binKeyBuffer = Buffer.from(x509bin); // This must be Buffer object to get decoded;\n\n  const decoded = rfc5280.Certificate.decode(binKeyBuffer, 'der'); // decode binary x509-formatted public key to parsed object\n  const binSpki = rfc5280.SubjectPublicKeyInfo.encode(decoded.tbsCertificate.subjectPublicKeyInfo, 'der');\n  const publicObj = new Key('der', binSpki);\n  return await publicObj.export('jwk', {outputPublic: true});\n}\n\n\n/**\n * Parse X.509 certificate and return DER-encoded TBSCertificate and DER encoded signature\n * @param certX509\n * @param format\n * @return {{tbsCertificate: *, signatureValue: *, signatureAlgorithm: *}}\n */\nexport function parse(certX509, format = 'pem'){\n\n  let x509bin;\n  if (format === 'pem') x509bin = jseu.formatter.pemToBin(certX509);\n  else if (format === 'der') x509bin = certX509;\n  else throw new Error('InvalidFormatSpecification');\n\n  const binKeyBuffer = Buffer.from(x509bin); // This must be Buffer object to get decoded;\n\n  const decoded = rfc5280.Certificate.decode(binKeyBuffer, 'der'); // decode binary x509-formatted public key to parsed object\n  const sigOid = decoded.signatureAlgorithm.algorithm;\n  const sigParam = decoded.signatureAlgorithm.parameters;\n\n  const filter = Object.keys(params.signatureAlgorithms).filter(\n    (name) => params.signatureAlgorithms[name].oid.toString() === sigOid.toString()\n  );\n  if(filter.length <= 0) throw new Error('UnsupportedSignatureAlgorithm');\n  const signatureAlgorithm = {algorithm: filter[0]};\n\n  if (filter[0] === 'rsassaPss') signatureAlgorithm.parameters = rsa.decodeRsassaPssParams(sigParam);\n  else signatureAlgorithm.parameters = { hash: params.signatureAlgorithms[signatureAlgorithm.algorithm].hash };\n\n  const binTBSCertificate = rfc5280.TBSCertificate.encode(decoded.tbsCertificate, 'der');\n\n  return {\n    tbsCertificate: new Uint8Array(binTBSCertificate),\n    signatureValue: new Uint8Array(decoded.signature.data),\n    signatureAlgorithm\n  };\n}\n\n\n\n/**\n * Set RDN sequence for issuer and subject fields\n * @param options\n * @return {{type: *, value: *}[][]}\n */\nfunction setRDNSequence(options) {\n  const encodedArray = Object.keys(options).map((k) => {\n    if (Object.keys(attributeTypeOIDMap).indexOf(k) < 0) throw new Error('InvalidOptionSpecification');\n\n    const type = attributeTypeOIDMap[k];\n    let value;\n    if (['dnQualifier, countryName, serialNumber'].indexOf(k) >= 0) {\n      if (k === 'countryName' && options[k].length !== 2) throw new Error('InvalidCountryNameCode');\n      value = rfc5280.DirectoryString.encode({type: 'printableString', value: options[k]}, 'der');\n    }\n    else value = rfc5280.DirectoryString.encode({type: 'utf8String', value: options[k]}, 'der');\n\n    return {type, value};\n  });\n\n  return [encodedArray];\n}\n\n// https://tools.ietf.org/html/rfc5280#appendix-A\nconst attributeTypeOIDMap = {\n  // X509name DirectoryName\n  name: [2, 5, 4, 41],\n  surname: [2, 5, 4, 4],\n  givenName: [2, 5, 4, 42],\n  initials: [2, 5, 4, 43],\n  generationQualifier: [2, 5, 4, 44],\n\n  commonName: [2, 5, 4, 3], // DirectoryName\n  localityName: [2, 5, 4, 7], // DirectoryName\n  stateOrProvinceName: [2, 5, 4, 8], // DirectoryName\n  organizationName: [2, 5, 4, 10], // DirectoryName\n  organizationalUnitName: [2, 5, 4, 11], // DirectoryName\n  title: [2, 5, 4, 12], // DirectoryName\n\n  dnQualifier: [2, 5, 4, 46], // PrintableString\n  countryName: [2, 5, 4, 6], // PrintableString(2)\n  serialNumber: [2, 5, 4, 5], // PrintableString\n\n  pseudonym: [2, 5, 4, 65], // DirectoryName\n\n  domainComponent: [0, 9, 2342, 19200300, 100, 1, 25], // IA5String https://tools.ietf.org/html/rfc4519\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/x509.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 253,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 254,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{fromJwk}",
    "description": "Convert jwk to X509 pem",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 255,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{toJwk}",
    "description": "Convert X.509 certificate to JWK",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "certX509",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 256,
    "kind": "function",
    "name": "parse",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~parse",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{parse}",
    "description": "Parse X.509 certificate and return DER-encoded TBSCertificate and DER encoded signature",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "certX509",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{tbsCertificate: *, signatureValue: *, signatureAlgorithm: *}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 257,
    "kind": "function",
    "name": "setRDNSequence",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~setRDNSequence",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": "Set RDN sequence for issuer and subject fields",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{type: *, value: *}[][]"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 258,
    "kind": "variable",
    "name": "attributeTypeOIDMap",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~attributeTypeOIDMap",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "{\"name\": *, \"surname\": *, \"givenName\": *, \"initials\": *, \"generationQualifier\": *, \"commonName\": *, \"localityName\": *, \"stateOrProvinceName\": *, \"organizationName\": *, \"organizationalUnitName\": *, \"title\": *, \"dnQualifier\": *, \"countryName\": *, \"serialNumber\": *, \"pseudonym\": *, \"domainComponent\": *}"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "jscu: A Universal Cryptographic Library for JavaScript\n--\n\n[![CircleCI](https://circleci.com/gh/junkurihara/jscu.svg?style=svg)](https://circleci.com/gh/junkurihara/jscu)\n[![Coverage Status](https://coveralls.io/repos/github/junkurihara/jscu/badge.svg?branch=develop)](https://coveralls.io/github/junkurihara/jscu?branch=develop)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg)](https://david-dm.org/junkurihara/jscu)\n[![Maintainability](https://api.codeclimate.com/v1/badges/3e20cff0e8e062363a13/maintainability)](https://codeclimate.com/github/junkurihara/jscu/maintainability)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Introduction\n\nThis repository is a *monorepo* of a universal cryptographic library for JavaScript called `js-crypto-utils` (`jscu`), which is designed so as to work in most modern browsers and Node.js. The detailed explanation would be given in each package repository. The root package is given [here](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-utils) (in `develop` branch), and we should start from there.\n\n# For Developers\n\nUsage of this monorepo and procedures for NPM deployment are summarized as follows.\n\n- This monorepo is managed via [Yarn Workspace](https://yarnpkg.com/en/docs/workspaces) and [Lerna](https://github.com/lerna/lerna). After cloning this Git repo, just do `yarn install` at the root of the cloned folder. Then the setup is all done.\n- Versioning pattern of each package is completely independent, but the version of this Git repository specified in the root `package.json` is tied with the root package, i.e., `packages/js-crypto-utils`. The name of root package is also given in the root `package.json`.\n- Deployment of packages to NPM must be done through CircleCI, and **the deployment operation is only triggered by tags associated with Git repo version**. Any commits to any branch and any tags of individual package version won't kicks the deployment mechanism. The versioning and tagging would be done through the following combination of GitFlow and Lerna procedures.\n  1. First execute `yarn flow:version` and bump a version of each package that has been modified on `develop` branch. Here we note that for each updated package, the updated tag would be committed (not pushed), and hence we should almost finalize the release operation at least for each package. This simultaneously update the repo version specified in the root `package.json` without committing.\n  2. Add final changes for release at the level of GitHub repo. Then, commit changes and then execute `yarn release:start` to start release process on a release branch. Here we note the release version will be the updated Git repo version.\n  3. To finalize the release operation, execute `yarn release:finish` to merge the release branch to `master`, and then merge `master` to `develop`. It will also tag the `master` branch with the updated Git repo version, i.e., the root package (`packages/js-crypto-utils`) version.\n  4. Execute `yarn release:finish` and push all branches and the generated tag of Git repo version to GitHub.",
    "longname": "/home/circleci/repo/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified (and specific) cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/js-x509-utils\n- `aes`: https://github.com/junkurihara/js-crypto-aes\n- `random`: https://github.com/junkurihara/js-crypto-random\n- `hash`: https://github.com/junkurihara/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypt-utils // yarn\n  ```\n  \n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  ``` \n  \nThen you should import the package as follows.\n```javascript\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'js-crypto-utils/dist/index.js'; // for npm/github\n```\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in IE and Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509 (may not work in IE due to RSA)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint (SHA-512/SHA-1 does not work in IE, SHA-1 doesn't in Edge)\n  * WebCrypto API for browsers\n  * MsCrypto for IE\n  * NodeCrypto for Node.js\n\n# License\nLicensed under the MIT license, see `LICENSE` file.",
    "longname": "/home/circleci/repo/packages/js-crypto-utils/README.md",
    "name": "./packages/js-crypto-utils/README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/circleci/repo/packages/js-crypto-utils/README.md",
    "name": "./packages/js-crypto-utils/README.md",
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified (and specific) cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/js-x509-utils\n- `aes`: https://github.com/junkurihara/js-crypto-aes\n- `random`: https://github.com/junkurihara/js-crypto-random\n- `hash`: https://github.com/junkurihara/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypt-utils // yarn\n  ```\n  \n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  ``` \n  \nThen you should import the package as follows.\n```javascript\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'js-crypto-utils/dist/index.js'; // for npm/github\n```\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in IE and Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509 (may not work in IE due to RSA)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint (SHA-512/SHA-1 does not work in IE, SHA-1 doesn't in Edge)\n  * WebCrypto API for browsers\n  * MsCrypto for IE\n  * NodeCrypto for Node.js\n\n# License\nLicensed under the MIT license, see `LICENSE` file.",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 259,
    "kind": "testFile",
    "name": "packages/js-crypto-aes/test/cbc.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst aes = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Encryption and Decryption with AES-CBC Test`, () => {\n  const keyLength = [16, 32]; // 24 bytes (192 bits) AES key is not supported in Chrome at this point\n  let msg;\n  let iv;\n  before( async () => {\n    msg = new Uint8Array(1024);\n    iv = new Uint8Array(16);\n    for(let i = 0; i < 1024; i++) msg[i] = 0xFF & i;\n    for(let i = 0; i < 16; i++) iv[i] = 0xFF & i;\n  });\n\n  it('Encrypt and decrypt with AES-CBC succeeds correctly', async function() {\n    this.timeout(5000);\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-CBC', iv});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-CBC', iv});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n\n  it('IV must be 16 bytes for AES-CBC', async () => {\n    let result = true;\n    const key = await random.getRandomBytes(12);\n    const ivz = new Uint8Array(12);\n    await aes.encrypt(msg, key, {name: 'AES-CBC', ivz}).catch( () => {result = false; });\n    expect(result).to.be.false;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/test/cbc.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 260,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 261,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0.it1",
    "access": null,
    "description": "Encrypt and decrypt with AES-CBC succeeds correctly",
    "lineNumber": 23
  },
  {
    "__docId__": 262,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0.it2",
    "access": null,
    "description": "IV must be 16 bytes for AES-CBC",
    "lineNumber": 34
  },
  {
    "__docId__": 263,
    "kind": "testFile",
    "name": "packages/js-crypto-aes/test/gcm.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst aes = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Encryption and Decryption with AES-GCM Test`, () => {\n  const keyLength = [16, 32]; // 24 bytes (192 bits) AES key is not supported in Chrome at this point\n  let msg;\n  let iv;\n  before( async () => {\n    msg = new Uint8Array(1024);\n    iv = new Uint8Array(12);\n    for(let i = 0; i < 1024; i++) msg[i] = 0xFF & i;\n    for(let i = 0; i < 12; i++) iv[i] = 0xFF & i;\n  });\n\n  it('Encrypt and decrypt with AES-GCM succeeds correctly', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv, tagLength: 16});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv, tagLength: 16});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n  it('Encrypt and decrypt with AES-GCM succeeds correctly with AAD', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const additionalData = await random.getRandomBytes(32);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv, additionalData, tagLength: 16});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv, additionalData, tagLength: 16});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n  it('Ciphertext alternation can be detected in AES-GCM', async function () {\n    this.timeout(2000);\n    const key = await random.getRandomBytes(32);\n    const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv});\n    encrypted[0] = 0xFF;\n\n    let result = true;\n    await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv}).catch( () => { result = false; });\n    expect(result).to.be.false;\n  });\n\n  it('IV must be 12 bytes for AES-GCM', async () => {\n    let result = true;\n    const key = await random.getRandomBytes(16);\n    const ivz = new Uint8Array(16);\n    await aes.encrypt(msg, key, {name: 'AES-GCM', ivz}).catch( () => {result = false; });\n    expect(result).to.be.false;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/test/gcm.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 264,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 265,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it4",
    "access": null,
    "description": "Encrypt and decrypt with AES-GCM succeeds correctly",
    "lineNumber": 23
  },
  {
    "__docId__": 266,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it5",
    "access": null,
    "description": "Encrypt and decrypt with AES-GCM succeeds correctly with AAD",
    "lineNumber": 32
  },
  {
    "__docId__": 267,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it6",
    "access": null,
    "description": "Ciphertext alternation can be detected in AES-GCM",
    "lineNumber": 42
  },
  {
    "__docId__": 268,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it7",
    "access": null,
    "description": "IV must be 12 bytes for AES-GCM",
    "lineNumber": 53
  },
  {
    "__docId__": 269,
    "kind": "testFile",
    "name": "packages/js-crypto-ec/test/ec.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst elliptic = env.library;\nconst envName = env.envName;\n\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Elliptic curve cryptography test`, () => {\n\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  const keys = [];\n  const msgLen = 128;\n  const msg = new Uint8Array(msgLen);\n  before( async () => {\n    for(let i = 0; i < msgLen; i++) msg[i] = 0xFF & i;\n  });\n\n  it('JWK key pair is correctly generated', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(curves.map( async (crv) => {\n      let result = true;\n      const key = await elliptic.generateKey(crv).catch( (e) => {result = false;});\n      keys.push(key);\n      // console.log(key);\n      return result;\n    }));\n    console.log(results);\n    console.log(keys);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Message is successfully signed and verified with generated JWK pairs', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const sign = await elliptic.sign(msg, kp.privateKey, 'SHA-256').catch( (e) => {result = false;});\n      //console.log(sign);\n      const valid = await elliptic.verify(msg, sign, kp.publicKey, 'SHA-256').catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Shared secret is correctly computed at each side', async () => {\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const newKey = await elliptic.generateKey(kp.privateKey.crv).catch( (e) => {result = false;});\n      const shared1 = await elliptic.deriveSecret(kp.publicKey, newKey.privateKey).catch( (e) => {result = false;});\n      const shared2 = await elliptic.deriveSecret(newKey.publicKey, kp.privateKey).catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return (shared1.toString() === shared2.toString());\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Message is successfully signed and verified with generated JWK pairs with DER signature', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const sign = await elliptic.sign(msg, kp.privateKey, 'SHA-256', 'der').catch( (e) => {result = false;});\n      //console.log(sign);\n      const valid = await elliptic.verify(msg, sign, kp.publicKey, 'SHA-256', 'der').catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/test/ec.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 270,
    "kind": "test",
    "name": "describe8",
    "testId": 8,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe8",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 271,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe8.it9",
    "access": null,
    "description": "JWK key pair is correctly generated",
    "lineNumber": 22
  },
  {
    "__docId__": 272,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe8.it10",
    "access": null,
    "description": "Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 36
  },
  {
    "__docId__": 273,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe8.it11",
    "access": null,
    "description": "Shared secret is correctly computed at each side",
    "lineNumber": 51
  },
  {
    "__docId__": 274,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe8.it12",
    "access": null,
    "description": "Message is successfully signed and verified with generated JWK pairs with DER signature",
    "lineNumber": 65
  },
  {
    "__docId__": 275,
    "kind": "testFile",
    "name": "packages/js-crypto-hash/test/hash.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hash = env.library;\nconst envName = env.envName;\n\n\n\nimport params from '../src/params.js';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: Hash generation test`, () => {\n  let msg;\n  before( async () => {\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('Hash should be generated for each hash algorithms', async () => {\n    await Promise.all(hashes.map( async (alg) => {\n      const d = await hash.compute(msg, alg).catch( (e) => console.error(e));\n      console.log(`${alg}: ${d}`);\n      expect(d, `failed at ${alg}`).to.be.a('Uint8Array');\n      const len = params.hashes[alg].hashSize;\n      expect(d, `failed at ${alg}`).to.be.length(len);\n    }));\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/test/hash.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 276,
    "kind": "test",
    "name": "describe13",
    "testId": 13,
    "memberof": "packages/js-crypto-hash/test/hash.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hash/test/hash.spec.js~describe13",
    "access": null,
    "lineNumber": 15
  },
  {
    "__docId__": 277,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "packages/js-crypto-hash/test/hash.spec.js~describe13",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hash/test/hash.spec.js~describe13.it14",
    "access": null,
    "description": "Hash should be generated for each hash algorithms",
    "lineNumber": 22
  },
  {
    "__docId__": 278,
    "kind": "testFile",
    "name": "packages/js-crypto-hkdf/test/hkdf.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hkdf = env.library;\nconst envName = env.envName;\n\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nlet hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: HKDF test`, () => {\n  let masterSecret;\n  const length = 144;\n  before( async () => {\n    masterSecret = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) masterSecret[i] = 0xFF & i;\n  });\n\n  it('HKDF is done with automatic salt generation', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', null);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.byteLength, `failed at ${hash}`).to.be.equal(length);\n    }));\n\n  });\n\n  it('When the same salt is given, the same hash is obtained with HKDF', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', null);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.byteLength, `failed at ${hash}`).to.be.equal(length);\n\n      const dash = await hkdf.compute(masterSecret, hash, length, '', d.salt);\n      expect(dash.key).to.be.a('Uint8Array');\n      expect(dash.salt).to.be.a('Uint8Array');\n      expect(dash.key.toString() === d.key.toString(), `failed at ${hash}`).to.be.true;\n    }));\n  });\n\n  const fixedMACs = {\n    'SHA-256': '124,145,193,234,149,107,107,61,61,58,9,228,216,212,69,71,240,202,118,194,180,114,113,80,57,24,232,113,213,155,191,166,26,1,94,230,244,185,171,102,20,246,59,203,245,200,17,25,92,22,196,106,168,145,125,94,125,84,101,149,119,146,250,243,152,225,232,129,232,101,106,19,55,157,34,240,146,204,162,5,235,156,31,230,188,36,176,44,67,35,99,135,83,197,177,236,167,63,60,93,47,189,225,162,175,151,241,234,151,223,136,25,249,206,88,208,28,111,166,235,128,33,40,15,90,219,238,153,152,79,97,115,33,89,55,168,181,141,76,237,144,181,57,117',\n    'SHA-384': '226,40,99,209,178,247,5,3,166,90,9,57,196,54,29,65,191,119,205,64,47,173,233,116,113,173,210,1,8,30,44,233,142,251,189,192,98,33,183,94,253,87,14,102,50,209,55,67,226,34,229,19,69,88,120,205,147,250,207,6,190,188,129,162,142,51,6,94,198,13,52,245,178,65,101,49,1,35,97,111,92,164,181,162,227,6,13,233,115,237,140,241,0,94,195,189,92,45,79,229,249,176,59,226,25,219,176,12,37,70,220,234,182,3,199,37,63,197,185,145,65,12,133,26,152,177,154,89,5,110,49,205,30,57,50,9,111,119,211,27,189,48,162,248',\n    'SHA-512': '77,119,111,188,124,95,226,127,20,170,196,226,159,131,36,202,21,73,204,211,247,102,23,159,105,161,241,64,50,116,222,170,254,66,55,162,60,1,101,29,45,47,15,139,247,111,136,142,99,191,28,155,218,49,174,135,126,218,59,64,167,134,208,165,16,247,6,10,59,62,132,83,23,168,218,212,7,22,213,52,101,9,30,1,228,227,88,185,196,5,50,49,100,24,84,15,58,45,93,90,119,135,41,224,224,53,39,176,107,150,138,99,113,161,111,145,83,241,68,46,151,134,169,76,254,20,58,160,91,177,62,71,12,106,54,35,116,101,34,115,23,103,199,33',\n    'SHA-1': '231,154,101,85,67,166,227,46,107,169,115,168,122,162,93,194,10,128,27,249,153,198,172,180,27,209,12,238,163,12,98,163,236,102,63,223,161,210,134,122,189,22,131,17,171,185,178,228,115,0,218,206,137,173,245,206,223,69,72,248,241,58,225,7,23,151,118,82,196,123,65,14,205,160,64,3,225,9,124,178,27,174,18,48,251,3,59,132,162,81,151,191,178,11,202,26,233,214,5,254,87,32,229,112,122,149,27,28,87,252,204,243,161,2,123,48,131,94,121,188,147,143,232,247,105,96,151,230,76,180,214,185,71,188,78,23,251,225,102,131,107,231,158,87',\n    'MD5': '34,114,11,173,87,235,112,155,161,97,171,57,143,74,153,140,175,88,254,87,93,61,179,88,60,142,74,41,117,97,62,89,80,168,115,6,130,109,48,166,162,35,217,104,241,208,238,57,121,26,33,71,247,81,97,99,62,96,225,167,118,46,176,104,212,119,127,248,29,0,165,36,183,238,250,171,155,179,152,55,236,224,58,4,1,22,144,146,92,123,240,96,1,46,82,221,253,32,216,171,51,137,130,88,53,209,151,50,204,151,231,90,56,171,97,250,101,225,150,198,242,161,216,91,196,89,103,163,106,120,61,59,26,150,23,226,244,149,161,40,106,90,106,32'\n  };\n\n  it('When the fixed salt is given, the mac is always fixed', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', masterSecret);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.toString() === fixedMACs[hash]).to.be.true;\n    }));\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/test/hkdf.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 279,
    "kind": "test",
    "name": "describe15",
    "testId": 15,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15",
    "access": null,
    "lineNumber": 13
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15.it16",
    "access": null,
    "description": "HKDF is done with automatic salt generation",
    "lineNumber": 21
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15.it17",
    "access": null,
    "description": "When the same salt is given, the same hash is obtained with HKDF",
    "lineNumber": 33
  },
  {
    "__docId__": 282,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe15.it18",
    "access": null,
    "description": "When the fixed salt is given, the mac is always fixed",
    "lineNumber": 57
  },
  {
    "__docId__": 283,
    "kind": "testFile",
    "name": "packages/js-crypto-hmac/test/hmac.spec.js",
    "content": "import random from 'js-crypto-random';\nimport jseu from 'js-encoding-utils';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hmac = env.library;\nconst envName = env.envName;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'MD5', 'SHA-1'];\ndescribe(`${envName}: HMAC test`, () => {\n  let msg;\n  before( async () => {\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('HMAC successfully generates unique MAC for unique key', async function () {\n    this.timeout(20000);\n    const array = await Promise.all(hashes.map( async (hash) => {\n      const keya = await random.getRandomBytes(32);\n      const keyb = await random.getRandomBytes(32);\n      const da = await hmac.compute(keya, msg, hash);\n      const db = await hmac.compute(keyb, msg, hash);\n      expect(da).to.be.a('Uint8Array');\n      expect(db).to.be.a('Uint8Array');\n      return da.toString() !== db.toString();\n    }));\n    console.log(array);\n    expect(array.every((a) => (a === true))).to.be.true;\n  });\n\n  it('If msg is overwritten, it can be detected via MAC', async function () {\n    this.timeout(20000);\n    const key = await random.getRandomBytes(32);\n    const newMsg = new Uint8Array(msg);\n    newMsg[1] = 0xFF&0x33;\n\n    const origArray = await Promise.all(hashes.map( async (hash) => jseu.encoder.encodeBase64(await hmac.compute(key, msg, hash))));\n    const altArray = await Promise.all(hashes.map( async (hash) => jseu.encoder.encodeBase64(await hmac.compute(key, newMsg, hash))));\n\n    const array = origArray.map( (orig, idx) => orig !== altArray[idx]);\n    console.log(array);\n    console.log(origArray);\n    console.log(altArray);\n\n    expect(array.every( (x) => x)).to.be.true;\n\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/test/hmac.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 284,
    "kind": "test",
    "name": "describe19",
    "testId": 19,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe19",
    "access": null,
    "lineNumber": 14
  },
  {
    "__docId__": 285,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js~describe19",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe19.it20",
    "access": null,
    "description": "HMAC successfully generates unique MAC for unique key",
    "lineNumber": 21
  },
  {
    "__docId__": 286,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js~describe19",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe19.it21",
    "access": null,
    "description": "If msg is overwritten, it can be detected via MAC",
    "lineNumber": 36
  },
  {
    "__docId__": 287,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/convertEC.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport ecKey from './ec_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nfunction prune(jwk){\n  delete jwk.ext;\n  delete jwk.alg;\n  delete jwk.key_ops;\n  return jwk;\n}\n\n\nconst curves = ['P-256', 'P-384', 'P-521'];\ndescribe(`${envName}: EC Key conversion from/to JWK test.`, () => {\n  \n  let ECKeySet = [];\n  before(async function (){\n    this.timeout(20000);\n    ECKeySet = ecKey.ecKey;//await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('JWK EC should be successfully converted to PEM and re-converted to JWK correctly', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const pempub = await publicKey.export('pem', {compact: false});\n      const pempri = await privateKey.export('pem', {compact: false});\n\n      const publicKey2 = new keyutils.Key('pem', pempub);\n      const privateKey2 = new keyutils.Key('pem', pempri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      const res =  (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n      if (!res) {\n        console.log(objectSort(jwkpub));\n        console.log(objectSort(key.publicKey));\n        console.log(objectSort(jwkpri));\n        console.log(objectSort(key.privateKey));\n        // console.log(pempub);\n        // console.log(pempri);\n      }\n      return res;\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to PEM and re-converted to JWK correctly with public key compact form', async () => {\n\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const pempub = await publicKey.export('pem', {compact: true});\n      const pempri = await privateKey.export('pem', {compact: true});\n\n      const publicKey2 = new keyutils.Key('pem', pempub);\n      const privateKey2 = new keyutils.Key('pem', pempri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n\n  it('JWK EC should be successfully converted to DER and re-converted to JWK correctly', async () => {\n\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const derpub = await publicKey.export('der', {compact: false});\n      const derpri = await privateKey.export('der', {compact: false});\n\n      const publicKey2 = new keyutils.Key('der', derpub);\n      const privateKey2 = new keyutils.Key('der', derpri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to DER and re-converted to JWK correctly with public key compact form', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const derpub = await publicKey.export('der', {compact: true});\n      const derpri = await privateKey.export('der', {compact: true});\n\n      const publicKey2 = new keyutils.Key('der', derpub);\n      const privateKey2 = new keyutils.Key('der', derpri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to uncompressed-octet formed key and vice varsa', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const octpub = await publicKey.export('oct', {compact: false});\n      const octpri = await privateKey.export('oct', {compact: false});\n\n      const publicKey2 = new keyutils.Key('oct', octpub, {namedCurve: key.publicKey.crv});\n      const privateKey2 = new keyutils.Key('oct', octpri, {namedCurve: key.privateKey.crv});\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to compact-octet formed key and vice varsa', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const octpub = await publicKey.export('oct', {compact: true});\n      const octpri = await privateKey.export('oct', {compact: true});\n      // console.log(octpub);\n\n      const publicKey2 = new keyutils.Key('oct', octpub, {namedCurve: key.publicKey.crv});\n      const privateKey2 = new keyutils.Key('oct', octpri, {namedCurve: key.privateKey.crv});\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/convertEC.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 288,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "access": null,
    "lineNumber": 28
  },
  {
    "__docId__": 289,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it23",
    "access": null,
    "description": "JWK EC should be successfully converted to PEM and re-converted to JWK correctly",
    "lineNumber": 36
  },
  {
    "__docId__": 290,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it24",
    "access": null,
    "description": "JWK EC should be successfully converted to PEM and re-converted to JWK correctly with public key compact form",
    "lineNumber": 66
  },
  {
    "__docId__": 291,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it25",
    "access": null,
    "description": "JWK EC should be successfully converted to DER and re-converted to JWK correctly",
    "lineNumber": 89
  },
  {
    "__docId__": 292,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it26",
    "access": null,
    "description": "JWK EC should be successfully converted to DER and re-converted to JWK correctly with public key compact form",
    "lineNumber": 112
  },
  {
    "__docId__": 293,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it27",
    "access": null,
    "description": "JWK EC should be successfully converted to uncompressed-octet formed key and vice varsa",
    "lineNumber": 133
  },
  {
    "__docId__": 294,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe22.it28",
    "access": null,
    "description": "JWK EC should be successfully converted to compact-octet formed key and vice varsa",
    "lineNumber": 154
  },
  {
    "__docId__": 295,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sampleRSA from './rsa_sample.js';\n\nimport jseu from 'js-encoding-utils';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nfunction prune(jwk){\n  delete jwk.ext;\n  delete jwk.alg;\n  delete jwk.key_ops;\n  return jwk;\n}\n\n\n\nconst bits = ['2048', '4096'];\ndescribe(`${envName}: RSA Key conversion from/to JWK test.`, () => {\n  before(async () => {\n  });\n\n  it('JWK RSA should be successfully converted from PEM', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('pem', sampleRSA[bitLen].publicKey.pem);\n      const jwkpub = await publicKey.export('jwk');\n      // private key\n      const privateKey = new keyutils.Key('pem', sampleRSA[bitLen].privateKey.pem);\n      const jwkpri = await privateKey.export('jwk');\n\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].publicKey.jwk))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].privateKey.jwk))));\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('PEM RSA should be successfully converted from JWK', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n      const pempub = await publicKey.export('pem');\n      // private key\n      const privateKey = new keyutils.Key('jwk', sampleRSA[bitLen].privateKey.jwk);\n      const pempri = await privateKey.export('pem');\n\n      return (pempub === sampleRSA[bitLen].publicKey.pem) && (pempri === sampleRSA[bitLen].privateKey.pem);\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('JWK RSA should be successfully converted from DER', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      const derpub = jseu.formatter.pemToBin(sampleRSA[bitLen].publicKey.pem);\n      const derpri = jseu.formatter.pemToBin(sampleRSA[bitLen].privateKey.pem);\n\n      // public key\n      const publicKey = new keyutils.Key('der', derpub);\n      const jwkpub = await publicKey.export('jwk');\n      // private key\n      const privateKey = new keyutils.Key('der', derpri);\n      const jwkpri = await privateKey.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].publicKey.jwk))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].privateKey.jwk))));\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('DER RSA should be successfully converted from JWK', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n      const derpub = await publicKey.export('der');\n      // private key\n      const privateKey = new keyutils.Key('jwk', sampleRSA[bitLen].privateKey.jwk);\n      const derpri = await privateKey.export('der');\n\n      return (derpub.toString() === jseu.formatter.pemToBin(sampleRSA[bitLen].publicKey.pem).toString())\n        && (derpri.toString() === jseu.formatter.pemToBin(sampleRSA[bitLen].privateKey.pem).toString());\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 296,
    "kind": "test",
    "name": "describe29",
    "testId": 29,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29",
    "access": null,
    "lineNumber": 31
  },
  {
    "__docId__": 297,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29.it30",
    "access": null,
    "description": "JWK RSA should be successfully converted from PEM",
    "lineNumber": 35
  },
  {
    "__docId__": 298,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29.it31",
    "access": null,
    "description": "PEM RSA should be successfully converted from JWK",
    "lineNumber": 52
  },
  {
    "__docId__": 299,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29.it32",
    "access": null,
    "description": "JWK RSA should be successfully converted from DER",
    "lineNumber": 67
  },
  {
    "__docId__": 300,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe29.it33",
    "access": null,
    "description": "DER RSA should be successfully converted from JWK",
    "lineNumber": 86
  },
  {
    "__docId__": 301,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sample from './encrypted_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\ndescribe(`${envName}: RSA/EC Key conversion from/to JWK test.`, () => {\n  const encOptionArray = [\n    {algorithm: 'pbes2'}, // = AES256 with hmachWithSHA256\n    {algorithm: 'pbes2', cipher: 'aes128-cbc', prf: 'hmacWithSHA256'},\n    // {algorithm: 'pbes2', cipher: 'aes192-cbc', prf: 'hmacWithSHA256'}, // not supported in Chrome\n    {algorithm: 'pbes2', cipher: 'aes256-cbc', prf: 'hmacWithSHA256'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA256'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA384'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA512'},\n    {algorithm: 'pbeWithMD5AndDES-CBC'},\n    {algorithm: 'pbeWithSHA1AndDES-CBC'}\n  ];\n  const rsaSample = sample.RSA;\n  const ecSample = sample.EC;\n\n  before(async () => {\n  });\n\n  it('RSA PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK', async function (){\n    this.timeout(10000);\n    const array = await Promise.all(Object.keys(rsaSample).map( async (key) => {\n      const elem = await Promise.all(encOptionArray.map( async (encOptions) => {\n        let result = true;\n        const privateKey = new keyutils.Key('pem', rsaSample[key]);\n        result = result && privateKey.isEncrypted;\n\n        await privateKey.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey.isEncrypted;\n\n        const jwkpri = await privateKey.export('pem').catch( () => {result = false; });\n        const pempri = await privateKey.export(\n          'pem', {\n            encryptParams: Object.assign({ passphrase: 'kddilabs' }, encOptions)\n          }\n        ).catch( () => {result = false; });\n\n        const privateKey2 = new keyutils.Key('pem', pempri);\n        result = result && privateKey2.isEncrypted;\n        await privateKey2.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey2.isEncrypted;\n\n        const jwkpri2 = await privateKey2.export('pem').catch( () => {result = false;});\n\n\n        return result && (objectSort(jwkpri).toString() === objectSort(jwkpri2).toString());\n      }));\n      console.log(elem);\n      return elem.every( (x) => x);\n    }));\n    expect(array.every( (x) => x)).to.be.true;\n\n    // AES256 encrypted key sample\n    // const test = '-----BEGIN ENCRYPTED PRIVATE KEY-----\\n' +\n    //   'MIIFLTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQI24WwHkKy4+0CAggA\\n' +\n    //   'MAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBDHasukS1RwbDihH6StdYmnBIIE\\n' +\n    //   '0A9gsWExWzLVV74rnE3PIKJuiophU6SxTpf5zNPaThM2vU7BqwIqNtGIpSMVEQbP\\n' +\n    //   'UsbKt5OOgm4cWgLQ4mp6ZVj84kym2IOv+OYKKw5qKsDG2egcYCXG0RtSoRaBM8Us\\n' +\n    //   'ju3j7lL0A4dEuiUqeun9m742HuQ+8VDZU4+4eO5V5AcaVvwex+tROqyhTsdDO8BB\\n' +\n    //   'LPuCC05dt4pn7bn3pgBm0ZVUAF1FJLs/rncPhJnJDflpbDApsFaRWNpD3878F9L8\\n' +\n    //   'BLKHZr/srJu1ajcM6E5avyzTvnpeRYqLMqanXqGy957yOg23NANcny20NHktkZJz\\n' +\n    //   '/oqdWrjiXT4gPHAskx2KYPaVySOVa55tBGoqVovzCHFNuIjwamucg5ZWZY8C6sJC\\n' +\n    //   '0ZaFAW9TV3Rs2GqxcL3LFx9zEgDWT+VJxQaNFXoXLz8ROYKh6QKAV7jgV4JOUYc6\\n' +\n    //   'ow3gGUqkhEyIYDuKzZOWeZ1IMHltMUaRz7S+ygPxBvgnjthA1XU9JRv3QSNleLGz\\n' +\n    //   'WcZBWDhNXLIKepefrBgvrYim3qdfK5H72FjYOx3Ir8K52dPB4BMqqz8JJjSRMfYM\\n' +\n    //   'ak5abTy6znSnHHHYOrYQE47E9RTYqu2rMp3B75Xru2KUxoVFV49xXXEYNzCNwFg+\\n' +\n    //   'PwE8gF04mEoqBiwFn40woVQUN8WpWFl3pzKai9HvIPYUOSpZrmPzE8Mu/SVpV//G\\n' +\n    //   '3fkVwmOyCOs3Tg/tA5aKKjMbSXMJULhCbtxUwx2Kxn8K0PfrRk7+MmLOQlp9JDvN\\n' +\n    //   'esrONUx/7R0SyuGkEYCQyEHzlURNrWG0ZQDlBOMIuItj2ikoNYvoNTctPsYIQdkr\\n' +\n    //   'ZwHSJR0DvxCA4/Vso72tnTNrZS2CoNJfJVfE8VwtA0QX9jgkS1b8nkPk1tcrvYsw\\n' +\n    //   '9uPYXDvmucQyKIKWomA9s27vDw0QqIwgMJ6vIWnaRDDXuIF4CpAOrwaW78ZHee1M\\n' +\n    //   'fvBq571/NMJFemqh8KMLZfBzkj/JoUfxRbZmBfKs/JdRZ/W6OOO5NZLcGprslpJd\\n' +\n    //   'u29LBMIx+cmgUZCjDtbKHDMeeG6ptSl4omLrcTE7+ZowOSUaTVxlRqweMqKNJmuc\\n' +\n    //   'esfWhGEbppk+oPyXDzQ9ENIUcrKin5RJ8QKcxvpiWHxAqwzfXB9eqzUkAuDmQOel\\n' +\n    //   'jbnigof4XL+KKnANoHHOgs47kKNJm2PzHOvxsKKiI4LIC2AMp2nGrpiMtyP/7uie\\n' +\n    //   'tZ6Po5HffFSTjlYEE9jEfQ/tipIqyxvEEK+aPYdZ5P3vW2OI0CTcrXJxLlBVPaxB\\n' +\n    //   'JVD4oMxKdIEIpmV0qnBtaD7aEF2lSIk0gYNnz+DKbXi12zmHNuJ77u6lbXN6lhlr\\n' +\n    //   'lcPWHQq4btWKDPR79+0lyQiY0UmdwQOUaihvdU6mY07PmslnUbtj5XVDDNP22Qdz\\n' +\n    //   '3jk9pGVlTcgPQqmcDVdMbHtT8khpIimriI186BvcbPOWI5H4UThyXTSisDPzEGQR\\n' +\n    //   'F9Z9mNb6p71nqARRNcNIMlA7JJombnR4Ws1NDv5y9szp6WH/lkTDyWw3k9sjrx8a\\n' +\n    //   'is2Ke0G4AAq0uP+ev5TMtnFZrLnGvt4KkWpJgibiIje+e3rya9jk+GH8qf2nldlj\\n' +\n    //   'ywUZpixaRCAyxa2Bbjcm/lKsUfdMq8cgzRW51wTpFlMs\\n' +\n    //   '-----END ENCRYPTED PRIVATE KEY-----';\n    // console.log(await keyutils.toJwkFrom('pem', test, {passphrase: 'kddilabs'}).catch( () => {result = false;}));\n  });\n\n\n  it('EC PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK', async function() {\n    this.timeout(10000);\n    const array = await Promise.all(Object.keys(ecSample).map( async (key) => {\n      const elem = await Promise.all(encOptionArray.map( async (encOptions) => {\n        let result = true;\n        const privateKey = new keyutils.Key('pem', ecSample[key]);\n        result = result && privateKey.isEncrypted;\n\n        await privateKey.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey.isEncrypted;\n\n        const jwkpri = await privateKey.export('pem').catch( () => {result = false; });\n        const pempri = await privateKey.export(\n          'pem', {\n            encryptParams: Object.assign({ passphrase: 'kddilabs' }, encOptions)\n          }\n        ).catch( () => {result = false; });\n\n        const privateKey2 = new keyutils.Key('pem', pempri);\n        result = result && privateKey2.isEncrypted;\n        await privateKey2.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey2.isEncrypted;\n\n        const jwkpri2 = await privateKey2.export('pem').catch( () => {result = false;});\n\n\n        return result && (objectSort(jwkpri).toString() === objectSort(jwkpri2).toString());\n      }));\n      console.log(elem);\n      return elem.every( (x) => x);\n    }));\n    expect(array.every( (x) => x)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 302,
    "kind": "test",
    "name": "describe34",
    "testId": 34,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe34",
    "access": null,
    "lineNumber": 19
  },
  {
    "__docId__": 303,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe34.it35",
    "access": null,
    "description": "RSA PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK",
    "lineNumber": 37
  },
  {
    "__docId__": 304,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe34.it36",
    "access": null,
    "description": "EC PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK",
    "lineNumber": 105
  },
  {
    "__docId__": 305,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sampleEC from './ec_sample.js';\nimport sampleRSA from './rsa_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\nconst bits = ['2048', '4096'];\nconst hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\ndescribe(`${envName}: JWK thumbprint generation test.`, () => {\n\n  let keySet = [];\n  before(async () => {\n    keySet = sampleEC.ecKey; //await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('EC: JWK thumbprint in array buffer is generated successfully for each curve and hashes', async () => {\n    const tps = await Promise.all( keySet.map(\n      async (jwkey) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', jwkey.publicKey);\n          const tp = await key.getJwkThumbprint(h);\n          expect(tp instanceof Uint8Array).to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('EC: JWK thumbprint in hex string is generated successfully for each curve and hashes', async () => {\n    const tps = await Promise.all( keySet.map(\n      async (jwkey) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', jwkey.publicKey);\n          const tp = await key.getJwkThumbprint(h, 'hex');\n          expect(typeof(tp)==='string').to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('RSA: JWK thumbprint in array buffer is generated successfully for each bits and hashes', async () => {\n    const tps = await Promise.all( bits.map(\n      async (bitLen) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n          const tp = await key.getJwkThumbprint(h);\n          expect(tp instanceof Uint8Array).to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('RSA: JWK thumbprint in hex string is generated successfully for each bits and hashes', async () => {\n    const tps = await Promise.all( bits.map(\n      async (bitLen) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n          const tp = await key.getJwkThumbprint(h, 'hex');\n          expect(typeof(tp)==='string').to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 306,
    "kind": "test",
    "name": "describe37",
    "testId": 37,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37",
    "access": null,
    "lineNumber": 16
  },
  {
    "__docId__": 307,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37.it38",
    "access": null,
    "description": "EC: JWK thumbprint in array buffer is generated successfully for each curve and hashes",
    "lineNumber": 23
  },
  {
    "__docId__": 308,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37.it39",
    "access": null,
    "description": "EC: JWK thumbprint in hex string is generated successfully for each curve and hashes",
    "lineNumber": 36
  },
  {
    "__docId__": 309,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37.it40",
    "access": null,
    "description": "RSA: JWK thumbprint in array buffer is generated successfully for each bits and hashes",
    "lineNumber": 49
  },
  {
    "__docId__": 310,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe37.it41",
    "access": null,
    "description": "RSA: JWK thumbprint in hex string is generated successfully for each bits and hashes",
    "lineNumber": 62
  },
  {
    "__docId__": 311,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/misc.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst Key = env.library.Key;\nconst envName = env.envName;\n\n\nimport sampleRSA from './rsa_sample.js';\nimport sampleEC from './ec_sample.js';\nimport jseu from 'js-encoding-utils';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nconst bits = ['2048', '4096'];\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\ndescribe(`${envName}: RSA/EC Key conversion from/to JWK test.`, () => {\n\n  let ECKeySet = [];\n  before(async function (){\n    this.timeout(20000);\n    ECKeySet = sampleEC.ecKey;//await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('EC: Derive public key to private key', async function () {\n    this.timeout(4000);\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const keyObj = new Key('jwk', key.privateKey);\n      expect(keyObj.isPrivate).to.be.true;\n\n      const pubpemCompact = await keyObj.export('pem', {compact: true, outputPublic: true});  // export public from private\n      const koc = new Key('pem', pubpemCompact);\n      expect(koc.isPrivate).to.be.false;\n      const kocjwk = await koc.export('jwk');\n\n      const pubpem = await keyObj.export('pem', {compact: false, outputPublic: true});  // export public from private\n      const ko = new Key('pem', pubpem);\n      expect(ko.isPrivate).to.be.false;\n      const kojwk = await ko.export('jwk');\n\n      expect(\n        JSON.stringify(objectSort(kocjwk)) === JSON.stringify(objectSort(key.publicKey))\n        && JSON.stringify(objectSort(kojwk)) === JSON.stringify(objectSort(key.publicKey))\n      ).to.be.true;\n\n      const octpemCompact = await keyObj.export('oct', {compact: true, output:'string', outputPublic: true});\n      const ooc = new Key('oct', jseu.encoder.hexStringToArrayBuffer(octpemCompact), {namedCurve: key.publicKey.crv});\n      // console.log(getKeyStatus(ooc));\n      expect(ooc.isPrivate).to.be.false;\n      const oocjwk = await ooc.export('jwk');\n\n\n      const octpem = await keyObj.export('oct', {compact: false, output:'string', outputPublic: true}); // export public from private\n      const oo = new Key('oct', jseu.encoder.hexStringToArrayBuffer(octpem), {namedCurve: key.publicKey.crv});\n      expect(oo.isPrivate).to.be.false;\n      const oojwk = await oo.export('jwk');\n\n      expect(\n        JSON.stringify(objectSort(oocjwk)) === JSON.stringify(objectSort(key.publicKey))\n        && JSON.stringify(objectSort(oojwk)) === JSON.stringify(objectSort(key.publicKey))\n      ).to.be.true;\n\n\n    }));\n    // console.log(array);\n    // expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n\n  it('Status Change Test', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      const key = new Key('pem', sampleRSA[bitLen].privateKey.pem);\n      let status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 0 && !status.status.jwk\n      ).to.be.true;\n\n      const jwk = await key.export('jwk');\n      status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 9 && status.status.jwk\n      ).to.be.true;\n\n      await key.encrypt('password');\n      status = getKeyStatus(key);\n      expect(\n        status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 0 && !status.status.jwk\n      ).to.be.true;\n      // console.log(status);\n\n      const asis = await key.export('pem');\n      // console.log(asis);\n\n      await key.decrypt('password');\n      status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength === 0 && !status.status.der\n        && status.jwkKeyLength === 9 && status.status.jwk\n      ).to.be.true;\n      // console.log(status);\n\n      // console.log(await key.getJwkThumbprint('SHA-256', 'hex'));\n\n\n    }));\n    // console.log(array);\n    // expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('Misc', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const keyObj = new Key('jwk', key.privateKey);\n      const kty = await keyObj.keyType;\n      expect(kty === 'EC').to.be.true;\n\n      console.log(jseu.encoder.arrayBufferToHexString(await keyObj.jwkThumbprint));\n    }));\n  });\n\n});\n\nconst getKeyStatus = (k) => ({\n  type: k._type,\n  private: k.isPrivate,\n  derLength: (k._der) ? k._der.length : 0,\n  octLength: (k._oct) ? Object.keys(k._oct).length : 0,\n  jwkKeyLength: (k._jwk) ? Object.keys(k._jwk).length : 0,\n  status: k._current,\n  isEncrypted: k.isEncrypted\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/misc.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 312,
    "kind": "test",
    "name": "describe42",
    "testId": 42,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe42",
    "access": null,
    "lineNumber": 24
  },
  {
    "__docId__": 313,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe42.it43",
    "access": null,
    "description": "EC: Derive public key to private key",
    "lineNumber": 32
  },
  {
    "__docId__": 314,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe42.it44",
    "access": null,
    "description": "Status Change Test",
    "lineNumber": 77
  },
  {
    "__docId__": 315,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe42.it45",
    "access": null,
    "description": "Misc",
    "lineNumber": 128
  },
  {
    "__docId__": 316,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/misc2.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst Key = env.library.Key;\nconst envName = env.envName;\n\nimport jseu from 'js-encoding-utils';\nimport {pruneLeadingZeros, appendLeadingZeros} from '../src/util.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\ndescribe(`${envName}: RSA Key pruning leading zeros and appending leading zeros`, () => {\n\n  const badRSA = {\n    'kty': 'RSA',\n    'e': 'AAEAAQ', // 00 01 00 01\n    'n': 'qLOyhK-OtQs4cDSoYPFGxJGfMYdjzWxVmMiuSBGh4KvEx-CwgtaTpef87Wdc9GaFEncsDLxkp0LGxjD1M8jMcvYq6DPEC_JYQumEu3i9v5fAEH1VvbZi9cTg-rmEXLUUjvc5LdOq_5OuHmtme7PUJHYW1PW6ENTP0ibeiNOfFvs'\n  };\n  before(async() => {\n  });\n\n  it('Bad RSA JWK', async function () {\n    this.timeout(4000);\n    const key = new Key('jwk', badRSA);\n    const der = await key.export('der');\n    const newKey = new Key('der', der);\n    const newJwk = await newKey.export('jwk');\n    expect(newJwk.e === 'AQAB').to.be.true;\n\n  });\n\n  it('util test', async () => {\n    const leading = jseu.encoder.decodeBase64Url('AAEAAQ');\n    const nonleading = jseu.encoder.decodeBase64Url('AQAB');\n\n    expect(pruneLeadingZeros(leading).toString() === nonleading.toString()).to.be.true;\n    expect(appendLeadingZeros(nonleading, leading.length).toString() === leading.toString()).to.be.true;\n\n    const msg = new Uint8Array(256);\n    const offset = 17;\n    msg.forEach( (x, idx) => { msg[idx] = (offset > idx) ? 0x00 : 0xFF & idx; });\n\n    const b64uLeading = jseu.encoder.encodeBase64Url(msg);\n    const binLeading = jseu.encoder.decodeBase64Url(b64uLeading);\n    const b64uNonLeading = jseu.encoder.encodeBase64Url(msg.slice(offset));\n    const binNonLeading = jseu.encoder.decodeBase64Url(b64uNonLeading);\n\n    expect(pruneLeadingZeros(binLeading).toString() === binNonLeading.toString()).to.be.true;\n\n    expect(appendLeadingZeros(binNonLeading, binLeading.length).toString() === binLeading.toString()).to.be.true;\n\n\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/misc2.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 317,
    "kind": "test",
    "name": "describe46",
    "testId": 46,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe46",
    "access": null,
    "lineNumber": 20
  },
  {
    "__docId__": 318,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe46.it47",
    "access": null,
    "description": "Bad RSA JWK",
    "lineNumber": 30
  },
  {
    "__docId__": 319,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe46.it48",
    "access": null,
    "description": "util test",
    "lineNumber": 40
  },
  {
    "__docId__": 320,
    "kind": "testFile",
    "name": "packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "content": "import chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\nimport jseu from 'js-encoding-utils';\n\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst pbkdf = env.library;\nconst envName = env.envName;\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\nconst sample = {\n  pbkdf1: {\n    p: 'password',\n    pbuf: '70617373776f7264',\n    s: 'dc04deff5a33c22df3aa82085f9c2d0f5477af73cd500dfe53162d70ba096a03',\n    c: 2048,\n    dkLen: 16,\n    key: {\n      'SHA-256': '2e460082f6002d377042bbfd7c3fcf61',\n      'SHA-384': 'bc3d241bd9975babb7bb7fd0c843c9e0',\n      'SHA-512': '2b875a1a163ade05f788ba386033c20a',\n      'SHA-1': '55ce9e9aa9bf733f193e66620365fe0e',\n      'MD5': '9238c6bfe098e5c4e7b68549233cc8ef'\n    }\n  },\n  pbkdf2: {\n    p: 'password',\n    pbuf: '70617373776f7264',\n    s: 'dc04deff5a33c22df3aa82085f9c2d0f5477af73cd500dfe53162d70ba096a03',\n    c: 2048,\n    dkLen: 32,\n    key: {\n      'SHA-256': 'bf3d09d429fbf71bbb384a6421447da32096ff8a010c7042d3e29194237792d2',\n      'SHA-384': 'f4e9e3377bfdb37695b41d163b67f6a8de017db98ea69bd5163f9d771a141878',\n      'SHA-512': 'ff055f4a1f3b9b70de87ecd942c7aed9d1e5b77d5b4d36f92389ead9f6c359bf',\n      'SHA-1': 'ca95cba5373ca0b86ad1dd7b31fb51d77f4cdc424c1d9b704620cee505bdc772',\n      'MD5': '28ecf8c0c5435581175b094cb7626fff5dca051755dcab43add58cff48abfe8f'\n    }\n  }\n};\n\ndescribe(`${envName}: Test for PBKDF 1 and 2`, () => {\n  before( async () => {\n  });\n\n  it('PBKDF2 with password string', async () => {\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf2(\n        sample.pbkdf2.p,\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.s),\n        sample.pbkdf2.c,\n        sample.pbkdf2.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf2.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF2 with password buffer', async () => {\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf2(\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.pbuf),\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.s),\n        sample.pbkdf2.c,\n        sample.pbkdf2.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf2.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF1 with password string', async () => {\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf1(\n        sample.pbkdf1.p,\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.s),\n        sample.pbkdf1.c,\n        sample.pbkdf1.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf1.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF1 with password buffer', async () => {\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf1(\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.pbuf),\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.s),\n        sample.pbkdf1.c,\n        sample.pbkdf1.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf1.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 321,
    "kind": "test",
    "name": "describe49",
    "testId": 49,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49",
    "access": null,
    "lineNumber": 43
  },
  {
    "__docId__": 322,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49.it50",
    "access": null,
    "description": "PBKDF2 with password string",
    "lineNumber": 47
  },
  {
    "__docId__": 323,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49.it51",
    "access": null,
    "description": "PBKDF2 with password buffer",
    "lineNumber": 61
  },
  {
    "__docId__": 324,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49.it52",
    "access": null,
    "description": "PBKDF1 with password string",
    "lineNumber": 75
  },
  {
    "__docId__": 325,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe49.it53",
    "access": null,
    "description": "PBKDF1 with password buffer",
    "lineNumber": 89
  },
  {
    "__docId__": 326,
    "kind": "testFile",
    "name": "packages/js-crypto-random/test/random.spec.js",
    "content": "import chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst random = env.library;\nconst envName = env.envName;\n\n\ndescribe(`${envName}: Random generation test`, () => {\n\n  it('Random bytes of desired length should be generated successfully', () => {\n    const r = random.getRandomBytes(32);\n    expect(r).to.be.a('Uint8Array');\n    expect(r).to.be.length(32);\n  });\n\n  it('Random ascii string of desired length should be generated successfully', () => {\n    const r = random.getRandomAsciiString(32);\n    expect(r).to.be.a('String');\n    expect(r).to.be.length(32);\n  });\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/test/random.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 327,
    "kind": "test",
    "name": "describe54",
    "testId": 54,
    "memberof": "packages/js-crypto-random/test/random.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe54",
    "access": null,
    "lineNumber": 10
  },
  {
    "__docId__": 328,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "packages/js-crypto-random/test/random.spec.js~describe54",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe54.it55",
    "access": null,
    "description": "Random bytes of desired length should be generated successfully",
    "lineNumber": 12
  },
  {
    "__docId__": 329,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "packages/js-crypto-random/test/random.spec.js~describe54",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe54.it56",
    "access": null,
    "description": "Random ascii string of desired length should be generated successfully",
    "lineNumber": 18
  },
  {
    "__docId__": 330,
    "kind": "testFile",
    "name": "packages/js-crypto-rsa/test/rsa.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst rsa = env.library;\nconst envName = env.envName;\n\n\nimport rsaSmaple from './rsa_sample.js';\n// import * as oaep from '../src/oaep.js';\nimport jseu from 'js-encoding-utils';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\ndescribe(`${envName}: RSA cryptography test`, () => {\n\n  const modulusLength = ['2048', '4096'];\n  const keys = [];\n  const msgLen = 128;\n  const msg = new Uint8Array(msgLen);\n  before( async () => {\n    for(let i = 0; i < msgLen; i++) msg[i] = 0xFF & i;\n  });\n\n  it('JWK key pair is correctly generated', async function () {\n    this.timeout(500000);\n    const results = await Promise.all(modulusLength.map(async (n) => {\n      let result = true;\n      const key = await rsa.generateKey(n).catch((e) => {\n        result = false;\n      });\n      keys.push(key);\n      // console.log(key);\n      return result;\n    }));\n    console.log(results);\n    console.log(keys);\n    expect(results.every((r) => r)).to.be.true;\n  });\n\n  it('Message is successfully encrypted and encrypted', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(Object.keys(rsaSmaple).map( async (kp) => {\n      let result = true;\n      const encrypted = await rsa.encrypt(msg, rsaSmaple[kp].publicKey.jwk, 'SHA-256').catch( (e) => {result = false;});\n      // console.log(jseu.encoder.encodeBase64(encrypted));\n      const decrypted = await rsa.decrypt(encrypted, rsaSmaple[kp].privateKey.jwk, 'SHA-256').catch( (e) => {result = false;});\n\n      expect(result).to.be.true;\n      return (decrypted.toString() === msg.toString());\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  // it('OAEP', async function (){\n  //   this.timeout(50000);\n  //   const em = await oaep.emeOaepEncode(msg, new Uint8Array([]), 256, 'SHA-256');\n  //   // console.log(em);\n  //   const msgPrime = await oaep.emeOaepDecode(em, new Uint8Array([]), 256, 'SHA-256');\n  //   expect(msg.toString() === msgPrime.toString()).to.be.true;\n  // });\n\n  it('RSASSA-PKCS1-v1_5: Message is successfully signed and verified with generated JWK pairs', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(Object.keys(rsaSmaple).map( async (kp) => {\n      let result = true;\n      const sign = await rsa.sign(msg, rsaSmaple[kp].privateKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'}).catch( (e) => {result = false; console.error(e);});\n      // console.log(sign);\n      // console.log(jseu.encoder.encodeBase64(sign));\n      const valid = await rsa.verify(msg, sign, rsaSmaple[kp].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'}).catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n    it('RSA-PSS: Message is successfully signed and verified with generated JWK pairs', async function () {\n      this.timeout(5000);\n      const results = await Promise.all(Object.keys(rsaSmaple).map(async (kp) => {\n        let result = true;\n        const sign = await rsa.sign(msg, rsaSmaple[kp].privateKey.jwk, 'SHA-256').catch((e) => {\n          result = false;\n        });\n        // console.log(jseu.encoder.encodeBase64(sign));\n        const valid = await rsa.verify(msg, sign, rsaSmaple[kp].publicKey.jwk, 'SHA-256').catch((e) => {\n          result = false;\n        });\n        expect(result).to.be.true;\n\n        return valid;\n      }));\n      console.log(results);\n      expect(results.every((r) => r)).to.be.true;\n    });\n  }\n\n\n  it('Compatibility test', async () => {\n    const webEnc = 'd8ehCiJyQjqjrWnKSNBJ+5Q7SS+5Xdv+Bevcn+3xYX4zMMsY2BCDux75rvexiUcIZphXf3HRNsrL340wlGhg0sNKGBaFR1Nv2D3Ta5FyEnuDbSxl6hItF6pvZ628c0DW5/YTfPE1xJLZwE+8bHAgjJO3eob5vU7/h8X9tZtf37FUfPIMLDWNc4v7E2uynrzV0xHpg6J7QZbwvJmz9uShEVraR0pkR86MPvNnRw8y2iB+xAK5V+CqZLT6I5+rZuWWxaI5+9BypeR2JmNXogrqg88/JiKy1N/TdwJ2ZJ8inu1VW97soJbLmtNPH2Ur5Dd+9dZSNKhdNQwS0QLXZn3C6A==';\n    const webSig = 'CHoyzFCHWBPv6cXPplD8P0IRIO/683lfMMcMYmyukkotegyNnP+BtwID3e7f41tRe7sxUXJtb/MjUkDtxv08T2dBTAgNJtk/LLDvNVJ0AJ7MwATQpojzY1xoyEOnRhrDsYjYI+ITYDMLFbvAng2x8hf5mNrR+GoAZLxsBFtq+4n4av7FFmPMpwpFJ/R6arQky3OIt6/dm3d5jQQ6kTPSHKb3gVrutsXUUrSosXQiMDz0Qu6T2bdwKHWX5zO9P00AYwgpoLaWV+vHXQNEyyxLA/VgB2C8obpTNNJF5rqcuVp9KNGmffV43UnzWZX0YAB5JSIc+9JXKqj71JO3Q7AjTA==\\n';\n    const webSigPKCS1V15 = 'HOe0gTJIHojBv5M0cMIZLIH4k/ZQu8fl2ko3vU+lwx7W24KvQMp8FwjtZt7Cg+7A4PV0BO/w/pHdpaA6SM22er2fYy0jQsC+TWpkd4Z7jPNsQDSRK7UI/xTRrAlYvat4wb5DZrN6x73/m9MZqXXpfIGrmIe0wu7MHW2iRk063bA/A2rxD9bveO6H3l4zYdMRxjwA6I2Wvgc1KxDZrPxGdDDt4EUzekj3rBSOB7S1EUKlc7hC1BicgIUe3Z1hGaCS0T7EwWuqZ091lyiJGrR2aayn8bKLQmeROKEcO51CWLLM5pF6M3hTACt1saz9kGufDvqWPw8uyMP+aPGlV+ASsw==';\n    const nodeEnc = 'oryyTFEC/BEgCjML93pibShvvQws120JQ41jFFhY8qm2ceGfknkBXmZYuafsCk2tUGO82mYoS0vGRd22jcQ35Bz5AcnBRlCSk90GUUPYvoRe3ED6k8rzYsi7JkMRWbXOSaI2UBx6cxWHS6ooY/XYsjubz7D+sV6okQkBbGpVCOhw0biBI6QYw54YaMryW3yxSKIoq56Z6mWNMmSTbY1DC9l6ckDn0XDePdZs/SQox1g35OmBNnALRn92Nltg6Bw1wuV/FKNsosiwdwZW7VoQqpvHORDsBBIVG++tIx/T2E5D1tddGOt0vqEWuEA3zn6x/FmKSeLzO6KGaD1xzoivTA==';\n    const nodeSig = 'c9vdu4tmstRJEk1fLLLqU/r6cNZ9Tp74Zw2VsJxNvoAEFP/BXkwq27drupqajvxj+QKxP7ggs83Oi/cppmqAFghXMU1OJRRdMIbcn9O8RBZ0SJkY/LHy8NUrNvJ3AY8EjL3zqH1X0YaQltnKs9xgne4p+DpL45fQlFz8BJML+Tw1bIS59uZ87RNIEcAytiwH6VXb/HLJdLZD40OWfG2lD4g5oobZz/Gdd1ncAFuFcl0ut7SZu/wltp8DCXeQ6zl4lUG7YS3+RG0Iigq45pBYhq2Hrag+t0YQwTQQRGhKEjFlr8cKIdUaTSDgEwNcRf25cSVSJrrFepaKswM8QDkpVw==';\n    const nodeSigPKCS1V15 = 'HOe0gTJIHojBv5M0cMIZLIH4k/ZQu8fl2ko3vU+lwx7W24KvQMp8FwjtZt7Cg+7A4PV0BO/w/pHdpaA6SM22er2fYy0jQsC+TWpkd4Z7jPNsQDSRK7UI/xTRrAlYvat4wb5DZrN6x73/m9MZqXXpfIGrmIe0wu7MHW2iRk063bA/A2rxD9bveO6H3l4zYdMRxjwA6I2Wvgc1KxDZrPxGdDDt4EUzekj3rBSOB7S1EUKlc7hC1BicgIUe3Z1hGaCS0T7EwWuqZ091lyiJGrR2aayn8bKLQmeROKEcO51CWLLM5pF6M3hTACt1saz9kGufDvqWPw8uyMP+aPGlV+ASsw==';\n\n    const decrypted = await rsa.decrypt(jseu.encoder.decodeBase64(webEnc), rsaSmaple['2048'].privateKey.jwk, 'SHA-256');\n    console.log(decrypted.toString() === msg.toString());\n    expect(decrypted.toString() === msg.toString()).to.be.true;\n\n    if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n      const valid = await rsa.verify(msg, jseu.encoder.decodeBase64(webSig), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {\n        name: 'RSA-PSS',\n        saltLength: 192\n      });\n      console.log(valid);\n      expect(valid).to.be.true;\n    }\n    const validP = await rsa.verify(msg, jseu.encoder.decodeBase64(webSigPKCS1V15), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'});\n    console.log(validP);\n    expect(validP).to.be.true;\n\n    const decryptedNode = await rsa.decrypt(jseu.encoder.decodeBase64(nodeEnc), rsaSmaple['2048'].privateKey.jwk, 'SHA-256');\n    console.log(decryptedNode.toString() === msg.toString());\n    expect(decryptedNode.toString() === msg.toString()).to.be.true;\n\n    if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n      const validNode = await rsa.verify(msg, jseu.encoder.decodeBase64(nodeSig), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {\n        name: 'RSA-PSS',\n        saltLength: 192\n      });\n      console.log(validNode);\n      expect(validNode).to.be.true;\n    }\n\n    const validNodeP = await rsa.verify(msg, jseu.encoder.decodeBase64(nodeSigPKCS1V15), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'});\n    console.log(validNodeP);\n    expect(validNodeP).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/test/rsa.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 331,
    "kind": "test",
    "name": "describe57",
    "testId": 57,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "access": null,
    "lineNumber": 14
  },
  {
    "__docId__": 332,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57.it58",
    "access": null,
    "description": "JWK key pair is correctly generated",
    "lineNumber": 24
  },
  {
    "__docId__": 333,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57.it59",
    "access": null,
    "description": "Message is successfully encrypted and encrypted",
    "lineNumber": 40
  },
  {
    "__docId__": 334,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57.it60",
    "access": null,
    "description": "RSASSA-PKCS1-v1_5: Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 63
  },
  {
    "__docId__": 335,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57.it61",
    "access": null,
    "description": "RSA-PSS: Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 80
  },
  {
    "__docId__": 336,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe57.it62",
    "access": null,
    "description": "Compatibility test",
    "lineNumber": 101
  },
  {
    "__docId__": 337,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.encrypt.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\ndescribe(`${envName}: Encryption test`, () => {\n  const curves = ['P-256', 'P-384', 'P-521'];\n  const hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\n  let ecKeySet = [];\n  let rsaKeySet = [];\n  let msg;\n  before( async function () {\n    this.timeout(10000);\n    ecKeySet = await Promise.all(curves.map( async (crv) => [ await jscu.pkc.generateKey('EC', {namedCurve: crv}), await jscu.pkc.generateKey('EC', {namedCurve: crv})]));\n    rsaKeySet = await Promise.all([2048, 4096].map( async (nLen) => await jscu.pkc.generateKey('RSA', {modulusLength: nLen})));\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('ECDH: Encrypted message is successfully generated and decrypted', async () => {\n    for (let i = 0; i < curves.length; i++) {\n      for (let j = 0; j < hashes.length; j++) {\n        let options = {\n          privateKey: ecKeySet[i][1].privateKey,\n          hash: hashes[j],\n          encrypt: 'AES-GCM',\n          keyLength: 32,\n          info: ''\n        };\n        const encrypted = await jscu.pkc.encrypt(msg, ecKeySet[i][0].publicKey, options);\n\n        options = {\n          publicKey: ecKeySet[i][1].publicKey,\n          hash: hashes[j],\n          encrypt: 'AES-GCM',\n          keyLength: 32,\n          info: '',\n          salt: encrypted.salt,\n          iv: encrypted.iv\n        };\n        const decrypted = await jscu.pkc.decrypt(encrypted.data, ecKeySet[i][0].privateKey, options);\n\n        expect(msg.toString() === decrypted.toString()).to.be.true;\n      }\n    }\n  });\n\n  it('RSA-OAEP: Encrypted message is successfully generated and decrypted', async () => {\n    const results = await Promise.all(rsaKeySet.map( async (kp) => {\n      let result = true;\n      const encrypted = await jscu.pkc.encrypt(msg, kp.publicKey, {hash: 'SHA-256'}).catch( (e) => {console.error(e); result = false;});\n      const decrypted = await jscu.pkc.decrypt(encrypted.data, kp.privateKey, {hash: 'SHA-256'}).catch( (e) => {result = false;});\n\n      expect(result).to.be.true;\n      return (decrypted.toString() === msg.toString());\n    }));\n    expect(results.every( (r) => r)).to.be.true;\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.encrypt.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 338,
    "kind": "test",
    "name": "describe63",
    "testId": 63,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe63",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 339,
    "kind": "test",
    "name": "it64",
    "testId": 64,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe63",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe63.it64",
    "access": null,
    "description": "ECDH: Encrypted message is successfully generated and decrypted",
    "lineNumber": 20
  },
  {
    "__docId__": 340,
    "kind": "test",
    "name": "it65",
    "testId": 65,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe63",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe63.it65",
    "access": null,
    "description": "RSA-OAEP: Encrypted message is successfully generated and decrypted",
    "lineNumber": 48
  },
  {
    "__docId__": 341,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.keygen.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\nasync function ecKeyPairAssert(kp){\n  expect(kp.publicKey instanceof jscu.Key).to.be.true;\n  expect(kp.privateKey instanceof jscu.Key).to.be.true;\n\n  const publicJwk = await kp.publicKey.export('jwk');\n  const privateJwk = await kp.privateKey.export('jwk');\n\n  expect(privateJwk.x).to.be.a('string');\n  expect(privateJwk.y).to.be.a('string');\n  expect(privateJwk.d).to.be.a('string');\n  expect(publicJwk.x).equal(privateJwk.x);\n  expect(publicJwk.y).equal(privateJwk.y);\n}\n\nasync function rsaKeyPairAssert(kp){\n  expect(kp.publicKey instanceof jscu.Key).to.be.true;\n  expect(kp.privateKey instanceof jscu.Key).to.be.true;\n\n  const publicJwk = await kp.publicKey.export('jwk');\n  const privateJwk = await kp.privateKey.export('jwk');\n\n  expect(privateJwk.n).to.be.a('string');\n  expect(privateJwk.e).to.be.a('string');\n  expect(privateJwk.d).to.be.a('string');\n  expect(privateJwk.p).to.be.a('string');\n  expect(privateJwk.q).to.be.a('string');\n  expect(privateJwk.dp).to.be.a('string');\n  expect(privateJwk.dq).to.be.a('string');\n  expect(privateJwk.qi).to.be.a('string');\n  expect(publicJwk.n).equal(privateJwk.n);\n  expect(publicJwk.e).equal(privateJwk.e);\n}\n\ndescribe(`${envName}: Key generation test via exported api`, () => {\n\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  it('ECDSA Key Generation should be done successfully', async function () {\n    this.timeout(10000);\n    await Promise.all(curves.map( async (crv) => {\n      const kp = await jscu.pkc.generateKey('EC', {namedCurve: crv});\n      await ecKeyPairAssert(kp);\n    }));\n  });\n\n  it('ECDSA Key Generation should be done unsuccessfully', async function () {\n    this.timeout(10000);\n    const crv = '256'; // unsupported // K-256 is supported sometimes.\n    let err;\n    try {\n      const kp = await jscu.pkc.generateKey('EC', {namedCurve: crv});\n      await ecKeyPairAssert(kp);\n    } catch (e) { err = e; }\n    expect(err).to.be.a('error');\n  });\n\n  it('RSA Key Generation should be done successfully', async function () {\n    this.timeout(10000);\n    let result = true;\n    await Promise.all([2048, 4096].map( async (nLen) => {\n      const kp = await jscu.pkc.generateKey('RSA', {modulusLength: nLen});\n      await rsaKeyPairAssert(kp);\n    })).catch( () => { result = false; });\n    // console.log(keys);\n    expect(result).to.be.true;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.keygen.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 342,
    "kind": "test",
    "name": "describe66",
    "testId": 66,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66",
    "access": null,
    "lineNumber": 39
  },
  {
    "__docId__": 343,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66.it67",
    "access": null,
    "description": "ECDSA Key Generation should be done successfully",
    "lineNumber": 42
  },
  {
    "__docId__": 344,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66.it68",
    "access": null,
    "description": "ECDSA Key Generation should be done unsuccessfully",
    "lineNumber": 50
  },
  {
    "__docId__": 345,
    "kind": "test",
    "name": "it69",
    "testId": 69,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe66.it69",
    "access": null,
    "description": "RSA Key Generation should be done successfully",
    "lineNumber": 61
  },
  {
    "__docId__": 346,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.sign.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\ndescribe(`${envName}: Signing and verification test via exported api`, () => {\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  const hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\n  let ecKeySet = [];\n  let rsaKeySet = [];\n  let msg;\n  before( async function () {\n    this.timeout(10000);\n    ecKeySet = await Promise.all(curves.map( async (crv) => await jscu.pkc.generateKey('EC', {namedCurve: crv})));\n    rsaKeySet = await Promise.all([2048, 4096].map( async (nLen) => await jscu.pkc.generateKey('RSA', {modulusLength: nLen})));\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n\n\n  it('ECDSA Signing and verification should be done successfully', async () => {\n    for (let i = 0; i < curves.length; i++){\n      for (let j = 0; j < hashes.length; j++){\n        const sig = await jscu.pkc.sign(msg, ecKeySet[i].privateKey, hashes[j]);\n        const result = await jscu.pkc.verify(msg, sig, ecKeySet[i].publicKey, hashes[j]);\n        expect(result).to.be.true;\n      }\n    }\n  });\n\n  it('RSA-PSS Signing and verification should be done successfully', async () => {\n    const array = await Promise.all(\n      rsaKeySet.map( async (kp) => {\n        let result = true;\n        for(let i = 0; i < hashes.length; i++) {\n          const sig = await jscu.pkc.sign(msg, kp.privateKey, hashes[i], {name: 'RSA-PSS', saltLength: 32});\n          const valid = await jscu.pkc.verify(msg, sig, kp.publicKey, hashes[i], {name: 'RSA-PSS', saltLength: 32});\n          result = valid && result;\n        }\n        return result;\n      }));\n      expect(array.every( (r) => r)).to.be.true;\n  });\n\n  it('RSASSA-PKCS1-v1_5 Signing and verification should be done successfully', async () => {\n    const array = await Promise.all(\n      rsaKeySet.map( async (kp) => {\n        let result = true;\n        for(let i = 0; i < hashes.length; i++) {\n          const sig = await jscu.pkc.sign(msg, kp.privateKey, hashes[i], {name: 'RSASSA-PKCS1-v1_5'});\n          const valid = await jscu.pkc.verify(msg, sig, kp.publicKey, hashes[i], {name: 'RSASSA-PKCS1-v1_5'});\n          result = valid && result;\n        }\n        return result;\n      }));\n    expect(array.every( (r) => r)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.sign.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 347,
    "kind": "test",
    "name": "describe70",
    "testId": 70,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe70",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 348,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe70.it71",
    "access": null,
    "description": "ECDSA Signing and verification should be done successfully",
    "lineNumber": 22
  },
  {
    "__docId__": 349,
    "kind": "test",
    "name": "it72",
    "testId": 72,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe70.it72",
    "access": null,
    "description": "RSA-PSS Signing and verification should be done successfully",
    "lineNumber": 32
  },
  {
    "__docId__": 350,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe70.it73",
    "access": null,
    "description": "RSASSA-PKCS1-v1_5 Signing and verification should be done successfully",
    "lineNumber": 46
  },
  {
    "__docId__": 351,
    "kind": "testFile",
    "name": "packages/js-x509-utils/test/x509.ec.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst x509 = env.library;\nconst envName = env.envName;\n\nimport ec from 'js-crypto-ec';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\nconst sigopt = ['ecdsa-with-sha256', 'ecdsa-with-sha384', 'ecdsa-with-sha512', 'ecdsa-with-sha1'];\nconst crtsample = '-----BEGIN CERTIFICATE-----\\n' +\n  'MIIBxjCCAWwCCQCEZlhfc33wtzAKBggqhkjOPQQDAjBrMQswCQYDVQQGEwJKUDEO\\n' +\n  'MAwGA1UECAwFVG9reW8xEDAOBgNVBAcMB0NoaXlvZGExFjAUBgNVBAoMDVNlbGYg\\n' +\n  'RW1wbG95ZWQxDDAKBgNVBAsMA1ImRDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcN\\n' +\n  'MTgwOTE4MTA0OTM0WhcNMjgwOTE1MTA0OTM0WjBrMQswCQYDVQQGEwJKUDEOMAwG\\n' +\n  'A1UECAwFVG9reW8xEDAOBgNVBAcMB0NoaXlvZGExFjAUBgNVBAoMDVNlbGYgRW1w\\n' +\n  'bG95ZWQxDDAKBgNVBAsMA1ImRDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wWTATBgcq\\n' +\n  'hkjOPQIBBggqhkjOPQMBBwNCAAScXEKv9GvV8EHzB+d9E0EgS3JFJxgz/uAQYwpZ\\n' +\n  'gI5+9KVuoGhkPk7Y3DuFbKQ20snMA5W7p5YhXxwo82pspWvDMAoGCCqGSM49BAMC\\n' +\n  'A0gAMEUCIQDG0lRQgVAYaXVkkIYQ8YC1A/NzvtlzlP2Kk07Ox6GCVwIgNS5BnBHj\\n' +\n  'UR3om5rYSWmj7rgz0uJxoaZkkNH4xM2Zfss=\\n' +\n  '-----END CERTIFICATE-----';\n\ndescribe(`${envName}: Generated JWK EC public key should be successfully converted to X509 PEM certificate and vice versa`, () => {\n  let keySet = [];\n  let msg;\n  before(async function () {\n    this.timeout(20000);\n    keySet = await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n    msg = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('Transform JWKs to X509 PEMs as self certs and verify generated ones', async function () {\n    this.timeout(20000);\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const array = await Promise.all(\n      keySet.map( async (kp) => {\n        let result = true;\n        await Promise.all(sigopt.map(async (so) => {\n          let re;\n          try {\n            const crt = await x509.fromJwk(\n              kp.publicKey,\n              kp.privateKey,\n              'pem',\n              {\n                signature: so,\n                days: 365,\n                issuer: name,\n                subject: name\n              }\n            );\n            const parsed = await x509.parse(crt, 'pem');\n            // console.log(parsed.signatureAlgorithm);\n            re = await ec.verify(parsed.tbsCertificate, parsed.signatureValue, kp.publicKey, parsed.signatureAlgorithm.parameters.hash, 'der');\n          } catch (e) { re = false; }\n          expect(re, `failed at ${so}`).to.be.true;\n          result = re && result;\n        }));\n        return result;\n      })\n    );\n    console.log(array);\n    expect(array.every( (x) => x)).to.be.true;\n  });\n\n  it('Transform X509 Self Signed PEM to JWK, and verify it', async function () {\n    this.timeout(20000);\n    const jwkey = await x509.toJwk(crtsample, 'pem');\n\n    const parsed = x509.parse(crtsample, 'pem');\n    const re = await ec.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.signatureAlgorithm.parameters.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/test/x509.ec.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 352,
    "kind": "test",
    "name": "describe74",
    "testId": 74,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe74",
    "access": null,
    "lineNumber": 27
  },
  {
    "__docId__": 353,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js~describe74",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe74.it75",
    "access": null,
    "description": "Transform JWKs to X509 PEMs as self certs and verify generated ones",
    "lineNumber": 37
  },
  {
    "__docId__": 354,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js~describe74",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe74.it76",
    "access": null,
    "description": "Transform X509 Self Signed PEM to JWK, and verify it",
    "lineNumber": 79
  },
  {
    "__docId__": 355,
    "kind": "testFile",
    "name": "packages/js-x509-utils/test/x509.rsa.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst x509 = env.library;\nconst envName = env.envName;\n\nimport sample from './sample_crt.js';\n\nimport rsa from 'js-crypto-rsa';\nimport {Key} from 'js-crypto-key-utils';\nimport chai from 'chai';\nimport sample_crt from './sample_crt';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512'];//, 'SHA-1'];\nconst pkcs1s = [ 'sha256WithRSAEncryption', 'sha384WithRSAEncryption', 'sha512WithRSAEncryption']; // RSASSA-PKCS1-v1_5\nconst constantSaltLen = 32;\n\ndescribe(`${envName}: RSA: Generated JWK public key should be successfully converted to X509 PEM certificate and vice versa`, () => {\n  before(async () => {\n  });\n\n  it('Transform JWKs to X509 RSASSA-PKCS1-v1_5 PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const results = await Promise.all(pkcs1s.map( async (signatureAlgorithm) => {\n      const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n      const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n      const crt = await x509.fromJwk(\n        await publicObj.export('jwk'),\n        await privateObj.export('jwk'),\n        'pem',\n        {\n          signature: signatureAlgorithm,\n          days: 365,\n          issuer: name,\n          subject: name\n        }\n      );\n      const parsed = await x509.parse(crt, 'pem');\n      // console.log(parsed.signatureAlgorithm);\n      const re = await rsa.verify(\n        parsed.tbsCertificate,\n        parsed.signatureValue,\n        await publicObj.export('jwk'),\n        parsed.signatureAlgorithm.parameters.hash,\n        {name: 'RSASSA-PKCS1-v1_5'}\n      );\n      return re;\n    }));\n    console.log(results);\n    expect(results.every( (elem) => elem === true)).to.be.true;\n  });\n\n  it('Transform JWKs to X509 RSA-PSS Empty Parameter PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n    const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n\n    const crt = await x509.fromJwk(\n      await publicObj.export('jwk'),\n      await privateObj.export('jwk'),\n      'pem',\n      {\n        signature: 'rsassaPss',\n        days: 365,\n        issuer: name,\n        subject: name\n      }\n    );\n    const parsed = await x509.parse(crt, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      await publicObj.export('jwk'),\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform JWKs to X509 RSA-PSS Explicit Parameter PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n    const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n\n    const results = await Promise.all(hashes.map( async (hash) => {\n      const crt = await x509.fromJwk(\n        await publicObj.export('jwk'),\n        await privateObj.export('jwk'),\n        'pem',\n        {\n          signature: 'rsassaPss',\n          saltLength: constantSaltLen,\n          hash,\n          days: 365,\n          issuer: name,\n          subject: name\n        }\n      );\n      const parsed = await x509.parse(crt, 'pem');\n      // console.log(parsed.signatureAlgorithm);\n      const re = await rsa.verify(\n        parsed.tbsCertificate,\n        parsed.signatureValue,\n        await publicObj.export('jwk'),\n        parsed.signatureAlgorithm.parameters.hash,\n        {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n      );\n      return re;\n    }));\n    console.log(results);\n    expect(results.every( (elem) => elem === true)).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSASSA-PKCS1-v1_5 PEM to JWK, and verify it', async () => {\n    const jwkey = await x509.toJwk(sample.rsa.certificatePKCS1v1_5, 'pem');\n    const parsed = x509.parse(sample.rsa.certificatePKCS1v1_5, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSASSA-PKCS1-v1_5'}\n    );\n    // = await rsa.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSA-PSS Explicit Parameter PEM to JWK, and verify it', async () => {\n    const samplePss = '-----BEGIN CERTIFICATE-----\\n' +\n      'MIIFazCCBCKgAwIBAgIJAKmJV6cI/tYpMD4GCSqGSIb3DQEBCjAxoAswCQYFKw4D\\n' +\n      'AhoFAKEYMBYGCSqGSIb3DQEBCDAJBgUrDgMCGgUAogMCARSjAwIBATCBszELMAkG\\n' +\n      'A1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjESMBAGA1UEBxMJRnJhbmtmdXJ0MR4w\\n' +\n      'HAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0ZXMxOTA3BgNVBAsTMGNyZWF0ZWQg\\n' +\n      'YnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3dy5rYWlzZXIuY3gvKTEkMCIGA1UE\\n' +\n      'AxMbUFNTIHRlc3RSb290IENBIENlcnRpZmljYXRlMB4XDTEwMDcxMzE5NTc1NVoX\\n' +\n      'DTE2MDEwMzE5NTc1NVowgbMxCzAJBgNVBAYTAkRFMQ8wDQYDVQQIEwZIZXNzZW4x\\n' +\n      'EjAQBgNVBAcTCUZyYW5rZnVydDEeMBwGA1UEChMVUFNTIHRlc3QgY2VydGlmaWNh\\n' +\n      'dGVzMTkwNwYDVQQLEzBjcmVhdGVkIGJ5IE1hcnRpbiBLYWlzZXIgKGh0dHA6Ly93\\n' +\n      'd3cua2Fpc2VyLmN4LykxJDAiBgNVBAMTG1BTUyB0ZXN0Um9vdCBDQSBDZXJ0aWZp\\n' +\n      'Y2F0ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMZnLiVdh/4aR2Gj\\n' +\n      'FKBiDmuNe8o6NJSgNRMXv+zweb1CQRUQ4HzdiZDRBTxAGM+83/ofeD3ALUyDGniX\\n' +\n      'fbjxv05QyPGnJDjJYpdQ3ilM4MXoEYz7ZfB4/AVh1zvqELFR3a2TZ78oQGYJBeF3\\n' +\n      'vAmVuDwCrZ8J7xddABt7ceqDtzhhNcvOWDZxXtzK5yDtb4N/RMJZtbK6ZNsLV/+J\\n' +\n      'OMHT+22xycE6tE2gMCqUUC2b2MpnW71GqtkKxaA36VXl/c4Z0IhNE2Zx3qy5NVsU\\n' +\n      'Z+NYw6JrWtEw+kf2j0bKj5w0LMlERKbNib4kofcMJ8qPEIvk1u6T30vKUb7HQdU7\\n' +\n      '2OuTWQ8CAwEAAaOCARwwggEYMB0GA1UdDgQWBBTfH+IBoj70+Wn4OseW1pkNL7bO\\n' +\n      'MzCB6AYDVR0jBIHgMIHdgBTfH+IBoj70+Wn4OseW1pkNL7bOM6GBuaSBtjCBszEL\\n' +\n      'MAkGA1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjESMBAGA1UEBxMJRnJhbmtmdXJ0\\n' +\n      'MR4wHAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0ZXMxOTA3BgNVBAsTMGNyZWF0\\n' +\n      'ZWQgYnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3dy5rYWlzZXIuY3gvKTEkMCIG\\n' +\n      'A1UEAxMbUFNTIHRlc3RSb290IENBIENlcnRpZmljYXRlggkAqYlXpwj+1ikwDAYD\\n' +\n      'VR0TBAUwAwEB/zA+BgkqhkiG9w0BAQowMaALMAkGBSsOAwIaBQChGDAWBgkqhkiG\\n' +\n      '9w0BAQgwCQYFKw4DAhoFAKIDAgEUowMCAQEDggEBAJ8GcFT/Jdhz65JK0c9EFdAq\\n' +\n      '8FKa9VWX7QDQlIuu0UbZaHYaFmY1NbXcxlvTOD1ArByCHpFQ8+wrXgLrxedlm/fI\\n' +\n      '9WkvFsyvC1kSeV88C90E3mh+w9i2Qsz0Gjj2RjD98cPsqqQO7q/7uvKNcHMN5nKi\\n' +\n      'VuIPMr5fisx0C/IBQAunBfzBfdGmjoNaahDBYCKiyAaU7A+dYorRbMJF7SxBhTr1\\n' +\n      'WI/N3LlBKLF5mvtDYg7sXx6ULR/xAKKkVeUTIgGMYq/s46ZMP11QrfRHx4zNAwP9\\n' +\n      'aARZeUz1X0/LM6LgaQvVIhZqbyB637eZhusOP3226TDn7hGx/UdS0UxSwfjrzS8=\\n' +\n      '-----END CERTIFICATE-----';\n    const jwkey = await x509.toJwk(samplePss, 'pem');\n    console.log(jwkey);\n    const parsed = x509.parse(samplePss, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    // = await rsa.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSA-PSS Empty Parameter PEM to JWK, and verify it', async () => {\n    const samplePss = '-----BEGIN CERTIFICATE-----\\n' +\n      'MIIFCTCCA/GgAwIBAgIJALCOVlO1QTu1MA0GCSqGSIb3DQEBCjAAMIGzMQswCQYD\\n' +\n      'VQQGEwJERTEPMA0GA1UECBMGSGVzc2VuMRIwEAYDVQQHEwlGcmFua2Z1cnQxHjAc\\n' +\n      'BgNVBAoTFVBTUyB0ZXN0IGNlcnRpZmljYXRlczE5MDcGA1UECxMwY3JlYXRlZCBi\\n' +\n      'eSBNYXJ0aW4gS2Fpc2VyIChodHRwOi8vd3d3LmthaXNlci5jeC8pMSQwIgYDVQQD\\n' +\n      'ExtQU1MgdGVzdFJvb3QgQ0EgQ2VydGlmaWNhdGUwHhcNMTAwNzEzMTk1NjAzWhcN\\n' +\n      'MTYwMTAzMTk1NjAzWjCBszELMAkGA1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjES\\n' +\n      'MBAGA1UEBxMJRnJhbmtmdXJ0MR4wHAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0\\n' +\n      'ZXMxOTA3BgNVBAsTMGNyZWF0ZWQgYnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3\\n' +\n      'dy5rYWlzZXIuY3gvKTEkMCIGA1UEAxMbUFNTIHRlc3RSb290IENBIENlcnRpZmlj\\n' +\n      'YXRlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2haEKyn8mtVODAPA\\n' +\n      'EMV9VlNm+HPBh+Mve5nPoU4PZ198E2JQ1llvXbDWmhuKzn/ZyB2janx/imvylkOq\\n' +\n      'Jmkdqka+VC+69/pDmhHKp2qHL6S/alPG6E2kQhy4FVIEU2Qme6niMZY4005237Pi\\n' +\n      'fWc1MBEU2c6jdkUIbw5SrWub5dbMIi71lUPHzaLqGovkLaWg2+BnPOSdg13t3jLt\\n' +\n      'N6Dm9VMpDE0sOu/t582bc2MfCmO/vIsSpu2/iA+gB4vecDBJGyOISYKKvjnc4N2s\\n' +\n      'Obok9ZgJKeTM40hGXEGzE+cTEDkkh8ydlGVRIJe3o5wjuLH3P51/EFVu0PhCSyV6\\n' +\n      'FGIO1wIDAQABo4IBHDCCARgwHQYDVR0OBBYEFM4ICyE/5cAobWjQ7LPGLrAU/gbD\\n' +\n      'MIHoBgNVHSMEgeAwgd2AFM4ICyE/5cAobWjQ7LPGLrAU/gbDoYG5pIG2MIGzMQsw\\n' +\n      'CQYDVQQGEwJERTEPMA0GA1UECBMGSGVzc2VuMRIwEAYDVQQHEwlGcmFua2Z1cnQx\\n' +\n      'HjAcBgNVBAoTFVBTUyB0ZXN0IGNlcnRpZmljYXRlczE5MDcGA1UECxMwY3JlYXRl\\n' +\n      'ZCBieSBNYXJ0aW4gS2Fpc2VyIChodHRwOi8vd3d3LmthaXNlci5jeC8pMSQwIgYD\\n' +\n      'VQQDExtQU1MgdGVzdFJvb3QgQ0EgQ2VydGlmaWNhdGWCCQCwjlZTtUE7tTAMBgNV\\n' +\n      'HRMEBTADAQH/MA0GCSqGSIb3DQEBCjAAA4IBAQCBgFRdPf+k9up9PwwbHORNe8HP\\n' +\n      'c7+yXPDK/qH74bJMQvaNOpXhvb0KWDcj5GPJ0l+eVatV1UzyDZT6exqaBTeWjgKW\\n' +\n      '1HMfF9z3Ybs1PTKt8IASFNMe4Nizx6vuAvnP/GXTz7LwOZt7QYBTaAOKUQqB/yBQ\\n' +\n      'D9Vn+P+nqgQCBfFhVXPurUFpAt6npnKpKIG8wmMBoeeuWpzMFs0Rnf9TFJt9SkAn\\n' +\n      'M8J806yQWShmibcQWmmveHtN8s/69FUUIu6q1h0A8qxISj87CdC4XKvLRV6DSu4C\\n' +\n      '+b/CfhHaOR8lINDcVYg4j3VZU24nmPlWcH4yXO8gbnoMOLnf36/Ezw3wnVIV\\n' +\n      '-----END CERTIFICATE-----';\n    const jwkey = await x509.toJwk(samplePss, 'pem');\n    const parsed = x509.parse(samplePss, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/test/x509.rsa.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 356,
    "kind": "test",
    "name": "describe77",
    "testId": 77,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "access": null,
    "lineNumber": 19
  },
  {
    "__docId__": 357,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it78",
    "access": null,
    "description": "Transform JWKs to X509 RSASSA-PKCS1-v1_5 PEM as self signed cert and verify generated one",
    "lineNumber": 23
  },
  {
    "__docId__": 358,
    "kind": "test",
    "name": "it79",
    "testId": 79,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it79",
    "access": null,
    "description": "Transform JWKs to X509 RSA-PSS Empty Parameter PEM as self signed cert and verify generated one",
    "lineNumber": 62
  },
  {
    "__docId__": 359,
    "kind": "test",
    "name": "it80",
    "testId": 80,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it80",
    "access": null,
    "description": "Transform JWKs to X509 RSA-PSS Explicit Parameter PEM as self signed cert and verify generated one",
    "lineNumber": 98
  },
  {
    "__docId__": 360,
    "kind": "test",
    "name": "it81",
    "testId": 81,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it81",
    "access": null,
    "description": "Transform X509 Self Signed RSASSA-PKCS1-v1_5 PEM to JWK, and verify it",
    "lineNumber": 140
  },
  {
    "__docId__": 361,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it82",
    "access": null,
    "description": "Transform X509 Self Signed RSA-PSS Explicit Parameter PEM to JWK, and verify it",
    "lineNumber": 155
  },
  {
    "__docId__": 362,
    "kind": "test",
    "name": "it83",
    "testId": 83,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe77.it83",
    "access": null,
    "description": "Transform X509 Self Signed RSA-PSS Empty Parameter PEM to JWK, and verify it",
    "lineNumber": 202
  }
]