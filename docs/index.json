[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/aes.js",
    "content": "/**\n * aes.js\n */\n\nimport * as util from 'js-crypto-env';\nimport * as nodeapi from './nodeapi.js';\nimport * as webapi from './webapi.js';\nimport params from './params.js';\n\n/**\n * Check if the given algorithm spec is valid.\n * @param {String} name - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} iv - IV byte array if required\n * @param {Number} tagLength - Authentication tag length if required\n * @throws {Error} - Throws if UnsupportedAlgorithm, InvalidArguments, InvalidIVLength, or InvalidTagLength.\n */\nfunction assertAlgorithms({name, iv, tagLength}){\n  if(Object.keys(params.ciphers).indexOf(name) < 0) throw new Error('UnsupportedAlgorithm');\n  if(params.ciphers[name].ivLength){\n    if(!(iv instanceof Uint8Array)) throw new Error('InvalidArguments');\n    if(iv.byteLength < 2 || iv.byteLength > 16) throw new Error('InvalidIVLength');\n    if(params.ciphers[name].staticIvLength && (params.ciphers[name].ivLength !== iv.byteLength)) throw new Error('InvalidIVLength');\n  }\n  if(params.ciphers[name].tagLength && tagLength){\n    if(!Number.isInteger(tagLength)) throw new Error('InvalidArguments');\n    if(tagLength < 4 || tagLength > 16) throw new Error('InvalidTagLength');\n  }\n}\n\n/**\n * Encrypt data with AES\n * @param {Uint8Array} msg - Message to be encrypted.\n * @param {Uint8Array} key - The symmetric key used to encrypt the message.\n * @param {String} [name = 'AES-GCM'] - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of the initial vector if required.\n * @param {Uint8Array} [additionalData = new Uint8Array([])] - Byte array of additional data if required.\n * @param {Number} [tagLength = params.ciphers[name].tagLength] - Authentication tag length if required.\n * @return {Promise<Uint8Array>} - Encrypted message.\n * @throws {Error} - Throws if InvalidArguments, FaildToEncryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto).\n */\nexport async function encrypt(msg, key, {name = 'AES-GCM', iv, additionalData=new Uint8Array([]), tagLength}){\n  // assertion and sanitizing\n  if(!(msg instanceof Uint8Array) || !(key instanceof Uint8Array)) throw new Error('InvalidArguments');\n  assertAlgorithms({name, iv, tagLength});\n  if(params.ciphers[name].tagLength && !tagLength) tagLength = params.ciphers[name].tagLength;\n\n  const webCrypto = await util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = await util.getNodeCrypto(); // node crypto\n\n  let data;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') {// for web API including IE...\n    data = await webapi.encrypt(msg, key, {name, iv, additionalData, tagLength}, webCrypto)\n      .catch((e) => {\n        throw new Error(`FailedToEncryptWeb: ${e.message}`);\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try{\n      data = nodeapi.encrypt(msg, key, {name, iv, additionalData, tagLength}, nodeCrypto);\n    } catch(e) {\n      throw new Error(`FailedToEncryptNode: ${e.message}`);\n    }\n  } else {\n    throw new Error('UnsupportedEnvironment'); // TODO:fallback to native implementation\n  }\n\n  return data;\n}\n\n\n/**\n * Decrypt data with AES\n * @param {Uint8Array} data - Byte array of encrypted data.\n * @param {Uint8Array} key - Byte array of symmetric key to be used for decryption.\n * @param {String} [name = 'AES-GCM'] - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of the initial vector if required.\n * @param {Uint8Array} [additionalData = new Uint8Array([])] - Byte array of additional data if required.\n * @param {Number} [tagLength = params.ciphers[name].tagLength] - Authentication tag length if required.\n * @return {Promise<Uint8Array>} - Decrypted plaintext message.\n * @throws {Error} - Throws if InvalidArguments, FaildToDecryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto).\n */\nexport async function decrypt(data, key, {name='AES-GCM', iv, additionalData=new Uint8Array([]), tagLength}){\n  // assertion and sanitizing\n  if(!(data instanceof Uint8Array) || !(key instanceof Uint8Array)) throw new Error('InvalidArguments');\n  assertAlgorithms({name, iv, tagLength});\n  if(params.ciphers[name].tagLength && !tagLength) tagLength = params.ciphers[name].tagLength;\n\n  const webCrypto = await util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = await util.getNodeCrypto(); // node crypto\n\n  let msg;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') {\n    msg = await webapi.decrypt(data, key, {name, iv, additionalData, tagLength}, webCrypto).catch((e) => {\n      throw new Error(`FailedToDecryptWeb: ${e.message}`);\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined'){\n    try{\n      msg = nodeapi.decrypt(data, key, {name, iv, additionalData, tagLength}, nodeCrypto);\n    } catch(e) {\n      throw new Error(`FailedToDecryptNode: ${e.message}`);\n    }\n  } else throw new Error('UnsupportedEnvironment');\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/aes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "function",
    "name": "assertAlgorithms",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~assertAlgorithms",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": null,
    "description": "Check if the given algorithm spec is valid.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the specified algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "iv",
        "description": "IV byte array if required"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "tagLength",
        "description": "Authentication tag length if required"
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedAlgorithm, InvalidArguments, InvalidIVLength, or InvalidTagLength."
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": "{encrypt}",
    "description": "Encrypt data with AES",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "The symmetric key used to encrypt the message."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 'AES-GCM'",
        "defaultRaw": " 'AES-GCM'",
        "name": "name",
        "description": "Name of the specified algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of the initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " new Uint8Array([])",
        "defaultRaw": " new Uint8Array([])",
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " params.ciphers[name].tagLength",
        "defaultRaw": " params.ciphers[name].tagLength",
        "name": "tagLength",
        "description": "Authentication tag length if required."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Encrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidArguments, FaildToEncryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto)."
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/aes.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/aes.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/aes.js",
    "importStyle": "{decrypt}",
    "description": "Decrypt data with AES",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Byte array of encrypted data."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Byte array of symmetric key to be used for decryption."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 'AES-GCM'",
        "defaultRaw": " 'AES-GCM'",
        "name": "name",
        "description": "Name of the specified algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of the initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " new Uint8Array([])",
        "defaultRaw": " new Uint8Array([])",
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " params.ciphers[name].tagLength",
        "defaultRaw": " params.ciphers[name].tagLength",
        "name": "tagLength",
        "description": "Authentication tag length if required."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted plaintext message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidArguments, FaildToDecryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto)."
      }
    ]
  },
  {
    "__docId__": 4,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {encrypt, decrypt} from './aes.js';\n\nexport default {encrypt, decrypt};\nexport {encrypt, decrypt};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 5,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\n\n/**\n * Encrypt plaintext message via AES Node.js crypto API\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @return {Uint8Array} - Encrypted message byte array.\n * @throws {Error} - Throws error if UnsupportedCipher.\n */\nexport function encrypt(msg, key, {name, iv, additionalData, tagLength}, nodeCrypto){\n  let alg = params.ciphers[name].nodePrefix;\n  alg = `${alg}-${(key.byteLength*8).toString()}-`;\n  alg = alg + params.ciphers[name].nodeSuffix;\n\n  let cipher;\n  switch(name){\n  case 'AES-GCM': {\n    cipher = nodeCrypto.createCipheriv(alg, key, iv, {authTagLength: tagLength});\n    cipher.setAAD(additionalData);\n    break;\n  }\n  case 'AES-CBC': {\n    cipher = nodeCrypto.createCipheriv(alg, key, iv);\n    break;\n  }}\n\n  const body = new Uint8Array(cipher.update(msg));\n  const final = new Uint8Array(cipher.final());\n\n  let tag = new Uint8Array([]);\n  if(name === 'AES-GCM') tag = new Uint8Array(cipher.getAuthTag());\n\n  const data = new Uint8Array(body.length + final.length + tag.length);\n  data.set(body);\n  data.set(final, body.length);\n  data.set(tag, body.length + final.length);\n\n  return data;\n}\n\n\n/**\n * Decrypt data through AES Node.js crypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @return {Uint8Array} - Decrypted message byte array.\n * @throws {Error} - Throws error if UnsupportedCipher or DecryptionFailure.\n */\nexport function decrypt(data, key, {name, iv, additionalData, tagLength}, nodeCrypto) {\n  let alg = params.ciphers[name].nodePrefix;\n  alg = `${alg}-${(key.byteLength*8).toString()}-`;\n  alg = alg + params.ciphers[name].nodeSuffix;\n\n  let decipher;\n  let body;\n  switch(name){\n  case 'AES-GCM': {\n    decipher = nodeCrypto.createDecipheriv(alg, key, iv, {authTagLength: tagLength});\n    decipher.setAAD(additionalData);\n    body = data.slice(0, data.length - tagLength);\n    const tag = data.slice(data.length - tagLength);\n    decipher.setAuthTag(tag);\n    break;\n  }\n  case 'AES-CBC': {\n    decipher = nodeCrypto.createDecipheriv(alg, key, iv);\n    body = data;\n    break;\n  }\n  default: throw new Error('UnsupportedCipher');\n  }\n\n  const decryptedBody = decipher.update(body);\n  let final;\n  try{\n    final = decipher.final();\n  } catch (e) {\n    throw new Error('DecryptionFailure');\n  }\n  const msg = new Uint8Array(final.length + decryptedBody.length);\n  msg.set(decryptedBody);\n  msg.set(final, decryptedBody.length);\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 6,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/nodeapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/nodeapi.js",
    "importStyle": "{encrypt}",
    "description": "Encrypt plaintext message via AES Node.js crypto API",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Plaintext message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Byte array of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of AES algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "tagLength",
        "description": "Authentication tag length if required."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object, i.e., require(crypto) in Node.js."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Encrypted message byte array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws error if UnsupportedCipher."
      }
    ]
  },
  {
    "__docId__": 7,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/nodeapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/nodeapi.js",
    "importStyle": "{decrypt}",
    "description": "Decrypt data through AES Node.js crypto API.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Encrypted message to be decrypted."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Byte array of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of AES algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "tagLength",
        "description": "Authentication tag length if required."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object, i.e., require(crypto) in Node.js."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Decrypted message byte array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws error if UnsupportedCipher or DecryptionFailure."
      }
    ]
  },
  {
    "__docId__": 8,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  ciphers: {\n    'AES-GCM': {\n      nodePrefix: 'aes',\n      nodeSuffix: 'gcm',\n      ivLength: 12,  // default value of iv length, 12 bytes is recommended for AES-GCM\n      tagLength: 16,\n      staticIvLength: true // if true, IV length must be always ivLength.\n    },\n    'AES-CBC': {\n      nodePrefix: 'aes',\n      nodeSuffix: 'cbc',\n      ivLength: 16,\n      staticIvLength: true\n    }\n  }\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "packages/js-crypto-aes/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\n/**\n * Encrypt data through AES of WebCrypto API.\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} webCrypto - WebCrypto object, i.e., window.crypto.subtle or window.msCrypto.subtle\n * @return {Promise<Uint8Array>} - Encrypted data byte array.\n * @throws {Error} - Throws if UnsupportedCipher.\n */\nexport async function encrypt(msg, key, {name = 'AES-GCM', iv, additionalData, tagLength}, webCrypto) {\n  const encryptionConfig = setCipherParams({name, iv, additionalData, tagLength});\n\n  if (typeof window.msCrypto === 'undefined') {\n    // modern browsers\n    const sessionKeyObj = await webCrypto.importKey('raw', key, encryptionConfig, false, ['encrypt', 'decrypt']);\n    const data = await webCrypto.encrypt(encryptionConfig, sessionKeyObj, msg);\n    return new Uint8Array(data);\n  }\n  else {\n    const sessionKeyObj = await msImportKey('raw', key, encryptionConfig, false, ['encrypt', 'decrypt'], webCrypto);\n    const encryptedObj = await msEncrypt(encryptionConfig, sessionKeyObj, msg, webCrypto);\n\n    if (name === 'AES-GCM') {\n      const data = new Uint8Array(encryptedObj.ciphertext.byteLength + encryptedObj.tag.byteLength);\n      data.set(new Uint8Array(encryptedObj.ciphertext));\n      data.set(new Uint8Array(encryptedObj.tag), encryptedObj.ciphertext.byteLength);\n      return data;\n    } else return new Uint8Array(encryptedObj);\n  }\n}\n\n/**\n * Decrypt data through AES of WebCrypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} webCrypto - WebCrypto object, i.e., window.crypto.subtle or window.msCrypto.subtle\n * @return {Promise<Uint8Array>} - Decrypted plaintext message.\n * @throws {Error} - Throws if UnsupportedCipher or DecryptionFailure.\n */\nexport async function decrypt(data, key, {name, iv, additionalData, tagLength}, webCrypto) {\n  const decryptionConfig = setCipherParams({name, iv, additionalData, tagLength});\n\n  if (!window.msCrypto) {\n    // modern browsers\n    const sessionKeyObj = await webCrypto.importKey('raw', key, decryptionConfig, false, ['encrypt', 'decrypt']);\n    const msg = await webCrypto.decrypt(decryptionConfig, sessionKeyObj, data).catch((e) => {\n      throw new Error(`DecryptionFailure: ${e.message}`);\n    });\n    return new Uint8Array(msg);\n  }\n  else {\n    const sessionKeyObj = await msImportKey('raw', key, decryptionConfig, false, ['encrypt', 'decrypt'], webCrypto);\n    if (name === 'AES-GCM') {\n      const ciphertext = data.slice(0, data.length - tagLength);\n      const tag = data.slice(data.length - tagLength, data.length);\n      const msg = await msDecrypt(Object.assign(decryptionConfig, {tag}), sessionKeyObj, ciphertext, webCrypto).catch((e) => {\n        throw new Error(`DecryptionFailure: ${e.message}`);\n      });\n      return new Uint8Array(msg);\n    } else{\n      const msg = await msDecrypt(decryptionConfig, sessionKeyObj, data, webCrypto).catch((e) => {\n        throw new Error(`DecryptionFailure: ${e.message}`);\n      });\n      return new Uint8Array(msg);\n    }\n  }\n}\n\n/**\n * Set params for encryption algorithms.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n */\nconst setCipherParams = ({name, iv, additionalData, tagLength}) => {\n  const alg = {};\n\n  switch(name){\n  case 'AES-GCM': {\n    Object.assign(alg, {name, iv, tagLength: tagLength * 8});\n    Object.assign(alg, (additionalData.length > 0) ? {additionalData} : {});\n    break;\n  }\n  case 'AES-CBC': {\n    alg.name = name;\n    alg.iv = iv;\n    break;\n  }}\n\n  return alg;\n};\n\n// function definitions for IE\nconst msImportKey = (type, key, alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.importKey(type, key, alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyImportingFailed'); };\n});\nconst msEncrypt = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.encrypt(alg, key, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('EncryptionFailure'); };\n});\nconst msDecrypt = (alg, key, data, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.decrypt(alg, key, data);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('DecryptionFailure'); };\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": "{encrypt}",
    "description": "Encrypt data through AES of WebCrypto API.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Plaintext message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Byte array of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of AES algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "tagLength",
        "description": "Authentication tag length if required."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCrypto object, i.e., window.crypto.subtle or window.msCrypto.subtle"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Encrypted data byte array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedCipher."
      }
    ]
  },
  {
    "__docId__": 11,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": "{decrypt}",
    "description": "Decrypt data through AES of WebCrypto API.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Encrypted message to be decrypted."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Byte array of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of AES algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "tagLength",
        "description": "Authentication tag length if required."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCrypto object, i.e., window.crypto.subtle or window.msCrypto.subtle"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted plaintext message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedCipher or DecryptionFailure."
      }
    ]
  },
  {
    "__docId__": 12,
    "kind": "function",
    "name": "setCipherParams",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~setCipherParams",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": "Set params for encryption algorithms.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of AES algorithm like 'AES-GCM'."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Byte array of initial vector if required."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "additionalData",
        "description": "Byte array of additional data if required."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "tagLength",
        "description": "Authentication tag length if required."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 13,
    "kind": "function",
    "name": "msImportKey",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msImportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 14,
    "kind": "function",
    "name": "msEncrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msEncrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 15,
    "kind": "function",
    "name": "msDecrypt",
    "memberof": "packages/js-crypto-aes/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-aes/src/webapi.js~msDecrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-aes/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 16,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/asn1enc.js",
    "content": "/**\n * asn1enc.js\n */\n\nimport params from './params.js';\nimport asn from 'asn1.js';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\nconst BN = asn.bignum;\n\n/**\n * Decode ASN.1 encoded signature byte array.\n * @param {Uint8Array} asn1sig - Byte array of ASN.1 encoded signature.\n * @param {String} namedCurve - Name of curve like 'P-256'.\n * @return {Uint8Array} - Decoded raw signature.\n */\nexport function decodeAsn1Signature(asn1sig, namedCurve){\n  const asn1sigBuffer = Buffer.from(asn1sig); // This must be Buffer object to get decoded;\n  const decoded = ECDSASignature.decode(asn1sigBuffer, 'der');\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const r = new Uint8Array(decoded.r.toArray('be', len));\n  const s = new Uint8Array(decoded.s.toArray('be', len));\n  const signature = new Uint8Array(len*2);\n  signature.set(r);\n  signature.set(s, len);\n  return signature;\n}\n\n/**\n * Encode raw signature and obtain ASN.1-encoded signature.\n * @param {Uint8Array} signature - Byte array of raw signature.\n * @param {String} namedCurve - Name of curve like 'P-256'.\n * @return {Uint8Array} - Encoded ASN.1 signature.\n */\nexport function encodeAsn1Signature(signature, namedCurve){\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const r = signature.slice(0, len);\n  const s = signature.slice(len, signature.length);\n  const asn1sig = ECDSASignature.encode({\n    r: new BN(r), s: new BN(s)\n  }, 'der');\n  return new Uint8Array(asn1sig);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n// RFC5759 https://tools.ietf.org/html/rfc5759.html\nconst ECDSASignature = asn.define('ECDSASignature', function() {\n  this.seq().obj(\n    this.key('r').int(),\n    this.key('s').int()\n  );\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/asn1enc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 17,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 18,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 19,
    "kind": "function",
    "name": "decodeAsn1Signature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~decodeAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": "{decodeAsn1Signature}",
    "description": "Decode ASN.1 encoded signature byte array.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "asn1sig",
        "description": "Byte array of ASN.1 encoded signature."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Decoded raw signature."
    }
  },
  {
    "__docId__": 20,
    "kind": "function",
    "name": "encodeAsn1Signature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~encodeAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": "{encodeAsn1Signature}",
    "description": "Encode raw signature and obtain ASN.1-encoded signature.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of raw signature."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Encoded ASN.1 signature."
    }
  },
  {
    "__docId__": 21,
    "kind": "variable",
    "name": "ECDSASignature",
    "memberof": "packages/js-crypto-ec/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/asn1enc.js~ECDSASignature",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 22,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/ec.js",
    "content": "/**\n * ec.js\n */\n\nimport * as util from 'js-crypto-env';\nimport * as webapi from './webapi.js';\nimport * as nodeapi from './nodeapi.js';\nimport * as purejs from './purejs.js';\n\n/**\n * Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.\n * @param {String} [namedCurve='P-256'] - Name of curve like 'P-256'.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey }>} - The generated keys.\n * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.\n */\nexport async function generateKey(namedCurve='P-256'){\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let keyPair = {};\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.generateKey === 'function' && typeof webCrypto.exportKey === 'function') { // for web API\n    keyPair = await webapi.generateKey(namedCurve, webCrypto).catch((e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    keyPair = await nodeapi.generateKey(namedCurve, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    keyPair = await purejs.generateKey(namedCurve).catch( (e) => {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    });\n  }\n\n  return keyPair;\n}\n\n\n/**\n * Sign message with ECDSA.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key object in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} [signatureFormat='raw'] - Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the output is ASN.1 DER formatted.\n * @return {Promise<Uint8Array>} - Output signature byte array in raw or der format.\n * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.\n */\nexport async function sign(msg, privateJwk, hash = 'SHA-256', signatureFormat='raw') {\n  // assertion\n  if (signatureFormat !== 'raw' && signatureFormat !== 'der') throw new Error('InvalidSignatureFormat');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let signature;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') { // for web API\n    signature = await webapi.sign(msg, privateJwk, hash, signatureFormat, webCrypto).catch((e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    signature = await nodeapi.sign(msg, privateJwk, hash, signatureFormat, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    signature = await purejs.sign(msg, privateJwk, hash, signatureFormat).catch ((e) => {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    });\n  }\n  return signature;\n}\n\n\n/**\n * Verify signature with ECDSA.\n * @param {Uint8Array} msg - Byte array of message that have been signed.\n * @param {Uint8Array} signature - Byte array of signature for the given message.\n * @param {JsonWebKey} publicJwk - Public key object in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} [signatureFormat='raw'] - Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the input must be in ASN.1 DER format.\n * @return {Promise<boolean>} - The result of verification.\n * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.\n */\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', signatureFormat='raw') {\n  // assertion\n  if (signatureFormat !== 'raw' && signatureFormat !== 'der') throw new Error('InvalidSignatureFormat');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let valid;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.verify === 'function') { // for web API\n    valid = await webapi.verify(msg, signature, publicJwk, hash, signatureFormat, webCrypto).catch((e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    valid = await nodeapi.verify(msg, signature, publicJwk, hash, signatureFormat, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    valid = await purejs.verify(msg, signature, publicJwk, hash, signatureFormat).catch( (e) => {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    });\n  }\n\n  return valid;\n}\n\n/**\n * ECDH: Elliptic Curve Diffie-Hellman Key Exchange, which derives shared secret from my private key and destination's public key.\n * **NOTE** We SHOULD NOT use the derived secret as an encryption key directly.\n * We should employ an appropriate key derivation procedure like HKDF to use the secret for symmetric key encryption.\n * @param {JsonWebKey} publicJwk - Remote public key object in JWK format.\n * @param {JsonWebKey} privateJwk - Local (my) private key object in JWK format.\n * @return {Promise<Uint8Array>} - The derived master secret via ECDH.\n * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.\n */\nexport async function deriveSecret(publicJwk, privateJwk){\n  // assertion\n  if(publicJwk.crv !== privateJwk.crv) throw new Error('UnmatchedCurveName');\n\n  const webCrypto = util.getWebCrypto(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let native = true;\n  let errMsg;\n  let secret;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.deriveBits === 'function') { // for web API\n    secret = await webapi.deriveSecret(publicJwk, privateJwk, webCrypto)\n      .catch((e) => {\n        errMsg = e.message;\n        native = false;\n      });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    try { secret = nodeapi.deriveSecret(publicJwk, privateJwk, nodeCrypto); }\n    catch (e) {\n      errMsg = e.message;\n      native = false;\n    }\n  } else native = false;\n\n  if (native === false){ // fallback to native implementation\n    try{\n      secret = await purejs.deriveSecret(publicJwk, privateJwk);\n    } catch (e) {\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return secret;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 23,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{generateKey}",
    "description": "Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'P-256'",
        "defaultRaw": "'P-256'",
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey }>"
      ],
      "spread": false,
      "description": "The generated keys."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works."
      }
    ]
  },
  {
    "__docId__": 24,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{sign}",
    "description": "Sign message with ECDSA.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'raw'",
        "defaultRaw": "'raw'",
        "name": "signatureFormat",
        "description": "Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the output is ASN.1 DER formatted."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Output signature byte array in raw or der format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works."
      }
    ]
  },
  {
    "__docId__": 25,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{verify}",
    "description": "Verify signature with ECDSA.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message that have been signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of signature for the given message."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'raw'",
        "defaultRaw": "'raw'",
        "name": "signatureFormat",
        "description": "Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the input must be in ASN.1 DER format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "The result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works."
      }
    ]
  },
  {
    "__docId__": 26,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/ec.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/ec.js",
    "importStyle": "{deriveSecret}",
    "description": "ECDH: Elliptic Curve Diffie-Hellman Key Exchange, which derives shared secret from my private key and destination's public key.\n**NOTE** We SHOULD NOT use the derived secret as an encryption key directly.\nWe should employ an appropriate key derivation procedure like HKDF to use the secret for symmetric key encryption.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Remote public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Local (my) private key object in JWK format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "The derived master secret via ECDH."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works."
      }
    ]
  },
  {
    "__docId__": 27,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {generateKey, sign, verify, deriveSecret} from './ec.js';\n\nexport default {generateKey, sign, verify, deriveSecret};\nexport {generateKey, sign, verify, deriveSecret};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 28,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\nimport * as asn1enc from './asn1enc.js';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\n\n/**\n * Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.\n * @param {String} namedCurve - Name of curve like 'P-256'.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>} - The generated keys.\n * @throws {Error} - Throws if NotPublic/PrivateKeyForECCKeyGenNode\n */\nexport async function generateKey(namedCurve, nodeCrypto){\n  const ecdh = nodeCrypto.ECDH(params.namedCurves[namedCurve].nodeName);\n  ecdh.generateKeys();\n  const publicOct = new Uint8Array(ecdh.getPublicKey());\n  const privateOct = new Uint8Array(ecdh.getPrivateKey());\n\n  const publicKey = new Key('oct', publicOct, {namedCurve});\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCKeyGenNode');\n  const publicJwk = await publicKey.export('jwk', {outputPublic: true});\n  const privateKey = new Key('oct', privateOct, {namedCurve});\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCKeyGenNode');\n  const privateJwk = await privateKey.export('jwk');\n\n  return {publicKey: publicJwk, privateKey: privateJwk};\n}\n\n\n/**\n * Sign message with ECDSA.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format, 'raw' or 'der'\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<Uint8Array>} - Output signature byte array in raw or der format.\n * @throws {Error} - Throws if NotPrivateKeyForECCSignNode.\n */\nexport async function sign(msg, privateJwk, hash, signatureFormat, nodeCrypto){\n  const privateKey = new Key('jwk', privateJwk);\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCSignNode');\n  const privatePem = await privateKey.export('pem');\n\n  const sign = nodeCrypto.createSign(params.hashes[hash].nodeName);\n  sign.update(msg);\n  const asn1sig = sign.sign(privatePem);\n  return (signatureFormat === 'raw') ? asn1enc.decodeAsn1Signature(asn1sig, privateJwk.crv) : asn1sig;\n}\n\n/**\n * Verify signature with ECDSA.\n * @param {Uint8Array} msg - Byte array of message that have been signed.\n * @param {Uint8Array} signature - Byte array of signature for the given message.\n * @param {JsonWebKey} publicJwk - Public key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format,'raw' or 'der'.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<boolean>} - The result of verification.\n * @throws {Error} - Throws if NotPublicKeyForEccVerifyNode.\n */\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat, nodeCrypto){\n  const publicKey = new Key('jwk', publicJwk);\n  if (!publicKey.isPrivate) throw new Error('NotPrivateKeyForECCVerifyNode');\n  const publicPem = await publicKey.export('pem', {outputPublic: true, compact: false});\n\n  const verify = nodeCrypto.createVerify(params.hashes[hash].nodeName);\n  verify.update(msg);\n  const asn1sig = (signatureFormat === 'raw') ? asn1enc.encodeAsn1Signature(signature, publicJwk.crv) : signature;\n  return verify.verify(publicPem, asn1sig);\n}\n\n/**\n * Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.\n * @param {JsonWebKey} publicJwk - Remote public key object in JWK format.\n * @param {JsonWebKey} privateJwk - Local (my) private key object in JWK format.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Uint8Array} - The derived master secret via ECDH.\n */\nexport function deriveSecret(publicJwk, privateJwk, nodeCrypto){\n  const curve = params.namedCurves[privateJwk.crv].nodeName;\n  const payloadSize = params.namedCurves[privateJwk.crv].payloadSize;\n\n  const ecdh = nodeCrypto.createECDH(curve);\n\n  const privKeyBuf = jseu.encoder.decodeBase64Url(privateJwk.d);\n  const pubKeyBuf = new Uint8Array( payloadSize * 2 + 1 );\n  pubKeyBuf[0] = 0xFF & 0x04;\n  pubKeyBuf.set(jseu.encoder.decodeBase64Url(publicJwk.x), 1);\n  pubKeyBuf.set(jseu.encoder.decodeBase64Url(publicJwk.y), payloadSize + 1);\n  ecdh.setPrivateKey(privKeyBuf);\n  return new Uint8Array(ecdh.computeSecret(pubKeyBuf));\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 29,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{generateKey}",
    "description": "Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": "The generated keys."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublic/PrivateKeyForECCKeyGenNode"
      }
    ]
  },
  {
    "__docId__": 30,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{sign}",
    "description": "Sign message with ECDSA.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format, 'raw' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Output signature byte array in raw or der format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPrivateKeyForECCSignNode."
      }
    ]
  },
  {
    "__docId__": 31,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{verify}",
    "description": "Verify signature with ECDSA.",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message that have been signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of signature for the given message."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format,'raw' or 'der'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "The result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublicKeyForEccVerifyNode."
      }
    ]
  },
  {
    "__docId__": 32,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/nodeapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-ec/src/nodeapi.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/nodeapi.js",
    "importStyle": "{deriveSecret}",
    "description": "Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Remote public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Local (my) private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "The derived master secret via ECDH."
    }
  },
  {
    "__docId__": 33,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  namedCurves: {\n    'P-256': {indutnyName: 'p256', nodeName: 'prime256v1', payloadSize: 32},\n    'P-384': {indutnyName: 'p384', nodeName: 'secp384r1', payloadSize: 48},\n    'P-521': {indutnyName: 'p521', nodeName: 'secp521r1', payloadSize: 66},\n    'P-256K': {indutnyName: 'secp256k1', nodeName: 'secp256k1', payloadSize: 32},\n  },\n\n  hashes: {\n    'SHA-256': {nodeName: 'sha256'}, //, hashSize: 32},\n    'SHA-384': {nodeName: 'sha384'}, //, hashSize: 48},\n    'SHA-512': {nodeName: 'sha512'}, //, hashSize: 64}\n    'SHA-1': {nodeName: 'sha1'}, //, hashSize: 20},\n  },\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 34,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/purejs.js",
    "content": "/**\n * purejs.js\n */\n\nimport params from './params.js';\nimport * as asn1enc from './asn1enc.js';\nimport random from 'js-crypto-random';\nimport jschash from 'js-crypto-hash';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\nimport elliptic from 'elliptic';\nconst Ec = elliptic.ec;\n\n/**\n * Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.\n * @param {String} namedCurve - Name of curve like 'P-256'.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>} - The generated keys.\n * @throws {Error} - Throws if NotPublic/PrivateKeyForECCKeyGenPureJS\n */\nexport async function generateKey(namedCurve){\n\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n  const ecKey = ec.genKeyPair({\n    entropy: jseu.encoder.arrayBufferToString(await random.getRandomBytes(32))\n  });\n\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const publicOct = new Uint8Array(ecKey.getPublic('array'));\n  const privateOct = new Uint8Array(ecKey.getPrivate().toArray('be', len));\n\n  const publicKey = new Key('oct', publicOct, {namedCurve});\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCKeyGenPureJS');\n  const publicJwk = await publicKey.export('jwk', {outputPublic: true});\n\n  const privateKey = new Key('oct', privateOct, {namedCurve});\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCKeyGenPureJS');\n  const privateJwk = await privateKey.export('jwk');\n\n  return {publicKey: publicJwk, privateKey: privateJwk};\n}\n\n/**\n * Sign message with ECDSA.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format, 'raw' or 'der'\n * @return {Promise<Uint8Array>} - Output signature byte array in raw or der format.\n * @throws {Error} - Throws if NotPrivateKeyForECCSIgnPureJS\n */\nexport async function sign(msg, privateJwk, hash, signatureFormat) {\n  const namedCurve = privateJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const privateKey = new Key('jwk', privateJwk);\n  if (!privateKey.isPrivate) throw new Error('NotPrivateKeyForECCSignPureJS');\n  const privateOct = await privateKey.export('oct');\n\n  const ecKey = ec.keyFromPrivate(privateOct);\n\n  // get hash\n  const md = await jschash.compute(msg, hash);\n\n  // generate signature\n  const signature = ecKey.sign(md);\n\n  // formatting\n  const len = params.namedCurves[namedCurve].payloadSize;\n  const arrayR = new Uint8Array(signature.r.toArray('be', len));\n  const arrayS = new Uint8Array(signature.s.toArray('be', len));\n  const concat = new Uint8Array(arrayR.length + arrayS.length);\n  concat.set(arrayR);\n  concat.set(arrayS, arrayR.length);\n  return (signatureFormat === 'raw') ? concat : asn1enc.encodeAsn1Signature(concat, namedCurve);\n}\n\n/**\n * Verify signature with ECDSA.\n * @param {Uint8Array} msg - Byte array of message that have been signed.\n * @param {Uint8Array} signature - Byte array of signature for the given message.\n * @param {JsonWebKey} publicJwk - Public key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format,'raw' or 'der'.\n * @return {Promise<boolean>} - The result of verification.\n * @throws {Error} - Throws if NotPublicKeyForEccVerifyPureJS.\n */\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat){\n  const namedCurve = publicJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const publicKey = new Key('jwk', publicJwk);\n  if (publicKey.isPrivate) throw new Error('NotPublicKeyForECCVerifyPureJS');\n  const publicOct = await publicKey.export('oct', {compact: false, outputPublic: true});\n\n  const ecKey = ec.keyFromPublic(publicOct);\n\n  // parse signature\n  const len = params.namedCurves[namedCurve].payloadSize;\n  if(!(signature instanceof Uint8Array)) signature = new Uint8Array(signature);\n  signature = (signatureFormat === 'raw') ? signature : asn1enc.decodeAsn1Signature(signature, namedCurve);\n  const sigR = signature.slice(0, len);\n  const sigS = signature.slice(len, len+sigR.length);\n\n  // get hash\n  const md = await jschash.compute(msg, hash);\n\n  return await ecKey.verify(md, {s: sigS, r: sigR});\n}\n\n/**\n * Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.\n * @param {JsonWebKey} publicJwk - Remote public key object in JWK format.\n * @param {JsonWebKey} privateJwk - Local (my) private key object in JWK format.\n * @return {Promise<Uint8Array>} - The derived master secret via ECDH.\n * @throws {Error} - Throws if NotPublic/PrivateKeyForECCSDeriveKeyPureJS.\n */\nexport async function deriveSecret(publicJwk, privateJwk){\n  const namedCurve = privateJwk.crv;\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  const priKeyObj = new Key('jwk', privateJwk);\n  if (!priKeyObj.isPrivate) throw new Error('NotPrivateKeyForECCSDeriveKeyPureJS');\n  const privateOct = await priKeyObj.export('oct');\n\n  const pubKeyObj = new Key('jwk', publicJwk);\n  if (pubKeyObj.isPrivate) throw new Error('NotPublicKeyForECCDeriveKeyPureJS');\n  const publicOct = await pubKeyObj.export('oct', {compact: false, outputPublic: true});\n\n  const privateKey = ec.keyFromPrivate(privateOct);\n  const publicKey = ec.keyFromPublic(publicOct);\n\n  // derive shared key\n  const len = params.namedCurves[namedCurve].payloadSize;\n  return new Uint8Array(privateKey.derive(publicKey.getPublic()).toArray('be', len));\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/purejs.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "name": "Ec",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~Ec",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 36,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{generateKey}",
    "description": "Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": "The generated keys."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublic/PrivateKeyForECCKeyGenPureJS"
      }
    ]
  },
  {
    "__docId__": 37,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{sign}",
    "description": "Sign message with ECDSA.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format, 'raw' or 'der'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Output signature byte array in raw or der format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPrivateKeyForECCSIgnPureJS"
      }
    ]
  },
  {
    "__docId__": 38,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{verify}",
    "description": "Verify signature with ECDSA.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message that have been signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of signature for the given message."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format,'raw' or 'der'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "The result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublicKeyForEccVerifyPureJS."
      }
    ]
  },
  {
    "__docId__": 39,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/purejs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/purejs.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/purejs.js",
    "importStyle": "{deriveSecret}",
    "description": "Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Remote public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Local (my) private key object in JWK format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "The derived master secret via ECDH."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublic/PrivateKeyForECCSDeriveKeyPureJS."
      }
    ]
  },
  {
    "__docId__": 40,
    "kind": "file",
    "name": "packages/js-crypto-ec/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport * as asn1enc from './asn1enc.js';\n\n/**\n * Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.\n * @param {String} namedCurve - Name of curve like 'P-256'.\n * @param {Object} webCrypto - WebCryptoSubtle object.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>} - The generated keys.\n */\nexport async function generateKey(namedCurve, webCrypto){\n  // generate ecdsa key\n  // hash is used for signing and verification. never be used for key generation\n  const keys = await webCrypto.generateKey({ name: 'ECDSA', namedCurve, hash: {name: 'SHA-256'} }, true, ['sign', 'verify']);\n\n  // export keys in jwk format\n  const publicKey = await webCrypto.exportKey('jwk', keys.publicKey);\n  const privateKey = await webCrypto.exportKey('jwk', keys.privateKey);\n\n  // delete optional entries to export as general ecdsa/ecdh key\n  ['key_ops', 'alg', 'ext'].forEach((elem) => {\n    delete publicKey[elem];\n    delete privateKey[elem];\n  });\n\n  return {publicKey, privateKey};\n}\n\n/**\n * Sign message with ECDSA.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format, 'raw' or 'der'\n * @param {Object} webCrypto - WebCryptoSubtle object.\n * @return {Promise<Uint8Array>} - Output signature byte array in raw or der format.\n */\nexport async function sign(msg, privateJwk, hash, signatureFormat, webCrypto){\n  const algo = {name: 'ECDSA', namedCurve: privateJwk.crv, hash: {name: hash}};\n  const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['sign']);\n  const signature = await webCrypto.sign(algo, key, msg);\n  return (signatureFormat === 'raw')\n    ? new Uint8Array(signature)\n    : asn1enc.encodeAsn1Signature(new Uint8Array(signature), privateJwk.crv);\n}\n\n/**\n * Verify signature with ECDSA.\n * @param {Uint8Array} msg - Byte array of message that have been signed.\n * @param {Uint8Array} signature - Byte array of signature for the given message.\n * @param {JsonWebKey} publicJwk - Public key object in JWK format.\n * @param {String} hash - Name of hash algorithm used in singing, like 'SHA-256'.\n * @param {String} signatureFormat - Signature format,'raw' or 'der'.\n * @param {Object} webCrypto - WebCryptoSubtle object.\n * @return {Promise<boolean>} - The result of verification.\n */\nexport async function verify(msg, signature, publicJwk, hash, signatureFormat, webCrypto){\n  const algo = {name: 'ECDSA', namedCurve: publicJwk.crv, hash: {name: hash}};\n  const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['verify']);\n  const rawSignature = (signatureFormat === 'raw')\n    ? signature\n    : asn1enc.decodeAsn1Signature(signature, publicJwk.crv);\n  return await webCrypto.verify(algo, key, rawSignature, msg);\n}\n\n/**\n * Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.\n * @param {JsonWebKey} publicJwk - Remote public key object in JWK format.\n * @param {JsonWebKey} privateJwk - Local (my) private key object in JWK format.\n * @param {Object} webCrypto - WebCryptoSubtle object.\n * @return {Promise<Uint8Array>} - The derived master secret via ECDH.\n */\nexport async function deriveSecret(publicJwk, privateJwk, webCrypto){\n  const algo = {name: 'ECDH', namedCurve: privateJwk.crv};\n  const privateKey = await webCrypto.importKey('jwk', privateJwk, algo, false, ['deriveBits']);\n  const publicKey = await webCrypto.importKey('jwk', publicJwk, algo, false, []);\n  const bitLen = () => { const arr = jseu.encoder.decodeBase64Url(privateJwk.x); return 8*arr.length; };\n  return new Uint8Array(\n    await webCrypto.deriveBits(Object.assign(algo, {public: publicKey}), privateKey, bitLen())\n  );\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 41,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{generateKey}",
    "description": "Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": "The generated keys."
    }
  },
  {
    "__docId__": 42,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{sign}",
    "description": "Sign message with ECDSA.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format, 'raw' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Output signature byte array in raw or der format."
    }
  },
  {
    "__docId__": 43,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{verify}",
    "description": "Verify signature with ECDSA.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message that have been signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of signature for the given message."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used in singing, like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureFormat",
        "description": "Signature format,'raw' or 'der'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "The result of verification."
    }
  },
  {
    "__docId__": 44,
    "kind": "function",
    "name": "deriveSecret",
    "memberof": "packages/js-crypto-ec/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-ec/src/webapi.js~deriveSecret",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-ec/src/webapi.js",
    "importStyle": "{deriveSecret}",
    "description": "Key Derivation for ECDH, Elliptic Curve Diffie-Hellman Key Exchange.",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Remote public key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Local (my) private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "The derived master secret via ECDH."
    }
  },
  {
    "__docId__": 45,
    "kind": "file",
    "name": "packages/js-crypto-env/src/index.js",
    "content": "/**\n * index.js\n **/\nexport default {getNodeCrypto, getWebCrypto, getMsCrypto, getWebCryptoAll, getRootWebCryptoAll};\nexport {getNodeCrypto, getWebCrypto, getMsCrypto, getWebCryptoAll, getRootWebCryptoAll};\n/**\n * Obtain require(crypto) in Node.js environment.\n * @return {undefined|Object} - Node.js crypto object\n */\nfunction getNodeCrypto(){\n  if(typeof window !== 'undefined') return undefined;\n  else return require('crypto');\n}\n\n/**\n * Obtain window.crypto.subtle object in browser environments.\n * @return {undefined|Object} - WebCrypto API object\n */\nfunction getWebCrypto () {\n  if (typeof window === 'undefined') return undefined;\n  if (window.crypto) return window.crypto.subtle;\n}\n\n/**\n * Obtain window.crypto.subtle or window.msCrypto.subtle object in browser environments.\n * @return {undefined|Object} - WebCrypto API object\n */\nfunction getWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.msCrypto) return window.msCrypto.subtle;\n    if (window.crypto) return window.crypto.subtle;\n  }\n}\n\n/**\n * Obtain window.crypto or window.msCrypto object in browser environments.\n * @return {undefined|Object} - WebCrypto API object\n */\nfunction getRootWebCryptoAll () {\n  if (typeof window === 'undefined') return undefined;\n  else {\n    if (window.msCrypto) return window.msCrypto;\n    if (window.crypto) return window.crypto;\n  }\n}\n\n\n\n/**\n * Retrieve MsCryptoObject, i.e., window.msCrypto.subtle\n * @return {undefined|Object}\n */\nfunction getMsCrypto(){\n  if (typeof window === 'undefined') return undefined;\n  if (window.crypto) return undefined;\n  if (window.msCrypto) return window.msCrypto.subtle;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-env/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 46,
    "kind": "function",
    "name": "getNodeCrypto",
    "memberof": "packages/js-crypto-env/src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-env/src/index.js~getNodeCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-env/src/index.js",
    "importStyle": "{getNodeCrypto}",
    "description": "Obtain require(crypto) in Node.js environment.",
    "lineNumber": 10,
    "return": {
      "nullable": null,
      "types": [
        "undefined",
        "Object"
      ],
      "spread": false,
      "description": "Node.js crypto object"
    },
    "params": []
  },
  {
    "__docId__": 47,
    "kind": "function",
    "name": "getWebCrypto",
    "memberof": "packages/js-crypto-env/src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-env/src/index.js~getWebCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-env/src/index.js",
    "importStyle": "{getWebCrypto}",
    "description": "Obtain window.crypto.subtle object in browser environments.",
    "lineNumber": 19,
    "return": {
      "nullable": null,
      "types": [
        "undefined",
        "Object"
      ],
      "spread": false,
      "description": "WebCrypto API object"
    },
    "params": []
  },
  {
    "__docId__": 48,
    "kind": "function",
    "name": "getMsCrypto",
    "memberof": "packages/js-crypto-env/src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-env/src/index.js~getMsCrypto",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-env/src/index.js",
    "importStyle": "{getMsCrypto}",
    "description": "Retrieve MsCryptoObject, i.e., window.msCrypto.subtle",
    "lineNumber": 54,
    "return": {
      "nullable": null,
      "types": [
        "undefined",
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "getWebCryptoAll",
    "memberof": "packages/js-crypto-env/src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-env/src/index.js~getWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-env/src/index.js",
    "importStyle": "{getWebCryptoAll}",
    "description": "Obtain window.crypto.subtle or window.msCrypto.subtle object in browser environments.",
    "lineNumber": 28,
    "return": {
      "nullable": null,
      "types": [
        "undefined",
        "Object"
      ],
      "spread": false,
      "description": "WebCrypto API object"
    },
    "params": []
  },
  {
    "__docId__": 50,
    "kind": "function",
    "name": "getRootWebCryptoAll",
    "memberof": "packages/js-crypto-env/src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-env/src/index.js~getRootWebCryptoAll",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-env/src/index.js",
    "importStyle": "{getRootWebCryptoAll}",
    "description": "Obtain window.crypto or window.msCrypto object in browser environments.",
    "lineNumber": 40,
    "return": {
      "nullable": null,
      "types": [
        "undefined",
        "Object"
      ],
      "spread": false,
      "description": "WebCrypto API object"
    },
    "params": []
  },
  {
    "__docId__": 51,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/hash.js",
    "content": "/**\n * hash.js\n */\n\nimport * as util from 'js-crypto-env';\nimport params from './params.js';\nimport md5 from 'md5';\nimport jsHash from 'hash.js';\n\n/**\n * Compute Hash value.\n * @param {Uint8Array} msg - Byte array of message to be hashed.\n * @param {String} [hash = 'SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @return {Promise<Uint8Array>} - Hash value\n * @throws {Error} - Throws if UnsupportedHashAlgorithm, UnsupportedMessageType,\n *  or UnsupportedEnvironment, i.e., a case where even pure js implementation won't work.\n */\nexport async function compute(msg, hash = 'SHA-256') {\n  if(Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHashAlgorithm');\n  if(!(msg instanceof Uint8Array)) throw new Error('UnsupportedMessageType');\n\n  const webCrypto = util.getWebCrypto();\n  const nodeCrypto = util.getNodeCrypto();\n  const msCrypto = util.getMsCrypto();\n\n  let msgHash;\n  let errMsg;\n  let native = true;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.digest === 'function' && typeof msCrypto === 'undefined') {\n    msgHash = await webCrypto.digest(hash, msg).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    }); // for modern browsers\n  }\n  else if (typeof nodeCrypto !== 'undefined' ){ // for node\n    try {\n      msgHash = nodedigest(hash, msg, nodeCrypto);\n    } catch (e) {\n      errMsg = e.message;\n      native = false;\n    }\n  }\n  else if (typeof msCrypto !== 'undefined' && typeof msCrypto.digest === 'function') { // for legacy ie 11\n    msgHash = await msdigest(hash, msg, msCrypto).catch( (e) => {\n      errMsg = e.message;\n      native = false;\n    });\n  } else native = false;\n\n  if (!native){\n    try {\n      msgHash = purejs(hash, msg);\n    }\n    catch(e){\n      errMsg = `${errMsg} => ${e.message}`;\n      throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n    }\n  }\n\n  return new Uint8Array(msgHash);\n}\n\n/**\n * Compute hash using MsCrypto implementation\n * @param {String} hash - Name of hash algorithm like SHA-256\n * @param {Uint8Array} msg - Byte array of message to be hashed.\n * @param {Object} msCrypto - msCrypto object.\n * @return {Promise<Uint8Array>} - Hash value.\n * @throws {Error} - Throws if hashing failed.\n */\nconst msdigest = (hash, msg, msCrypto) => new Promise((resolve, reject) => {\n  const op = msCrypto.digest(hash, msg);\n  op.oncomplete = (evt) => {\n    resolve(evt.target.result);\n  };\n  op.onerror = (e) => {\n    reject(e);\n  };\n});\n\n/**\n * Compute hash using Node.js implementation\n * @param {String} hash - Name of hash algorithm like SHA-256\n * @param {Uint8Array} msg - Byte array of message to be hashed.\n * @param {Object} nodeCrypto - Node.js crypto object.\n * @return {Uint8Array} - Hash value.\n */\nconst nodedigest = (hash, msg, nodeCrypto) => {\n  const alg = params.hashes[hash].nodeName;\n  const hashFunc = nodeCrypto.createHash(alg);\n  hashFunc.update(msg);\n  return hashFunc.digest();\n};\n\n/**\n * Compute hash using pure js implementations\n * @param {String} hash - Name of hash algorithm like SHA-256\n * @param {Uint8Array} msg - Byte array of message to be hashed.\n * @return {Uint8Array} - Hash value.\n */\nconst purejs = (hash, msg) => {\n  let h;\n  if(hash === 'MD5'){\n    h = md5(Array.from(msg), {asBytes: true});\n  }\n  else {\n    h = jsHash[params.hashes[hash].nodeName]().update(msg).digest();\n  }\n\n  return new Uint8Array(h);\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/hash.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 52,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": "{compute}",
    "description": "Compute Hash value.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 'SHA-256'",
        "defaultRaw": " 'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Hash value"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedHashAlgorithm, UnsupportedMessageType,\n or UnsupportedEnvironment, i.e., a case where even pure js implementation won't work."
      }
    ]
  },
  {
    "__docId__": 53,
    "kind": "function",
    "name": "msdigest",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~msdigest",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": null,
    "description": "Compute hash using MsCrypto implementation",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like SHA-256"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "msCrypto",
        "description": "msCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Hash value."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if hashing failed."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "function",
    "name": "nodedigest",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~nodedigest",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": null,
    "description": "Compute hash using Node.js implementation",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like SHA-256"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "Node.js crypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Hash value."
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "function",
    "name": "purejs",
    "memberof": "packages/js-crypto-hash/src/hash.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-hash/src/hash.js~purejs",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hash/src/hash.js",
    "importStyle": null,
    "description": "Compute hash using pure js implementations",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like SHA-256"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be hashed."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Hash value."
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute} from './hash.js';\n\nexport default {compute};\nexport {compute};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "file",
    "name": "packages/js-crypto-hash/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20}, // SHOULD NOT USE\n    'MD5': {nodeName: 'md5', hashSize: 16} // SHOULD NOT USE\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/hkdf.js",
    "content": "/**\n * hkdf.js\n */\n\nimport params from './params.js';\nimport * as util from 'js-crypto-env';\n\nimport random from 'js-crypto-random';\nimport hmac  from 'js-crypto-hmac';\n\n/**\n * Hash-based Key Derivation Function computing from given master secret and salt.\n * If salt is not given, salt would be automatically generated inside.\n * Specification is given in RFC5869 {@link https://tools.ietf.org/html/rfc5869}.\n * @param {Uint8Array} master - Master secret to derive the key.\n * @param {String} [hash='SHA-256] - Name of hash algorithm used to derive the key.\n * @param {Number} [length = 32] - Intended length of derived key.\n * @param {String} [info=''] - String for information field of HKDF.\n * @param {Uint8Array} [salt=null] - Byte array of salt.\n * @return {Promise<{key: Uint8Array, salt: Uint8Array}>} - Derived key and salt used to derive the key.\n */\nexport async function compute(master, hash = 'SHA-256', length = 32, info = '', salt = null){\n  if(!info) info = '';\n  const webCrypto = util.getWebCrypto(); // web crypto api\n\n  let key;\n  if(!salt) salt = await random.getRandomBytes(length);\n\n  if (typeof webCrypto !== 'undefined'\n    && typeof webCrypto.importKey === 'function'\n    && typeof webCrypto.deriveBits === 'function'\n    && typeof window.msCrypto === 'undefined') {\n    try { // modern browsers supporting HKDF\n      const masterObj = await webCrypto.importKey('raw', master, {name: 'HKDF'}, false, ['deriveKey', 'deriveBits']);\n      key = await webCrypto.deriveBits({\n        name: 'HKDF',\n        salt,\n        info: new Uint8Array(info),\n        hash\n      }, masterObj, length * 8);\n      key = new Uint8Array(key);\n    }\n    catch (e) { // fall back to pure js implementation\n      key = await rfc5869(master, hash, length, info, salt);\n    }\n  }\n  else { // node and IE\n    key = await rfc5869(master, hash, length, info, salt);\n  }\n\n  return {key, salt};\n}\n\n/**\n * Naive implementation of RFC5869 in PureJavaScript\n * @param {Uint8Array} master - Master secret to derive the key.\n * @param {String} hash - Name of hash algorithm used to derive the key.\n * @param {Number} length - Intended length of derived key.\n * @param {String} info - String for information field of HKDF.\n * @param {Uint8Array} salt - Byte array of salt.\n * @return {Promise<Uint8Array>} - Derived key.\n */\nasync function rfc5869(master, hash, length, info, salt){\n  const len = params.hashes[hash].hashSize;\n\n  // RFC5869 Step 1 (Extract)\n  const prk = await hmac.compute(salt, master, hash);\n\n  // RFC5869 Step 2 (Expand)\n  let t = new Uint8Array([]);\n  const okm = new Uint8Array(Math.ceil(length / len) * len);\n  const uintInfo = new Uint8Array(info);\n  for(let i = 0; i < Math.ceil(length / len); i++){\n    const concat = new Uint8Array(t.length + uintInfo.length + 1);\n    concat.set(t);\n    concat.set(uintInfo, t.length);\n    concat.set(new Uint8Array([i+1]), t.length + uintInfo.length);\n    t = await hmac.compute(prk, concat, hash);\n    okm.set(t, len * i);\n  }\n  return okm.slice(0, length);\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/hkdf.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hkdf/src/hkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hkdf/src/hkdf.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hkdf/src/hkdf.js",
    "importStyle": "{compute}",
    "description": "Hash-based Key Derivation Function computing from given master secret and salt.\nIf salt is not given, salt would be automatically generated inside.\nSpecification is given in RFC5869 {@link https://tools.ietf.org/html/rfc5869}.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "master",
        "description": "Master secret to derive the key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256",
        "defaultRaw": "'SHA-256",
        "name": "hash",
        "description": "Name of hash algorithm used to derive the key."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 32",
        "defaultRaw": 32,
        "name": "length",
        "description": "Intended length of derived key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "info",
        "description": "String for information field of HKDF."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "salt",
        "description": "Byte array of salt."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{key: Uint8Array, salt: Uint8Array}>"
      ],
      "spread": false,
      "description": "Derived key and salt used to derive the key."
    }
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "rfc5869",
    "memberof": "packages/js-crypto-hkdf/src/hkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hkdf/src/hkdf.js~rfc5869",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hkdf/src/hkdf.js",
    "importStyle": null,
    "description": "Naive implementation of RFC5869 in PureJavaScript",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "master",
        "description": "Master secret to derive the key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm used to derive the key."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "Intended length of derived key."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "String for information field of HKDF."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "salt",
        "description": "Byte array of salt."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Derived key."
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute} from './hkdf.js';\n\nexport default {compute};\nexport {compute};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "packages/js-crypto-hkdf/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20},\n    'MD5': {nodeName: 'md5', hashSize: 16}\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/hmac.js",
    "content": "/**\n * hmac.js\n */\n\nimport params from './params.js';\nimport * as util from 'js-crypto-env';\nimport jschash from 'js-crypto-hash';\n\n\n/**\n * Compute keyed hash value\n * @param {Uint8Array} key - ByteArray of symmetric key.\n * @param {Uint8Array} data - Byte array of message to be hashed.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @return {Promise<Uint8Array>} - Keyed-hash value.\n * @throws {Error} - Throws if UnsupportedEnvironment, i.e., even neither WebCrypto, NodeCrypto nor PureJS is available.\n */\nexport async function compute(key, data, hash = 'SHA-256'){\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // node crypto\n\n  let native = true;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') {\n    if (typeof window.msCrypto === 'undefined'){\n      try {\n        // standard web api / modern browsers supporting HMAC\n        const keyObj = await webCrypto.importKey('raw', key, { name: 'HMAC', hash: {name: hash} }, false, ['sign', 'verify']);\n        const mac = await webCrypto.sign({name: 'HMAC', hash: {name: hash}}, keyObj, data);\n        return new Uint8Array(mac);\n      } catch (e) { native = false; }\n    }\n    else {\n      try{\n      // function definitions\n        const msImportKey = (type, key, alg, ext, use) => new Promise ( (resolve, reject) => {\n          const op = webCrypto.importKey(type, key, alg, ext, use);\n          op.oncomplete = (evt) => { resolve(evt.target.result); };\n          op.onerror = () => { reject('KeyImportingFailed'); };\n        });\n        const msHmac = (hash, k, d) => new Promise ( (resolve, reject) => {\n          const op = webCrypto.sign({name: 'HMAC', hash: {name: hash}}, k, d);\n          op.oncomplete = (evt) => { resolve(new Uint8Array(evt.target.result)); };\n          op.onerror = () => { reject('ComputingHMACFailed'); };\n        });\n\n        const keyObj = await msImportKey('raw', key, {name: 'HMAC', hash: {name: hash}}, false, ['sign', 'verify']);\n        const rawPrk = await msHmac(hash, keyObj, data);\n        return new Uint8Array(rawPrk);\n      } catch (e) { native = false; }\n    }\n  }\n  else if (typeof nodeCrypto !== 'undefined'){ // for node\n    try {\n      const f = nodeCrypto.createHmac(params.hashes[hash].nodeName, key);\n      return new Uint8Array(f.update(data).digest());\n    } catch (e) { native = false; }\n  }\n  else native = false;\n\n  if (!native){\n    try {\n      return await purejs(key, data, hash);\n    } catch (e) {\n      throw new Error('UnsupportedEnvironments');\n    }\n  }\n}\n\n\n/**\n * PureJS implementation of HMAC algorithm specified in RFC 2104 {@link https://tools.ietf.org/html/rfc2104}.\n * @param {Uint8Array} key - ByteArray of symmetric key.\n * @param {Uint8Array} data - Byte array of message to be hashed.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @return {Promise<void>} - Keyed-hash value.\n */\nasync function purejs(key, data, hash){\n  const B = params.hashes[hash].blockSize;\n  const L = params.hashes[hash].hashSize;\n\n  if(key.length > B) key = await jschash.compute(key, hash);\n\n  const K = new Uint8Array(B); // first the array is initialized with 0x00\n  K.set(key);\n\n  const KxorIpad = K.map( (k) => 0xFF & (0x36 ^ k));\n  const KxorOpad = K.map( (k) => 0xFF & (0x5c ^ k));\n\n  const inner = new Uint8Array(B + data.length);\n  inner.set(KxorIpad);\n  inner.set(data, B);\n  const hashedInner = await jschash.compute(inner, hash);\n\n  const outer = new Uint8Array(B + L);\n  outer.set(KxorOpad);\n  outer.set(hashedInner, B);\n\n  return await jschash.compute(outer, hash);\n}\n\n/**\n * Verify keyed-hash value using the key\n * @param {Uint8Array} key - ByteArray of symmetric key.\n * @param {Uint8Array} data - Byte array of message to be hashed.\n * @param {Uint8Array} mac - Given keyed-hash value.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @return {Promise<boolean>} - Result of verification.\n * @throws {Error} - Throws if InvalidInputMac\n */\nexport async function verify(key, data, mac, hash = 'SHA-256'){\n  if (!(mac instanceof Uint8Array)) throw new Error('InvalidInputMac');\n\n  const newMac = await compute(key, data, hash);\n  return (mac.toString() === newMac.toString());\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/hmac.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "compute",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~compute",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": "{compute}",
    "description": "Compute keyed hash value",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "ByteArray of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Keyed-hash value."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment, i.e., even neither WebCrypto, NodeCrypto nor PureJS is available."
      }
    ]
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "purejs",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~purejs",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": null,
    "description": "PureJS implementation of HMAC algorithm specified in RFC 2104 {@link https://tools.ietf.org/html/rfc2104}.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "ByteArray of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": "Keyed-hash value."
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-hmac/src/hmac.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-hmac/src/hmac.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-hmac/src/hmac.js",
    "importStyle": "{verify}",
    "description": "Verify keyed-hash value using the key",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "ByteArray of symmetric key."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Byte array of message to be hashed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "mac",
        "description": "Given keyed-hash value."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidInputMac"
      }
    ]
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {compute, verify} from './hmac.js';\n\nexport default {compute, verify};\nexport {compute, verify};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "packages/js-crypto-hmac/src/params.js",
    "content": "/**\n * params. js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32, blockSize: 64},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48, blockSize: 128},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64, blockSize: 128},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20, blockSize: 64},\n    'MD5': {nodeName: 'md5', hashSize: 16, blockSize: 64}\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1def.js",
    "content": "/**\n * asn1def.js\n */\n\nimport asn from 'asn1.js';\n\n///////////////////////////////////////////////////////////////////////////////////////////\n/**\n * This is either one of subjectPublicKeyInfo, oneAsymmetricKey or encryptedPrivateKeyInfo in ASN.1 format.\n * @type {AsnObject}\n */\nexport const KeyStructure = asn.define('KeyStructure', function (){\n  this.choice({\n    subjectPublicKeyInfo: this.use(SubjectPublicKeyInfo),\n    oneAsymmetricKey: this.use(OneAsymmetricKey),\n    encryptedPrivateKeyInfo: this.use(EncryptedPrivateKeyInfo)\n  });\n});\n\n/**\n * SubjectPublicKeyInfo specified in RFC 5280 {@link https://tools.ietf.org/html/rfc5280}.\n * @type {AsnObject}\n */\nexport const SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\n/**\n * OneAsymmetricKey specified in RFC5958 {@link https://tools.ietf.org/html/rfc5958}.\n * (old version PrivateKeyInfo {@link https://tools.ietf.org/html/rfc5208}.)\n * @type {AsnObject}\n */\nexport const OneAsymmetricKey = asn.define('OneAsymmetricKey', function () {\n  this.seq().obj(\n    this.key('version').use(Version),\n    this.key('privateKeyAlgorithm').use(AlgorithmIdentifier),\n    this.key('privateKey').octstr(),\n    this.key('attributes').implicit(0).optional().any(),\n    this.key('publicKey').implicit(1).optional().bitstr()\n  );\n});\n/**\n * EncryptedPrivateKeyInfo specified in RFC5958 {@link https://tools.ietf.org/html/rfc5958}.\n * @type {AsnObject}\n */\nexport const EncryptedPrivateKeyInfo = asn.define('EncryptedPrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('encryptionAlgorithm').use(AlgorithmIdentifier),\n    this.key('encryptedData').octstr()\n  );\n});\n\n\n///////////////////////////////////////////////////////////////////////////////////////////\n/**\n * PBEParameter, parameter for password-based encryption, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.\n * @type {AsnObject}\n */\nexport const PBEParameter = asn.define('PBEParameter', function(){\n  this.seq().obj(\n    this.key('salt').octstr(8),\n    this.key('iterationCount').int()\n  );\n});\n\n/**\n * PBES2Params, parameter for password-based encryption scheme 2, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.\n * @type {AsnObject}\n */\nexport const PBES2Params = asn.define('PBES2Params', function(){\n  this.seq().obj(\n    this.key('keyDerivationFunc').use(AlgorithmIdentifier),\n    this.key('encryptionScheme').use(AlgorithmIdentifier)\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// PBKDF2-params ::= SEQUENCE {\n//        salt CHOICE {\n//          specified OCTET STRING,\n//          otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n//        },\n//        iterationCount INTEGER (1..MAX),\n//        keyLength INTEGER (1..MAX) OPTIONAL,\n//        prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT\n//        algid-hmacWithSHA1\n//    }\n/**\n * PBKDF2Params, parameter for PBKDF2, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.\n * @type {AsnObject}\n */\nexport const PBKDF2Params = asn.define('PBKDF2Params', function(){\n  this.seq().obj(\n    this.key('salt').choice({\n      'specified': this.octstr(),\n      'otherSource': this.use(AlgorithmIdentifier)\n    }),\n    this.key('iterationCount').int(),\n    this.key('keyLength').int().optional(),\n    this.key('prf').use(AlgorithmIdentifier).def({\n      algorithm: [1, 2, 840, 113549, 2, 7], // hmacWithSHA1\n      parameters: Buffer.from([0x05, 0x00])\n    })\n  );\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////\n/**\n * PBES2ESParams specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.\n * @type {{'aes192-cbc': AsnObject, 'aes128-cbc': AsnObject, 'des-ede3-cbc': Object, 'aes256-cbc': AsnObject}}\n */\nexport const PBES2ESParams = {\n  'des-ede3-cbc': asn.define('DesEde3CbcParams', function(){\n    this.octstr();\n  }),\n  'aes128-cbc': asn.define('Aes128CbcParams', function(){\n    this.octstr();\n  }),\n  'aes192-cbc': asn.define('Aes192CbcParams', function(){\n    this.octstr();\n  }),\n  'aes256-cbc': asn.define('Aes256CbcParams', function(){\n    this.octstr();\n  })\n};\n\n\n////////////////////////////////////////////////////////////////////////////////////\n/**\n * AlgorithmIdentifier given in RFC 5280 {@link https://tools.ietf.org/html/rfc5280}\n * @type AsnObject\n */\nconst AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('parameters').optional().any()\n  );\n});\n\n/**\n * Version\n * @type {AsnObject}\n */\nconst Version = asn.define('Version', function () {\n  this.int();\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1def.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "name": "KeyStructure",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~KeyStructure",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{KeyStructure}",
    "description": "This is either one of subjectPublicKeyInfo, oneAsymmetricKey or encryptedPrivateKeyInfo in ASN.1 format.",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 71,
    "kind": "variable",
    "name": "SubjectPublicKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~SubjectPublicKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{SubjectPublicKeyInfo}",
    "description": "SubjectPublicKeyInfo specified in RFC 5280 {@link https://tools.ietf.org/html/rfc5280}.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "OneAsymmetricKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~OneAsymmetricKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{OneAsymmetricKey}",
    "description": "OneAsymmetricKey specified in RFC5958 {@link https://tools.ietf.org/html/rfc5958}.\n(old version PrivateKeyInfo {@link https://tools.ietf.org/html/rfc5208}.)",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "variable",
    "name": "EncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~EncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{EncryptedPrivateKeyInfo}",
    "description": "EncryptedPrivateKeyInfo specified in RFC5958 {@link https://tools.ietf.org/html/rfc5958}.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "variable",
    "name": "PBEParameter",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBEParameter",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBEParameter}",
    "description": "PBEParameter, parameter for password-based encryption, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "PBES2Params",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBES2Params",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBES2Params}",
    "description": "PBES2Params, parameter for password-based encryption scheme 2, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.",
    "lineNumber": 74,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "PBKDF2Params",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBKDF2Params",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBKDF2Params}",
    "description": "PBKDF2Params, parameter for PBKDF2, specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "PBES2ESParams",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~PBES2ESParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": "{PBES2ESParams}",
    "description": "PBES2ESParams specified in RFC 8018 {@link https://tools.ietf.org/html/rfc8018}.",
    "lineNumber": 116,
    "type": {
      "nullable": null,
      "types": [
        "{'aes192-cbc': AsnObject, 'aes128-cbc': AsnObject, 'des-ede3-cbc': Object, 'aes256-cbc': AsnObject}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "name": "AlgorithmIdentifier",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~AlgorithmIdentifier",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": null,
    "description": "AlgorithmIdentifier given in RFC 5280 {@link https://tools.ietf.org/html/rfc5280}",
    "lineNumber": 137,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "Version",
    "memberof": "packages/js-crypto-key-utils/src/asn1def.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1def.js~Version",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1def.js",
    "importStyle": null,
    "description": "Version",
    "lineNumber": 148,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 80,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1ec.js",
    "content": "/**\n * asn1ec.js\n */\n\nimport asn from 'asn1.js';\n\nimport params, {getAlgorithmFromOid} from './params.js';\nimport {toJwk as octKeyToJwk, fromJwk as octKeyFromJwk} from './octenc.js';\n\n/**\n * Convert JWK to parsed ASN.1 EC key object\n * @param {JsonWebKey} jwk - A key object in JWK format.\n * @param {PublicOrPrivate} type - 'public' or 'private'\n * @param {boolean} [compact=false] - *Only for EC public keys*, the compact form of public key is given as ASN.1 object if true.\n * @return {Object} - Parsed ASN.1 object.\n */\nexport function fromJWK(jwk, type, compact=false){\n  if (Object.keys(params.namedCurves).indexOf(jwk.crv) < 0) throw new Error('UnsupportedCurve');\n  const octetPublicKey = octKeyFromJwk(jwk, {outputFormat: 'binary', outputPublic: true, compact});\n\n  const publicKeyAlgorithmOid = params.publicKeyAlgorithms['EC'].oid;\n  const publicKey = {unused: 0, data: Array.from(octetPublicKey)};//Buffer.from(octkeyObj.publicKey)};\n  const parameters = ECParameters.encode({ type: 'namedCurve', value: params.namedCurves[jwk.crv].oid }, 'der');\n  const algorithm = { algorithm: publicKeyAlgorithmOid, parameters };\n\n  const decoded = {};\n  if(type === 'public'){ // SPKI\n    decoded.subjectPublicKey = publicKey;\n    decoded.algorithm = algorithm;\n  }\n  else if (type === 'private') { // PKCS8\n    const octetPrivateKey = octKeyFromJwk(jwk, {outputFormat: 'binary', outputPublic: false, compact});\n    decoded.version = 0; // no public key presents for v2 (0)\n    decoded.privateKeyAlgorithm = algorithm;\n    decoded.privateKey = ECPrivateKey.encode({\n      version: 1,\n      privateKey: Array.from(octetPrivateKey), //Buffer.from(octkeyObj.privateKey),\n      parameters,\n      publicKey\n    }, 'der');\n  }\n  return decoded;\n}\n\n\n/**\n * Convert parsed ASN.1 EC key object to JWK.\n * @param {Object} decoded - Parsed ASN.1 EC key object.\n * @param {PublicOrPrivate} type - 'public' or 'private'\n * @return {JsonWebKey} - Converted key objects in JWK format.\n * @throws {Error} - Throws if UnsupportedCurve.\n */\nexport function toJWK(decoded, type){\n  if (type === 'public'){ // SPKI\n    decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, 'der'); // overwrite nested binary object as parsed object\n    const octPubKey = new Uint8Array(decoded.subjectPublicKey.data); // convert oct key to jwk\n    const namedCurves = getAlgorithmFromOid(decoded.algorithm.parameters.value, params.namedCurves);\n    if(namedCurves.length < 1) throw new Error('UnsupportedCurve');\n\n    return octKeyToJwk(octPubKey, namedCurves[0], {outputPublic: true});\n  }\n  else if (type === 'private'){ // PKCS8\n    decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, 'der');\n    // Work around for optional private key parameter field.\n    try{ decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, 'der'); }\n    catch(e){ decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, 'der'); }\n\n    const octPrivKey = new Uint8Array(decoded.privateKey.privateKey);\n\n    const namedCurves = getAlgorithmFromOid(decoded.privateKeyAlgorithm.parameters.value, params.namedCurves);\n    if(namedCurves.length < 1) throw new Error('UnsupportedCurve');\n\n    return octKeyToJwk(octPrivKey, namedCurves[0], {outputPublic: false});\n  }\n}\n\n/////////////////////////\n/**\n * ECParameters specified in RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.\n * @type {AsnObject}\n */\nconst ECParameters = asn.define('ECParameters', function() {\n  this.choice({\n    namedCurve: this.objid()\n  });\n});\n\n/**\n * ECPrivateKey specified in RFC 5915 {@link https://tools.ietf.org/html/rfc5915}.\n * @type {AsnObject}\n */\nconst ECPrivateKey = asn.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented\n    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented\n  );\n});\n\n/**\n * ECPrivateKey Alternative for an work around...\n * @type {AsnObject}\n */\nconst ECPrivateKeyAlt = asn.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented\n    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "fromJWK",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~fromJWK",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": "{fromJWK}",
    "description": "Convert JWK to parsed ASN.1 EC key object",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwk",
        "description": "A key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "PublicOrPrivate"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "'public' or 'private'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "compact",
        "description": "*Only for EC public keys*, the compact form of public key is given as ASN.1 object if true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Parsed ASN.1 object."
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "toJWK",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~toJWK",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": "{toJWK}",
    "description": "Convert parsed ASN.1 EC key object to JWK.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "decoded",
        "description": "Parsed ASN.1 EC key object."
      },
      {
        "nullable": null,
        "types": [
          "PublicOrPrivate"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "'public' or 'private'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Converted key objects in JWK format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedCurve."
      }
    ]
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "ECParameters",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECParameters",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": "ECParameters specified in RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "ECPrivateKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECPrivateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": "ECPrivateKey specified in RFC 5915 {@link https://tools.ietf.org/html/rfc5915}.",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "name": "ECPrivateKeyAlt",
    "memberof": "packages/js-crypto-key-utils/src/asn1ec.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1ec.js~ECPrivateKeyAlt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1ec.js",
    "importStyle": null,
    "description": "ECPrivateKey Alternative for an work around...",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "AsnObject"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1enc.js",
    "content": "/**\n * asn1enc.js\n */\n\nimport * as asn1ec from './asn1ec.js';\nimport * as asn1rsa from './asn1rsa.js';\nimport params, {getAlgorithmFromOid} from './params.js';\nimport jseu from 'js-encoding-utils';\nimport BufferMod from 'buffer';\nimport {OneAsymmetricKey, SubjectPublicKeyInfo, KeyStructure} from './asn1def.js';\nimport {encryptEncryptedPrivateKeyInfo, decryptEncryptedPrivateKeyInfo} from './rfc8018.js';\nimport {getJwkType} from './util.js';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Convert jwk to spki/pkcs8 in string or binary format.\n * @param {JsonWebKey} jwkey - A key object in JWK format to be encoded.\n * @param {boolean} outputPublic - Derive public key from private key when true\n * @param {AsnFormat} format - 'pem' or 'der'\n * @param {boolean} compact - 'true' or 'false' for EC public key compressed representation in der/pem\n * @param {String} passphrase - if passphrase is given and the given key is private key, it will be encoded with the passphrase.\n * @param {AsnEncryptOptionsWithPassphrase} encOptions - ASN.1 encryption options\n * @return {Uint8Array|String} - Encoded private key in DER or PEM\n */\nexport async function fromJwk(jwkey, format, {outputPublic, compact=false, encOptions}){\n  const orgType = getJwkType(jwkey);\n  let type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  let decoded;\n  if (jwkey.kty === 'EC') {\n    decoded = asn1ec.fromJWK(jwkey, type, compact);\n  }\n  else if (jwkey.kty === 'RSA'){\n    decoded = asn1rsa.fromJwk(jwkey, type);\n  }\n\n  let binKey;\n  if (type === 'public') {\n    binKey = SubjectPublicKeyInfo.encode(decoded, 'der');\n  }\n  else {\n    binKey = OneAsymmetricKey.encode(decoded, 'der');\n    if(typeof encOptions.passphrase !== 'undefined' && encOptions.passphrase.length > 0){\n      binKey = await encryptEncryptedPrivateKeyInfo(binKey, encOptions);\n      type = 'encryptedPrivate';\n    }\n  }\n  binKey = new Uint8Array(binKey);\n\n  return (format === 'pem') ? jseu.formatter.binToPem(binKey, type) : binKey;\n}\n\n/**\n * Convert SPKI/PKCS8 key in string or binary format to JWK.\n * @param {PEM|DER} key - Key object.\n * @param {AsnFormat} format - 'pem' or 'der'\n * @param {boolean} [outputPublic] - Export public key even from private key if true.\n * @param {String} [passphrase] - Encrypt private key if passphrase is given.\n * @return {JsonWebKey} - Obtained key object in JWK format.\n * @throws {Error} Throws if UnsupportedKeyStructure, UnsupportedKey or InvalidKeyType.\n */\nexport async function toJwk(key, format, {outputPublic, passphrase}){\n  // Peel the pem strings\n  const binKey = (format === 'pem') ? jseu.formatter.pemToBin(key) : key;\n\n  // decode binary spki/pkcs8-formatted key to parsed object\n  let decoded;\n  try { decoded = KeyStructure.decode(Buffer.from(binKey), 'der'); }\n  catch (e) { throw new Error('FailedToDecodeKey'); }\n\n  let type;\n  if(decoded.type === 'subjectPublicKeyInfo'){\n    type = 'public';\n    decoded = decoded.value;\n  }\n  else {\n    type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : 'private';\n\n    if(decoded.type === 'encryptedPrivateKeyInfo') decoded = await decryptEncryptedPrivateKeyInfo(decoded.value, passphrase);\n    else if (decoded.type === 'oneAsymmetricKey') decoded = decoded.value;\n    else throw new Error('UnsupportedKeyStructure');\n  }\n\n  const keyTypes = getAlgorithmFromOid(\n    (type === 'public') ? decoded.algorithm.algorithm : decoded.privateKeyAlgorithm.algorithm,\n    params.publicKeyAlgorithms\n  );\n  if(keyTypes.length < 1) throw new Error('UnsupportedKey');\n\n  if (keyTypes[0] === 'EC') {\n    return asn1ec.toJWK(decoded, type);\n  }\n  else if (keyTypes[0] === 'RSA'){\n    return asn1rsa.toJwk(decoded, type);\n  }\n  else throw new Error('InvalidKeyType');\n}\n\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1enc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": "{fromJwk}",
    "description": "Convert jwk to spki/pkcs8 in string or binary format.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "A key object in JWK format to be encoded."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "outputPublic",
        "description": "Derive public key from private key when true"
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "'pem' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "compact",
        "description": "'true' or 'false' for EC public key compressed representation in der/pem"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "if passphrase is given and the given key is private key, it will be encoded with the passphrase."
      },
      {
        "nullable": null,
        "types": [
          "AsnEncryptOptionsWithPassphrase"
        ],
        "spread": false,
        "optional": false,
        "name": "encOptions",
        "description": "ASN.1 encryption options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array",
        "String"
      ],
      "spread": false,
      "description": "Encoded private key in DER or PEM"
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1enc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1enc.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1enc.js",
    "importStyle": "{toJwk}",
    "description": "Convert SPKI/PKCS8 key in string or binary format to JWK.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "PEM",
          "DER"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key object."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "'pem' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "outputPublic",
        "description": "Export public key even from private key if true."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "passphrase",
        "description": "Encrypt private key if passphrase is given."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Obtained key object in JWK format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedKeyStructure, UnsupportedKey or InvalidKeyType."
      }
    ]
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "content": "/**\n * asn1rsa.js\n */\n\nimport asn from 'asn1.js';\nimport jseu from 'js-encoding-utils';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\nimport params from './params.js';\nimport {appendLeadingZeros, pruneLeadingZeros} from './util';\n\n/**\n * Encode RSA JWK key to ASN.1 DER or PEM of SPKI/OneAsymmetricKey.\n * @param {JsonWebKey} jwk - A key object in JWK format to be encoded.\n * @param {PublicOrPrivate} type - 'public' or 'private'.\n * @returns {Object} - Parsed object of ASN.1 encoded key object.\n */\nexport function fromJwk(jwk, type){\n\n  const publicKeyAlgorithmOid = params.publicKeyAlgorithms['RSA'].oid;\n  // Parameters is always null Ox0500 in ASN.1 as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n  const parameters = Buffer.from([0x05, 0x00]);\n  const algorithm = { algorithm: publicKeyAlgorithmOid, parameters };\n\n  // to append leading zeros (pruned when making JWK) in order to make binary of intended bit length\n  // https://tools.ietf.org/html/rfc7518#section-6.3\n  const modulusBytes = jseu.encoder.decodeBase64Url(jwk.n);\n  const nLen = modulusBytes.length;\n  const modulusLength = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128));\n\n  const modulus = new asn.bignum(appendLeadingZeros(modulusBytes, modulusLength)); // JWA RFC\n  const publicExponent = new asn.bignum(jseu.encoder.decodeBase64Url(jwk.e));\n\n  const decoded = {};\n  if(type === 'public'){ // SPKI\n    decoded.subjectPublicKey = {\n      unused: 0,\n      data: RSAPublicKey.encode({ modulus, publicExponent  }, 'der')\n    };\n    decoded.algorithm = algorithm;\n  }\n  else if (type === 'private') { // PKCS8\n    decoded.version = 0;  // no public key presents for v2 (0)\n    decoded.privateKeyAlgorithm = algorithm;\n    decoded.privateKey = RSAPrivateKey.encode({\n      version: 0,\n      modulus,\n      publicExponent,\n      privateExponent: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.d), modulusLength)),\n      prime1: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.p), modulusLength)),\n      prime2: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.q), modulusLength)),\n      exponent1: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.dp), modulusLength)),\n      exponent2: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.dq), modulusLength)),\n      coefficient: new asn.bignum( appendLeadingZeros(jseu.encoder.decodeBase64Url(jwk.qi), modulusLength))\n    }, 'der');\n  }\n  return decoded;\n}\n\n/**\n * Convert RSA spki/pkcs8 public/private keys to JWK\n * @param {Object} decoded - Parsed object of RSA key to be encoded.\n * @param {PublicOrPrivate} type - 'public' or 'private'\n * @return {JsonWebKey} - Encoded RSA key object in JWK format.\n */\nexport function toJwk(decoded, type){\n\n  if (type === 'public'){ // SPKI\n    // algorithm.algorithm.parameters is always null Ox0500 in ASN.1\n    // as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n\n    // overwrite nested binary object as parsed object\n    decoded.subjectPublicKey.data = RSAPublicKey.decode(decoded.subjectPublicKey.data, 'der');\n    let modulus = decoded.subjectPublicKey.data.modulus;\n    let publicExponent = decoded.subjectPublicKey.data.publicExponent;\n\n    // convert n and e from BN\n    // modulus n\n    const nLen = modulus.byteLength();\n    const len = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128));\n    modulus = new Uint8Array(modulus.toArray('be', len));\n\n    // // publicExponent e;\n    publicExponent = new Uint8Array(publicExponent.toArray('be', publicExponent.byteLength()));\n\n    return {\n      kty: 'RSA',\n      n: jseu.encoder.encodeBase64Url(pruneLeadingZeros(modulus)), // prune leading zeros https://tools.ietf.org/html/rfc7518#section-6.3\n      e: jseu.encoder.encodeBase64Url(pruneLeadingZeros(publicExponent))\n    };\n  }\n  else if (type === 'private'){ // PKCS8\n    // privateKeyAlgorithm.algorithm.parameters is always null Ox0500 in ASN.1\n    // as shown in the Section 2.3.1 https://tools.ietf.org/html/rfc3279\n\n    // overwrite nested binary object as parsed object\n    decoded.privateKey = RSAPrivateKey.decode(decoded.privateKey, 'der');\n\n    const privateKeyElems = {};\n    privateKeyElems.modulus = decoded.privateKey.modulus;\n\n\n    // calculate key length from modulus n\n    const nLen = privateKeyElems.modulus.byteLength();\n    const len = (nLen % 128 === 0) ? nLen : nLen + (128 - (nLen % 128)); // this is actual key length, e.g., 256 bytes\n\n\n    // convert BN to Uint8Array\n    privateKeyElems.modulus = new Uint8Array(privateKeyElems.modulus.toArray('be', len)); // n of length len\n    privateKeyElems.publicExponent = new Uint8Array(\n      decoded.privateKey.publicExponent.toArray( 'be', decoded.privateKey.publicExponent.byteLength() )\n    ); // e of arbitrary small length\n    privateKeyElems.privateExponent = new Uint8Array(decoded.privateKey.privateExponent.toArray('be', len)); // d of length len\n\n    const keys = ['prime1', 'prime2', 'exponent1', 'exponent2', 'coefficient']; // elements of length len/2\n    keys.forEach( (key) => {\n      privateKeyElems[key] = new Uint8Array(decoded.privateKey[key].toArray('be', (len>>1) ));\n    });\n\n    // prune leading zeros JWW RSA private key: https://tools.ietf.org/html/rfc7517\n    return {\n      kty: 'RSA',\n      n: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.modulus)),\n      e: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.publicExponent)),\n      d: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.privateExponent)),\n      p: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.prime1)),\n      q: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.prime2)),\n      dp: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.exponent1)),\n      dq: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.exponent2)),\n      qi: jseu.encoder.encodeBase64Url(pruneLeadingZeros(privateKeyElems.coefficient))\n    };\n  }\n}\n\n\n///////////\n// https://tools.ietf.org/html/rfc3447\nconst RSAPublicKey = asn.define('RSAPublicKey', function() {\n  this.seq().obj(\n    this.key('modulus').int(), // n\n    this.key('publicExponent').int() // e\n  );\n});\n\nconst RSAPrivateKey = asn.define('RSAPrivateKey', function(){\n  this.seq().obj(\n    this.key('version').int(), // 0\n    this.key('modulus').int(), // n\n    this.key('publicExponent').int(), // e\n    this.key('privateExponent').int(), // d\n    this.key('prime1').int(), // p\n    this.key('prime2').int(), // q\n    this.key('exponent1').int(), // d mod (p-1)\n    this.key('exponent2').int(), // d mod (q-1)\n    this.key('coefficient').int(), // (inverse of q) mod p\n    this.key('otherPrimeInfos').optional().use(OtherPrimeInfos)\n  );\n});\n\nconst OtherPrimeInfos = asn.define('OtherPrimeInfos', function(){\n  this.seqof(OtherPrimeInfo);\n});\n\nconst OtherPrimeInfo = asn.define('OtherPrimeInfo', function(){\n  this.seq().obj(\n    this.key('prime').int(),\n    this.key('exponent').int(),\n    this.key('coefficient').int()\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/asn1rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 92,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": "{fromJwk}",
    "description": "Encode RSA JWK key to ASN.1 DER or PEM of SPKI/OneAsymmetricKey.",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - Parsed object of ASN.1 encoded key object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwk",
        "description": "A key object in JWK format to be encoded."
      },
      {
        "nullable": null,
        "types": [
          "PublicOrPrivate"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "'public' or 'private'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Parsed object of ASN.1 encoded key object."
    }
  },
  {
    "__docId__": 93,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": "{toJwk}",
    "description": "Convert RSA spki/pkcs8 public/private keys to JWK",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "decoded",
        "description": "Parsed object of RSA key to be encoded."
      },
      {
        "nullable": null,
        "types": [
          "PublicOrPrivate"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "'public' or 'private'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Encoded RSA key object in JWK format."
    }
  },
  {
    "__docId__": 94,
    "kind": "variable",
    "name": "RSAPublicKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~RSAPublicKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "RSAPrivateKey",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~RSAPrivateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "name": "OtherPrimeInfos",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~OtherPrimeInfos",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "OtherPrimeInfo",
    "memberof": "packages/js-crypto-key-utils/src/asn1rsa.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/asn1rsa.js~OtherPrimeInfo",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/asn1rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/converter.js",
    "content": "/**\n * converter.js\n */\n\nimport * as asn1enc from './asn1enc.js';\nimport * as octenc from './octenc.js';\n\n// ASN.1 in RFC5280 (SPKI) and RFC5208 (PKCS8) -> RSA and EC, encode='asn', format='pem' or 'der'\n// -> SPKI (in X.509): RFC5280 for public key, PKCS8: RFC5208 for private key\n// Octet Form in ANSI X9.63 -> EC, encode='oct', format='string' or 'binary', compact=true or false\n// -> Standards for Efficient Cryptography Group (SECG), \"SEC1: Elliptic Curve Cryptography\", Version 1.0, September 2000.\n/**\n * Convert JWK to ASN.1 (for RSA and EC) and Octet (for EC) encoded keys.\n * @param {String} output - 'pem', 'der', or 'oct' (only EC JWK), output format.\n * @param {JsonWebKey} jwkey - A JWK to be encoded.\n * @param {KeyExportOptions} options - Options to export key including encryption options.\n *   For EC JWK : options.compact = true or false\n *   For EC JWK with output = 'oct' : options.format = 'binary' or 'string'\n *   For both: outputPublic (optional) : boolean. derived key type. from private key, public key can be derived when true.\n * @return {PEM|DER|OctetEC} - Output key object.\n */\nexport async function fromJwkTo(output = 'pem', jwkey, options={}){\n  // assertion\n  if (['pem', 'der', 'oct'].indexOf(output) < 0) throw new Error('InvalidOutputForm');\n  if (typeof jwkey !== 'object') throw new Error('InvalidJWKAsObject');\n  if (jwkey.kty !== 'EC' && jwkey.kty !== 'RSA') throw new Error('UnsupportedKeyType');\n  if (typeof options.outputPublic !== 'undefined' && typeof options.outputPublic !== 'boolean') throw new Error('outputPublicMustBeBoolean');\n\n  // default values\n  if (jwkey.key === 'EC' && typeof options.compact !== 'boolean') options.compact = false;\n  if (output === 'oct' && options.output !== 'string') options.output = 'binary';\n  if (typeof options.encryptParams === 'undefined') options.encryptParams = {};\n  if ((output === 'der' || output === 'pem') && typeof options.encryptParams.passphrase === 'undefined') options.encryptParams.passphrase = '';\n\n  // In the case of PEM/DER\n  if (output === 'der' || output === 'pem') {\n    return await asn1enc.fromJwk(\n      jwkey, output,\n      {outputPublic: options.outputPublic, compact: options.compact, encOptions: options.encryptParams }\n    );\n  }\n  // In the case of Oct\n  else if (output === 'oct' && jwkey.kty === 'EC') {\n    return octenc.fromJwk(jwkey, {outputPublic: options.outputPublic, outputFormat: options.output, compact: options.compact});\n  }\n  else throw new Error('UnsupportedConversion');\n\n}\n\n\n/**\n * Convert ASN.1 encoded (for RSA and EC) or octet formed (for EC) keys to JWK.\n * @param {String} input - 'pem', 'der' or 'oct', input key format.\n * @param {PEM|DER|OctetEC} key - A key object to be encoded.\n * @param {JwkExportOptionsInternal} [options={}] - options to export JWK keys.\n * @return {JsonWebKey} - Obtained key object in JWK format.\n * @throws {Error} - Throws if InvalidInputForm, InappropriateOptions, outputPublicMustBeBoolean or UnsupportedConversion\n */\nexport async function toJwkFrom(input, key, options={}){\n  // assertion\n  if (['pem', 'der', 'oct'].indexOf(input) < 0) throw new Error('InvalidInputForm');\n  if (input === 'oct' && !options.namedCurve ) throw new Error('InappropriateOptions');\n  if (typeof options.outputPublic !== 'undefined' && typeof options.outputPublic !== 'boolean') throw new Error('outputPublicMustBeBoolean');\n\n  // default values\n  if ((input === 'der' || input === 'pem') && typeof options.passphrase === 'undefined') options.passphrase = '';\n\n  // In the case of PEM\n  if (input === 'der' || input === 'pem') {\n    return await asn1enc.toJwk(key, input, {outputPublic: options.outputPublic, passphrase: options.passphrase});\n  }\n  // In the case of Oct\n  else if (input === 'oct') {\n    return octenc.toJwk(key, options.namedCurve, {outputPublic: options.outputPublic});\n  }\n  else throw new Error('UnsupportedConversion');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/converter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "fromJwkTo",
    "memberof": "packages/js-crypto-key-utils/src/converter.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/converter.js~fromJwkTo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/converter.js",
    "importStyle": "{fromJwkTo}",
    "description": "Convert JWK to ASN.1 (for RSA and EC) and Octet (for EC) encoded keys.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "'pem', 'der', or 'oct' (only EC JWK), output format."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "A JWK to be encoded."
      },
      {
        "nullable": null,
        "types": [
          "KeyExportOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Options to export key including encryption options.\n  For EC JWK : options.compact = true or false\n  For EC JWK with output = 'oct' : options.format = 'binary' or 'string'\n  For both: outputPublic (optional) : boolean. derived key type. from private key, public key can be derived when true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "PEM",
        "DER",
        "OctetEC"
      ],
      "spread": false,
      "description": "Output key object."
    }
  },
  {
    "__docId__": 100,
    "kind": "function",
    "name": "toJwkFrom",
    "memberof": "packages/js-crypto-key-utils/src/converter.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/converter.js~toJwkFrom",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/converter.js",
    "importStyle": "{toJwkFrom}",
    "description": "Convert ASN.1 encoded (for RSA and EC) or octet formed (for EC) keys to JWK.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "'pem', 'der' or 'oct', input key format."
      },
      {
        "nullable": null,
        "types": [
          "PEM",
          "DER",
          "OctetEC"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "A key object to be encoded."
      },
      {
        "nullable": null,
        "types": [
          "JwkExportOptionsInternal"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "options to export JWK keys."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Obtained key object in JWK format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidInputForm, InappropriateOptions, outputPublicMustBeBoolean or UnsupportedConversion"
      }
    ]
  },
  {
    "__docId__": 101,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/index.js",
    "content": "/**\n * index.js\n */\n\n// import {fromJwkTo, toJwkFrom} from './converter.js';\n// import {getJwkThumbprint} from './thumbprint.js';\n// import {isAsn1Encrypted} from './util.js';\nimport {Key} from './key.js';\n\n// export default {fromJwkTo, toJwkFrom, getJwkThumbprint, isAsn1Encrypted, Key};\n// export {fromJwkTo, toJwkFrom, getJwkThumbprint, isAsn1Encrypted, Key};\n\nexport default {Key};\nexport {Key};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 102,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/key.js",
    "content": "/**\n * key.js\n */\nimport {fromJwkTo, toJwkFrom} from './converter.js';\nimport {getJwkThumbprint} from './thumbprint.js';\nimport cloneDeep from 'lodash.clonedeep';\nimport jseu from 'js-encoding-utils';\nimport {getJwkType, getSec1KeyType, isAsn1Encrypted, isAsn1Public} from './util.js';\n\n/**\n * Key class to abstract public and private key objects in string or binary.\n *   This class provides functions to interchangeably convert key formats,\n *   and key objects will be used for the root package, js-crypto-utils, as inputs to exposed APIs.\n */\nexport class Key {\n  /**\n   * @constructor\n   * @param {String} format - Key format: 'jwk', 'der', 'pem' or 'oct' (only for ECC key).\n   * @param {JsonWebKey|PEM|DER|OctetEC} key - Key object in the specified format.\n   * @param {Object} [options={}] - Required if format='oct', and then it is {namedCurve: String}.\n   * @throws {Error} - Throws if the input format and key are incompatible to the constructor.\n   */\n  constructor(format, key, options={}){\n    const localKey = cloneDeep(key);\n    const localOpt = cloneDeep(options);\n\n    this._jwk = {};\n    this._der = null;\n    this._oct = {}; // only for EC keys\n    this._current = {jwk: false, der: false, oct: false};\n\n    if(format === 'jwk'){\n      this._setJwk(localKey);\n    }\n    else if (format === 'der' || format === 'pem'){\n      if(format === 'der' && !(localKey instanceof Uint8Array)) throw new Error('DerKeyMustBeUint8Array');\n      if(format === 'pem' && (typeof localKey !== 'string')) throw new Error('PemKeyMustBeString');\n      this._setAsn1(localKey, format);\n    }\n    else if (format === 'oct'){\n      if(typeof localOpt.namedCurve !== 'string') throw new Error('namedCurveMustBeSpecified');\n      if(!(localKey instanceof Uint8Array)) throw new Error('OctetKeyMustBeUint8Array');\n      this._setSec1(localKey, localOpt.namedCurve);\n    }\n    else throw new Error('UnsupportedType');\n  }\n\n  ///////////////////////////////////////////////////////////\n  // private method handling instance variables\n  // all instance variables must be set via these methods\n  /**\n   * Set a key in JWK to the Key object.\n   * @param {JsonWebKey} jwkey - The Json Web Key.\n   * @private\n   */\n  _setJwk(jwkey){\n    this._type = getJwkType(jwkey); // this also check key format\n    this._jwk = jwkey;\n    if(this._isEncrypted) this._der = null;\n    this._isEncrypted = false;\n    this._setCurrentStatus();\n  }\n\n  /**\n   * Set a key in DER or PEM to the Key object.\n   * @param {DER|PEM} asn1key - The DER key byte array or PEM key string.\n   * @param {String} format - 'der' or 'pem' specifying the format.\n   * @private\n   */\n  _setAsn1(asn1key, format){\n    this._type = (isAsn1Public(asn1key, format)) ? 'public' : 'private'; // this also check key format\n    this._isEncrypted = isAsn1Encrypted(asn1key, format);\n    this._der = (format === 'pem') ? jseu.formatter.pemToBin(asn1key): asn1key;\n    if(this._isEncrypted){\n      this._jwk = {};\n      this._oct = {};\n    }\n    this._setCurrentStatus();\n  }\n\n  /**\n   * Set a key in SEC1 = Octet format to the Key Object.\n   * @param {OctetEC} sec1key - The Octet SEC1 key byte array.\n   * @param {String} namedCurve - Name of curve like 'P-256'.\n   * @private\n   */\n  _setSec1(sec1key, namedCurve){\n    this._type = getSec1KeyType(sec1key, namedCurve);  // this also check key format\n    this._oct = { namedCurve, key: sec1key };\n    if(this._isEncrypted) this._der = null;\n    this._isEncrypted = false;\n    this._setCurrentStatus();\n  }\n\n  /**\n   * Set the current internal status. In particular, manage what the object is based on.\n   * @private\n   */\n  _setCurrentStatus() {\n    this._current.jwk = (\n      typeof this._jwk.kty === 'string'\n      && (this._jwk.kty === 'RSA' || this._jwk.kty === 'EC')\n    );\n    this._current.der = (\n      typeof this._der !== 'undefined'\n      && this._der instanceof Uint8Array\n      && this._der.length > 0\n    );\n    this._current.oct = (\n      typeof this._oct.key !== 'undefined'\n      && this._oct.key instanceof Uint8Array\n      && this._oct.key.length > 0\n      && typeof this._oct.namedCurve === 'string'\n    );\n  }\n  ///////////////////////////////////////////////////////////\n  // (pseudo) public methods allowed to be accessed from outside\n  /**\n   * Convert the stored key and export the key in desired format.\n   * Imported key must be basically decrypted except the case where the key is exported as-is.\n   * @param {String} format - Intended format of exported key. 'jwk', 'pem', 'der' or 'oct'\n   * @param {KeyExportOptions} [options={}] - Optional arguments.\n   * @return {Promise<JsonWebKey|PEM|DER|OctetEC>} - Exported key object.\n   */\n  async export(format = 'jwk', options={}){\n    // global assertion\n    if(['pem', 'der', 'jwk', 'oct'].indexOf(format) < 0) throw new Error('UnsupportedFormat');\n\n    // return 'as is' without passphrase when nothing is given as 'options'\n    // only for the case to export der key from der key (considering encrypted key). expect to be called from getter\n    if(this._isEncrypted && this._type === 'private'){\n      if((format === 'der' || format === 'pem') && Object.keys(options).length === 0 && this._current.der) {\n        return (format === 'pem') ? jseu.formatter.binToPem(this._der, 'encryptedPrivate') : this._der;\n      }\n      else throw new Error('DecryptionRequired');\n    }\n\n    // first converted to jwk\n    let jwkey;\n    if(this._current.jwk){\n      jwkey = this._jwk;\n    }\n    else if(this._current.oct) { // options.type is not specified here to import jwk\n      jwkey = await toJwkFrom('oct', this._oct.key, {namedCurve: this._oct.namedCurve});\n    }\n    else if(this._current.der) {\n      jwkey = await toJwkFrom('der', this._der);\n    }\n    else throw new Error('InvalidStatus');\n\n    this._setJwk(jwkey); // store jwk if the exiting private key is not encrypted\n\n    // then export as the key in intended format\n    if (format === 'der' || format === 'pem') {\n      if(typeof options.encryptParams === 'undefined') options.encryptParams = {};\n      return await fromJwkTo(format, jwkey, {\n        outputPublic: options.outputPublic,\n        compact: options.compact,\n        //passphrase: options.encryptParams.passphrase,\n        encryptParams: options.encryptParams\n      });\n    }\n    else if (format === 'oct') {\n      return await fromJwkTo(format, jwkey, {\n        outputPublic: options.outputPublic,\n        output: options.output,\n        compact: options.compact\n      });\n    }\n    else return jwkey;\n  }\n\n  /**\n   * Encrypt stored key and set the encrypted key to this instance.\n   * @param {String} passphrase - String passphrase.\n   * @return {Promise<boolean>} - Always true otherwise thrown.\n   * @throws {Error} - Throws if AlreadyEncrypted.\n   */\n  async encrypt (passphrase){\n    if(this._isEncrypted) throw new Error('AlreadyEncrypted');\n    const options = {encryptParams: {passphrase}};\n    this._setAsn1(await this.export('der', options), 'der');\n\n    return true;\n  }\n\n  /**\n   * Decrypted stored key and set the decrypted key in JWK to this instance.\n   * @param {String} passphrase - String passphrase.\n   * @return {Promise<boolean>} - Always true otherwise thrown.\n   * @throws {Error} - Throws if NotEncrypted or FailedToDecrypt.\n   */\n  async decrypt (passphrase){\n    if(!this._isEncrypted) throw new Error('NotEncrypted');\n    let jwkey;\n    if(this._current.der && typeof passphrase === 'string'){\n      jwkey = await toJwkFrom('der', this._der, {passphrase}); // type is not specified here to import jwk\n    }\n    else throw new Error('FailedToDecrypt');\n    this._setJwk(jwkey);\n\n    return true;\n  }\n\n  /**\n   * Conpute JWK thumbprint specified in RFC7638 {@link https://tools.ietf.org/html/rfc7638}.\n   * @param {String} [alg='SHA-256'] - Name of hash algorithm for thumbprint computation like 'SHA-256'.\n   * @param {JwkThumbpirntFormat} [output='binary'] - Output format of JWK thumbprint. 'binary', 'hex' or 'base64'.\n   * @return {Promise<Uint8Array|String>} - Computed thumbprint.\n   * @throws {Error} - Throws if DecryptionRequired.\n   */\n  async getJwkThumbprint(alg='SHA-256', output='binary'){\n    if(this._isEncrypted) throw new Error('DecryptionRequired');\n    return await getJwkThumbprint(await this.export('jwk'), alg, output);\n  }\n\n  // getters\n  /**\n   * Get keyType in JWK format\n   * @return {Promise<String>} - 'RSA' or 'EC'\n   * @throws {Error} - Throws if DecryptionRequired.\n   */\n  get keyType(){\n    if(this._isEncrypted) throw new Error('DecryptionRequired');\n    return new Promise( async (resolve, reject) => {\n      const jwkey = await this.export('jwk').catch( (e) => {reject(e);});\n      resolve(jwkey.kty);\n    });\n  }\n\n  /**\n   * Get jwkThumbprint of this key.\n   * @return {Promise<Uint8Array>} - Returns binary thumbprint.\n   */\n  get jwkThumbprint(){\n    return this.getJwkThumbprint();\n  }\n\n  /**\n   * Check if this is encrypted.\n   * @return {boolean}\n   */\n  get isEncrypted(){ return this._isEncrypted; }\n\n  /**\n   * Check if this is a private key.\n   * @return {boolean}\n   */\n  get isPrivate(){ return this._type === 'private'; }\n\n  /**\n   * Returns the key in DER format.\n   * @return {Promise<DER>}\n   */\n  get der(){ return this.export('der'); }\n\n  /**\n   * Returns the key in PEM format.\n   * @return {Promise<PEM>}\n   */\n  get pem(){ return this.export('pem'); }\n\n  /**\n   * Returns the key in JWK format\n   * @return {Promise<JsonWebKey>}\n   */\n  get jwk(){ return this.export('jwk'); }\n\n  /**\n   * Returns the 'EC' key in Octet SEC1 format.\n   * @return {Promise<OctetEC>}\n   */\n  get oct(){ return this.export('oct', {output: 'string'});  }\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/key.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 103,
    "kind": "class",
    "name": "Key",
    "memberof": "packages/js-crypto-key-utils/src/key.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/key.js",
    "importStyle": "{Key}",
    "description": "Key class to abstract public and private key objects in string or binary.\n  This class provides functions to interchangeably convert key formats,\n  and key objects will be used for the root package, js-crypto-utils, as inputs to exposed APIs.",
    "lineNumber": 15,
    "interface": false
  },
  {
    "__docId__": 104,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "Key format: 'jwk', 'der', 'pem' or 'oct' (only for ECC key)."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey",
          "PEM",
          "DER",
          "OctetEC"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key object in the specified format."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Required if format='oct', and then it is {namedCurve: String}."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if the input format and key are incompatible to the constructor."
      }
    ]
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "_jwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_jwk",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "_der",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_der",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_oct",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_oct",
    "access": "private",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_current",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_current",
    "access": "private",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "{\"jwk\": *, \"der\": *, \"oct\": *}"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "_setJwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setJwk",
    "access": "private",
    "description": "Set a key in JWK to the Key object.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "The Json Web Key."
      }
    ],
    "return": null
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_type",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_type",
    "access": "private",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "_isEncrypted",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_isEncrypted",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "_setAsn1",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setAsn1",
    "access": "private",
    "description": "Set a key in DER or PEM to the Key object.",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER",
          "PEM"
        ],
        "spread": false,
        "optional": false,
        "name": "asn1key",
        "description": "The DER key byte array or PEM key string."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "'der' or 'pem' specifying the format."
      }
    ],
    "return": null
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "_setSec1",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setSec1",
    "access": "private",
    "description": "Set a key in SEC1 = Octet format to the Key Object.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "OctetEC"
        ],
        "spread": false,
        "optional": false,
        "name": "sec1key",
        "description": "The Octet SEC1 key byte array."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of curve like 'P-256'."
      }
    ],
    "return": null
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "_setCurrentStatus",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#_setCurrentStatus",
    "access": "private",
    "description": "Set the current internal status. In particular, manage what the object is based on.",
    "lineNumber": 99,
    "params": [],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "export",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#export",
    "access": "public",
    "description": "Convert the stored key and export the key in desired format.\nImported key must be basically decrypted except the case where the key is exported as-is.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "Intended format of exported key. 'jwk', 'pem', 'der' or 'oct'"
      },
      {
        "nullable": null,
        "types": [
          "KeyExportOptions"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Optional arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<JsonWebKey|PEM|DER|OctetEC>"
      ],
      "spread": false,
      "description": "Exported key object."
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "encrypt",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#encrypt",
    "access": "public",
    "description": "Encrypt stored key and set the encrypted key to this instance.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "String passphrase."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Always true otherwise thrown."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if AlreadyEncrypted."
      }
    ]
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "decrypt",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#decrypt",
    "access": "public",
    "description": "Decrypted stored key and set the decrypted key in JWK to this instance.",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "String passphrase."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Always true otherwise thrown."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotEncrypted or FailedToDecrypt."
      }
    ]
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getJwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#getJwkThumbprint",
    "access": "public",
    "description": "Conpute JWK thumbprint specified in RFC7638 {@link https://tools.ietf.org/html/rfc7638}.",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "alg",
        "description": "Name of hash algorithm for thumbprint computation like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "JwkThumbpirntFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'binary'",
        "defaultRaw": "'binary'",
        "name": "output",
        "description": "Output format of JWK thumbprint. 'binary', 'hex' or 'base64'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array|String>"
      ],
      "spread": false,
      "description": "Computed thumbprint."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if DecryptionRequired."
      }
    ]
  },
  {
    "__docId__": 130,
    "kind": "get",
    "name": "keyType",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#keyType",
    "access": "public",
    "description": "Get keyType in JWK format",
    "lineNumber": 223,
    "return": {
      "nullable": null,
      "types": [
        "Promise<String>"
      ],
      "spread": false,
      "description": "'RSA' or 'EC'"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if DecryptionRequired."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "get",
    "name": "jwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#jwkThumbprint",
    "access": "public",
    "description": "Get jwkThumbprint of this key.",
    "lineNumber": 235,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Returns binary thumbprint."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "get",
    "name": "isEncrypted",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#isEncrypted",
    "access": "public",
    "description": "Check if this is encrypted.",
    "lineNumber": 243,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "get",
    "name": "isPrivate",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#isPrivate",
    "access": "public",
    "description": "Check if this is a private key.",
    "lineNumber": 249,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "get",
    "name": "der",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#der",
    "access": "public",
    "description": "Returns the key in DER format.",
    "lineNumber": 255,
    "return": {
      "nullable": null,
      "types": [
        "Promise<DER>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "get",
    "name": "pem",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#pem",
    "access": "public",
    "description": "Returns the key in PEM format.",
    "lineNumber": 261,
    "return": {
      "nullable": null,
      "types": [
        "Promise<PEM>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "get",
    "name": "jwk",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#jwk",
    "access": "public",
    "description": "Returns the key in JWK format",
    "lineNumber": 267,
    "return": {
      "nullable": null,
      "types": [
        "Promise<JsonWebKey>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "get",
    "name": "oct",
    "memberof": "packages/js-crypto-key-utils/src/key.js~Key",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/js-crypto-key-utils/src/key.js~Key#oct",
    "access": "public",
    "description": "Returns the 'EC' key in Octet SEC1 format.",
    "lineNumber": 273,
    "return": {
      "nullable": null,
      "types": [
        "Promise<OctetEC>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/octenc.js",
    "content": "/**\n * octenc.js\n */\n\nimport params from './params.js';\nimport jseu from 'js-encoding-utils';\nimport elliptic from 'elliptic';\nimport {getJwkType, getSec1KeyType} from './util.js';\nconst Ec = elliptic.ec;\n\n\n/**\n * Convert JWK EC public/private keys to octet form.\n * Compressed form of EC public key is referred to RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.\n * @param {JsonWebKey} jwkey - A key object in JWK format to be encoded to SEC1 octet format key.\n * @param {boolean} [outputPublic] - Export public key even from private key if true.\n * @param {OctetFormat} [outputFormat='binary'] - 'binary' or 'string'.\n * @param {boolean} [compact=false] - Export compressed form of public key if true.\n * @return {JsonWebKey} - Encoded key object in JWK format.\n */\nexport function fromJwk(jwkey, {outputPublic, outputFormat='binary', compact=false}){\n  // original key type\n  const orgType = getJwkType(jwkey);\n  const type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  if(type === 'public'){\n    const bufX = jseu.encoder.decodeBase64Url(jwkey.x);\n    const bufY = jseu.encoder.decodeBase64Url(jwkey.y);\n\n    let publicKey;\n    if(compact){\n      // compressed form\n      // http://www.secg.org/SEC1-Ver-1.0.pdf\n      publicKey = new Uint8Array(bufX.length + 1);\n      publicKey[0] = 0xFF & ( (0x01 & bufY.slice(-1)[0]) + 0x02 );\n      publicKey.set(bufX, 1);\n    }\n    else {\n      // uncompressed form\n      publicKey = new Uint8Array(bufX.length + bufY.length + 1);\n      publicKey[0]=0xFF & 0x04;\n      publicKey.set(bufX, 1);\n      publicKey.set(bufY, bufX.length+1);\n    }\n    return (outputFormat === 'string') ? jseu.encoder.arrayBufferToHexString(publicKey): publicKey;\n  }\n  else if (type === 'private'){\n    if (!jwkey.d) throw new Error('InvalidKey');\n    const bufD = jseu.encoder.decodeBase64Url(jwkey.d);\n    return (outputFormat === 'string') ? jseu.encoder.arrayBufferToHexString(bufD) : bufD;\n  }\n}\n\n/**\n * Convert Octet form of EC public/private keys to JWK.\n * @param {String|Uint8Array} octkey - OctetEC key object in hex string format or Uint8Array.\n * @param {String} namedCurve - Name of elliptic curve like 'P-256'.\n * @param {boolean} [outputPublic] - Export public key even from private key if true.\n * @return {JsonWebKey} - Derived key object in JWK format.\n */\nexport function toJwk(octkey, namedCurve, {outputPublic}){\n  if (Object.keys(params.namedCurves).indexOf(namedCurve) < 0) throw new Error('UnsupportedCurve');\n\n  // original key type and check the key structure\n  const orgType = getSec1KeyType(octkey, namedCurve);\n  const type = (typeof outputPublic === 'boolean' && outputPublic) ? 'public' : orgType;\n\n  // format conversion\n  const binKey = (typeof octkey === 'string') ? jseu.encoder.hexStringToArrayBuffer(octkey): octkey;\n\n  // instantiation\n  const curve = params.namedCurves[namedCurve].indutnyName;\n  const ec = new Ec(curve);\n\n  // derive key object from binary key\n  const ecKey = (orgType === 'public') ? ec.keyFromPublic(binKey): ec.keyFromPrivate(binKey);\n  const publicKey = new Uint8Array(ecKey.getPublic('array'));\n  const len = params.namedCurves[namedCurve].payloadSize;\n\n  const bufX = publicKey.slice(1, len+1);\n  const bufY = publicKey.slice(len+1, len*2+1);\n\n  const jwKey = { // https://www.rfc-editor.org/rfc/rfc7518.txt\n    kty: 'EC',\n    crv: namedCurve,\n    x: jseu.encoder.encodeBase64Url(bufX), // oct to base64url\n    y: jseu.encoder.encodeBase64Url(bufY)\n    // ext: true\n  };\n\n  if(type === 'private'){\n    // octkey is exactly private key if type is private.\n    jwKey.d = jseu.encoder.encodeBase64Url(binKey);\n  }\n  return jwKey;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/octenc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "Ec",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~Ec",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{fromJwk}",
    "description": "Convert JWK EC public/private keys to octet form.\nCompressed form of EC public key is referred to RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "A key object in JWK format to be encoded to SEC1 octet format key."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "outputPublic",
        "description": "Export public key even from private key if true."
      },
      {
        "nullable": null,
        "types": [
          "OctetFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'binary'",
        "defaultRaw": "'binary'",
        "name": "outputFormat",
        "description": "'binary' or 'string'."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "compact",
        "description": "Export compressed form of public key if true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Encoded key object in JWK format."
    }
  },
  {
    "__docId__": 141,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-crypto-key-utils/src/octenc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/octenc.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/octenc.js",
    "importStyle": "{toJwk}",
    "description": "Convert Octet form of EC public/private keys to JWK.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "octkey",
        "description": "OctetEC key object in hex string format or Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of elliptic curve like 'P-256'."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "outputPublic",
        "description": "Export public key even from private key if true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsonWebKey"
      ],
      "spread": false,
      "description": "Derived key object in JWK format."
    }
  },
  {
    "__docId__": 142,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  // oid is referred to rfc5480 https://www.ietf.org/rfc/rfc5480.txt\n  namedCurves: {\n    'P-256': {indutnyName: 'p256', payloadSize: 32, oid: [1, 2, 840, 10045, 3, 1, 7]},\n    'P-384': {indutnyName: 'p384', payloadSize: 48, oid: [1, 3, 132, 0, 34]},\n    'P-521': {indutnyName: 'p521', payloadSize: 66, oid: [1, 3, 132, 0, 35]},\n    'P-256K': {indutnyName: 'secp256k1', payloadSize: 32, oid: [1, 3, 132, 0, 10]},\n  },\n\n  // https://tools.ietf.org/html/rfc3279\n  publicKeyAlgorithms: {\n    'EC': {oid: [1, 2, 840, 10045, 2, 1]},\n    'RSA': {oid: [1, 2, 840, 113549, 1, 1, 1]}\n  },\n\n  passwordBasedEncryptionSchemes: {\n    // PBES1\n    'pbeWithMD5AndDES-CBC': {oid: [1, 2, 840, 113549, 1, 5, 3 ], hash: 'MD5', encrypt: 'DES-CBC'},\n    'pbeWithSHA1AndDES-CBC': {oid: [1, 2, 840, 113549, 1, 5, 10 ], hash: 'SHA-1', encrypt: 'DES-CBC'},\n\n    // PBES2\n    'pbes2': {oid:  [ 1, 2, 840, 113549, 1, 5, 13 ]}\n  },\n\n  keyDerivationFunctions: {\n    'pbkdf2': {oid: [ 1, 2, 840, 113549, 1, 5, 12 ], defaultSaltLen: 8}\n  },\n\n  pbkdf2Prfs: {\n    'hmacWithSHA1': {oid: [1, 2, 840, 113549, 2, 7], hash: 'SHA-1'},\n    'hmacWithSHA256': {oid: [1, 2, 840, 113549, 2, 9], hash: 'SHA-256'},\n    'hmacWithSHA384': {oid: [1, 2, 840, 113549, 2, 10], hash: 'SHA-384'},\n    'hmacWithSHA512': {oid: [1, 2, 840, 113549, 2, 11], hash: 'SHA-512'}\n  },\n\n  encryptionSchemes: {\n    'des-ede3-cbc': {oid: [ 1, 2, 840, 113549, 3, 7 ], keyLength: 24, ivLength: 8},\n    'aes128-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 2 ], keyLength: 16, ivLength: 16},\n    'aes192-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 22 ], keyLength: 24, ivLength: 16},\n    'aes256-cbc': {oid: [ 2, 16, 840, 1, 101, 3, 4, 1, 42 ], keyLength: 32, ivLength: 16}\n  },\n\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20}, // SHOULD NOT USE\n    'MD5': {hashSize: 16} // SHOULD NOT USE\n  }\n};\n\n/**\n * Get algorithm name from ObjectIdentifier array loosely.\n * @param {Array} oid - ObjectIdentifier.\n * @param {Object} oidDict - Dictionary of ObjectIdentifier.\n * @return {Array} - Array of ObjectIdentifier array.\n */\nexport function getAlgorithmFromOid(oid, oidDict){\n  return Object.keys(oidDict).filter( (k) => oidDict[k].oid.toString() === oid.toString());\n}\n\n/**\n * Get algorithm name from ObjectIdentifier array strictly.\n * @param {Array} oid - ObjectIdentifier.\n * @param {Object} dict - Dictionary of ObjectIdentifier.\n * @return {Array} - Exactly one ObjectIdentifier.\n * @throws {Error} - Throws if UnsupportedAlgorithm.\n */\nexport const getAlgorithmFromOidStrict = (oid, dict) => {\n  const array = getAlgorithmFromOid(oid, dict);\n  if (array.length === 0) throw new Error('UnsupportedAlgorithm');\n  return array[0];\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 143,
    "kind": "function",
    "name": "getAlgorithmFromOid",
    "memberof": "packages/js-crypto-key-utils/src/params.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/params.js~getAlgorithmFromOid",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/params.js",
    "importStyle": "{getAlgorithmFromOid}",
    "description": "Get algorithm name from ObjectIdentifier array loosely.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "oid",
        "description": "ObjectIdentifier."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "oidDict",
        "description": "Dictionary of ObjectIdentifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Array of ObjectIdentifier array."
    }
  },
  {
    "__docId__": 144,
    "kind": "function",
    "name": "getAlgorithmFromOidStrict",
    "memberof": "packages/js-crypto-key-utils/src/params.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/params.js~getAlgorithmFromOidStrict",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/params.js",
    "importStyle": "{getAlgorithmFromOidStrict}",
    "description": "Get algorithm name from ObjectIdentifier array strictly.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "oid",
        "description": "ObjectIdentifier."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "dict",
        "description": "Dictionary of ObjectIdentifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Exactly one ObjectIdentifier."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedAlgorithm."
      }
    ]
  },
  {
    "__docId__": 145,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/rfc8018.js",
    "content": "/**\n * rfc8081\n */\n\nimport params, {getAlgorithmFromOidStrict} from './params.js';\nimport {PBES2ESParams, PBEParameter, PBES2Params, PBKDF2Params, OneAsymmetricKey, EncryptedPrivateKeyInfo} from './asn1def.js';\nimport des from 'des.js';\nimport BufferMod from 'buffer';\nimport asn from 'asn1.js';\nimport jseu from 'js-encoding-utils';\nimport pbkdf from 'js-crypto-pbkdf';\nimport jscaes from 'js-crypto-aes';\nimport jscrandom from 'js-crypto-random';\nconst Buffer = BufferMod.Buffer;\nconst BN = asn.bignum;\n\n///////////////////////////////////////////////////////////////////\n/**\n * Generate EncryptedPrivateKeyInfo ASN.1 object.\n * @param {DER} binKey - Binary key in DER format.\n * @param {AsnEncryptOptionsWithPassphrase} [options={passphrase: ''}] - Encryption options for ASN.1 private key.\n * @return {Promise<DER>} - Encrypted private key in DER.\n */\nexport async function encryptEncryptedPrivateKeyInfo(binKey, options = {passphrase:''}){\n  // default params\n  if(typeof options.algorithm === 'undefined') options.algorithm = 'pbes2';\n  if(typeof options.iterationCount === 'undefined') options.iterationCount = 2048;\n\n\n  if (options.algorithm === 'pbes2') {\n    if(typeof options.cipher === 'undefined') options.cipher = 'aes256-cbc';\n    if(typeof options.prf === 'undefined') options.prf = 'hmacWithSHA256';\n    const kdfAlgorithm = 'pbkdf2'; // TODO: currently only pbkdf2 is available\n\n    const encryptedPBES2 = await encryptPBES2(binKey, options.passphrase, kdfAlgorithm, options.prf, options.iterationCount, options.cipher);\n    return await encodePBES2(encryptedPBES2);\n  }\n  else {\n    const encryptedPBES1 = await encryptPBES1(binKey, options.passphrase, options.algorithm, options.iterationCount);\n    encryptedPBES1.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[encryptedPBES1.encryptionAlgorithm.algorithm].oid;\n    encryptedPBES1.encryptionAlgorithm.parameters = PBEParameter.encode(encryptedPBES1.encryptionAlgorithm.parameters, 'der');\n    return EncryptedPrivateKeyInfo.encode(encryptedPBES1, 'der');\n  }\n}\n\n/**\n * Decrypt EncryptedPrivateKeyInfo\n * @param {Object} epki - Parsed encrypted\n * @param {String} passphrase - Passphrase to decyrpt the object.\n * @return {Promise<Object>} - Decrypted object.\n */\nexport async function decryptEncryptedPrivateKeyInfo(epki, passphrase){\n  const decoded = {};\n\n  // encryptionAlgorithm.algorithm\n  decoded.encryptionAlgorithm = {\n    algorithm: getAlgorithmFromOidStrict(epki.encryptionAlgorithm.algorithm, params.passwordBasedEncryptionSchemes)\n  };\n  if (decoded.encryptionAlgorithm.algorithm === 'pbes2') {\n    decoded.encryptionAlgorithm.parameters = decodePBES2(epki.encryptionAlgorithm.parameters);\n  }\n  else {\n    decoded.encryptionAlgorithm.parameters = PBEParameter.decode(epki.encryptionAlgorithm.parameters, 'der');\n  }\n\n  decoded.encryptedData = epki.encryptedData;\n\n  // decrypt\n  if(decoded.encryptionAlgorithm.algorithm === 'pbes2') {\n    return await decryptPBES2(decoded, passphrase);\n  }\n  else return await decryptPBES1(decoded, passphrase);\n}\n\n//////////////////////////////\nfunction encodePBES2(decoded){\n  const epki = { encryptionAlgorithm: {} };\n\n  // algorithm\n  epki.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].oid;\n\n  // kdf\n  const kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;\n  if(kdf.algorithm === 'pbkdf2') {\n    kdf.parameters.prf.algorithm = params.pbkdf2Prfs[kdf.parameters.prf.algorithm].oid;\n    kdf.parameters = PBKDF2Params.encode(kdf.parameters, 'der');\n  } else throw new Error('UnsupportedKDF');\n  kdf.algorithm = params.keyDerivationFunctions[kdf.algorithm].oid;\n\n  // encryptionScheme\n  const eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;\n  if(Object.keys(PBES2ESParams).indexOf(eS.algorithm) >= 0){\n    eS.parameters = PBES2ESParams[eS.algorithm].encode(eS.parameters, 'der');\n  } else throw new Error('UnsupportedCipher');\n  eS.algorithm = params.encryptionSchemes[eS.algorithm].oid;\n\n  // params\n  epki.encryptionAlgorithm.parameters = PBES2Params.encode({ keyDerivationFunc: kdf, encryptionScheme: eS }, 'der');\n\n  // encoded data\n  epki.encryptedData = decoded.encryptedData;\n  return EncryptedPrivateKeyInfo.encode(epki, 'der');\n}\n\nfunction decodePBES2(rawParams){\n  const pbes2Params = PBES2Params.decode(rawParams, 'der');\n\n  // keyDerivationFunc\n  const kdfAlgorithm = getAlgorithmFromOidStrict(pbes2Params.keyDerivationFunc.algorithm, params.keyDerivationFunctions);\n\n  let iterationCount;\n  let salt;\n  let prf;\n  if (kdfAlgorithm === 'pbkdf2') {\n    const pbkdf2Params = PBKDF2Params.decode(pbes2Params.keyDerivationFunc.parameters, 'der');\n    prf = {\n      algorithm: getAlgorithmFromOidStrict(pbkdf2Params.prf.algorithm, params.pbkdf2Prfs),\n      parameters: pbkdf2Params.prf.parameters\n    };\n    iterationCount = pbkdf2Params.iterationCount;\n    salt = {type: pbkdf2Params.salt.type, value: pbkdf2Params.salt.value};\n  } else throw new Error('UnsupportedKDF');\n\n  //encryptionScheme\n  const encryptionScheme = getAlgorithmFromOidStrict(pbes2Params.encryptionScheme.algorithm, params.encryptionSchemes);\n  let encryptionParams;\n  if(Object.keys(PBES2ESParams).indexOf(encryptionScheme) >= 0){\n    encryptionParams = PBES2ESParams[encryptionScheme].decode(pbes2Params.encryptionScheme.parameters, 'der');\n  } else throw new Error('UnsupportedCipher'); // TODO: Other Encryption Scheme\n\n  return {\n    keyDerivationFunc: {\n      algorithm: kdfAlgorithm,\n      parameters: { salt, iterationCount, prf }\n    },\n    encryptionScheme: {\n      algorithm: encryptionScheme,\n      parameters: encryptionParams\n    }\n  };\n}\n\n\n//////////////////////\n// PBES2 RFC8018 Section 6.2.1\nasync function encryptPBES2(binKey, passphrase, kdfAlgorithm, prf, iterationCount, cipher){\n  // kdf\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = await jscrandom.getRandomBytes(\n    params.keyDerivationFunctions[kdfAlgorithm].defaultSaltLen\n  ); // TODO: currently only salt length of 8 is available\n  const keyLength = params.encryptionSchemes[cipher].keyLength; // get keyLength\n\n  let key;\n  if (kdfAlgorithm === 'pbkdf2') {\n    key = await pbkdf.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash);\n  } else throw new Error('UnsupportedKDF');\n\n  // encrypt\n  let iv;\n  let encryptedData;\n  if (cipher === 'des-ede3-cbc') { // TODO other encryption schemes\n    iv = Buffer.from(await jscrandom.getRandomBytes(params.encryptionSchemes[cipher].ivLength));\n    const CBC = des.CBC.instantiate(des.EDE);\n    const ct = CBC.create({ type: 'encrypt', key: Buffer.from(key), iv });\n    encryptedData = Buffer.from(ct.update(binKey).concat(ct.final()));\n  }\n  else if (cipher === 'aes128-cbc' || cipher === 'aes192-cbc' || cipher === 'aes256-cbc'){\n    iv = await jscrandom.getRandomBytes(params.encryptionSchemes[cipher].ivLength);\n    encryptedData = Buffer.from( await jscaes.encrypt(\n      new Uint8Array(binKey), key, {name: 'AES-CBC', iv}\n    ));\n    iv = Buffer.from(iv);\n  } else throw new Error('UnsupportedCipher');\n\n  // structure\n  return {\n    encryptedData,\n    encryptionAlgorithm: {\n      algorithm: 'pbes2',\n      parameters: {\n        keyDerivationFunc: {\n          algorithm: kdfAlgorithm,\n          parameters: {\n            salt: {type: 'specified', value: Buffer.from(salt)},\n            iterationCount: new BN(iterationCount),\n            prf: {algorithm: prf, parameters: Buffer.from([0x05, 0x00])}\n          }\n        },\n        encryptionScheme: { algorithm: cipher, parameters: iv }\n      }\n    }\n  };\n}\n\n//////////////////////////////\n// PBES2 RFC8018 Section 6.2.2\nasync function decryptPBES2(decoded, passphrase){\n  const kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;\n  const eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;\n\n  // pbkdf2\n  const keyLength = params.encryptionSchemes[eS.algorithm].keyLength; // get keyLength\n  let key;\n  if(kdf.algorithm === 'pbkdf2') {\n    const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n    if (kdf.parameters.salt.type !== 'specified') throw new Error('UnsupportedSaltSource');\n    const salt = new Uint8Array(kdf.parameters.salt.value);\n    const iterationCount = kdf.parameters.iterationCount.toNumber();\n    const prf = kdf.parameters.prf.algorithm;\n    key = await pbkdf.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash);\n  }\n  else throw new Error('UnsupportedKDF');\n\n  // decryption\n  // TODO other encryption schemes\n  let out;\n  if(eS.algorithm === 'des-ede3-cbc'){\n    const iv = eS.parameters;\n    const CBC = des.CBC.instantiate(des.EDE);\n    const pt = CBC.create({ type: 'decrypt', key, iv });\n    out = Buffer.from(pt.update(decoded.encryptedData).concat(pt.final()));\n  }\n  else if (eS.algorithm === 'aes128-cbc' || eS.algorithm === 'aes192-cbc'|| eS.algorithm === 'aes256-cbc'){\n    const iv = new Uint8Array(eS.parameters);\n    out = Buffer.from( await jscaes.decrypt(\n      new Uint8Array(decoded.encryptedData), key, {name: 'AES-CBC', iv}\n    ));\n  } else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return OneAsymmetricKey.decode(out, 'der');\n}\n\n//////////////////////////////\n// PBES1 RFC8018 Section 6.1.1\nasync function encryptPBES1(binKey, passphrase, algorithm, iterationCount){\n  // pbkdf1\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = await jscrandom.getRandomBytes(8); // defined as 8 octet\n  const hash = params.passwordBasedEncryptionSchemes[algorithm].hash;\n  const keyIv = await pbkdf.pbkdf1(pBuffer, salt, iterationCount, 16, hash);\n  const key = keyIv.slice(0, 8);\n  const iv = keyIv.slice(8, 16);\n\n  // decryption\n  const encrypt = params.passwordBasedEncryptionSchemes[algorithm].encrypt;\n  let out;\n  // TODO: Other Encryption Scheme\n  if(encrypt === 'DES-CBC') {\n    const CBC = des.CBC.instantiate(des.DES);\n    const ct = CBC.create({type: 'encrypt', key, iv});\n    out = Buffer.from(ct.update(binKey).concat(ct.final()));\n  }\n  else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return {\n    encryptionAlgorithm: {\n      algorithm,\n      parameters: {\n        salt: Buffer.from(salt),\n        iterationCount: new BN(iterationCount)\n      }\n    },\n    encryptedData: out\n  };\n}\n\n//////////////////////////////\n// PBES1 RFC8018 Section 6.1.2\nasync function decryptPBES1(decoded, passphrase){\n  // pbkdf1\n  const pBuffer = jseu.encoder.stringToArrayBuffer(passphrase);\n  const salt = new Uint8Array(decoded.encryptionAlgorithm.parameters.salt);\n  const hash = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].hash;\n  const iterationCount = decoded.encryptionAlgorithm.parameters.iterationCount.toNumber();\n  const keyIv = await pbkdf.pbkdf1(pBuffer, salt, iterationCount, 16, hash);\n  const key = keyIv.slice(0, 8);\n  const iv = keyIv.slice(8, 16);\n\n  // decryption\n  const encrypt = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].encrypt;\n  let out;\n  // TODO: Other Encryption Scheme\n  if(encrypt === 'DES-CBC') {\n    const CBC = des.CBC.instantiate(des.DES);\n    const ct = CBC.create({type: 'decrypt', key, iv});\n    out = Buffer.from(ct.update(decoded.encryptedData).concat(ct.final()));\n  }\n  else throw new Error('UnsupportedEncryptionAlgorithm');\n\n  return OneAsymmetricKey.decode(out, 'der');\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/rfc8018.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 146,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "encryptEncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptEncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": "{encryptEncryptedPrivateKeyInfo}",
    "description": "Generate EncryptedPrivateKeyInfo ASN.1 object.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER"
        ],
        "spread": false,
        "optional": false,
        "name": "binKey",
        "description": "Binary key in DER format."
      },
      {
        "nullable": null,
        "types": [
          "AsnEncryptOptionsWithPassphrase"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{passphrase: ''}",
        "defaultRaw": "{passphrase: ''}",
        "name": "options",
        "description": "Encryption options for ASN.1 private key."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DER>"
      ],
      "spread": false,
      "description": "Encrypted private key in DER."
    }
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "decryptEncryptedPrivateKeyInfo",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptEncryptedPrivateKeyInfo",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": "{decryptEncryptedPrivateKeyInfo}",
    "description": "Decrypt EncryptedPrivateKeyInfo",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "epki",
        "description": "Parsed encrypted"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "Passphrase to decyrpt the object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": "Decrypted object."
    }
  },
  {
    "__docId__": 150,
    "kind": "function",
    "name": "encodePBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encodePBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "decodePBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decodePBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "rawParams",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"keyDerivationFunc\": *, \"encryptionScheme\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "function",
    "name": "encryptPBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptPBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "params": [
      {
        "name": "binKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      },
      {
        "name": "kdfAlgorithm",
        "types": [
          "*"
        ]
      },
      {
        "name": "prf",
        "types": [
          "*"
        ]
      },
      {
        "name": "iterationCount",
        "types": [
          "*"
        ]
      },
      {
        "name": "cipher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"encryptedData\": *, \"encryptionAlgorithm\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "decryptPBES2",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptPBES2",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 154,
    "kind": "function",
    "name": "encryptPBES1",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~encryptPBES1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "params": [
      {
        "name": "binKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      },
      {
        "name": "algorithm",
        "types": [
          "*"
        ]
      },
      {
        "name": "iterationCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"encryptionAlgorithm\": *, \"encryptedData\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "function",
    "name": "decryptPBES1",
    "memberof": "packages/js-crypto-key-utils/src/rfc8018.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/rfc8018.js~decryptPBES1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/rfc8018.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "params": [
      {
        "name": "decoded",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/thumbprint.js",
    "content": "/**\n * thumbprint.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport hash from 'js-crypto-hash';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Compute JWK public key thumbprint specified in RFC7638\n * https://tools.ietf.org/html/rfc7638\n * @param {JsonWebKey} jwkey - A key object in JWK format\n * @param {String} [alg='SHA-256'] - Name of hash algorithm to compute the thumbprint.\n * @param {JwkThumbpirntFormat} [output='binary'] - Output format, 'binary', 'hex' or 'base64'\n * @return {Promise<String|Uint8Array>} - The computed JWK thumbprint.\n */\nexport async function getJwkThumbprint(jwkey, alg='SHA-256', output='binary'){\n  // assertion\n  if(['hex', 'binary'].indexOf(output) < 0) throw new Error('UnsupportedOutputFormat');\n\n  let jsonString;\n  if(jwkey.kty === 'EC'){\n    jsonString = JSON.stringify({crv: jwkey.crv, kty: jwkey.kty, x: jwkey.x, y: jwkey.y});\n  }\n  else if (jwkey.kty === 'RSA'){\n    jsonString = JSON.stringify({e: jwkey.e, kty: jwkey.kty, n: jwkey.n});\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  const uint8json = new Uint8Array(Buffer.from(jsonString, 'utf8'));\n  const thumbPrintBuf = await hash.compute(uint8json, alg);\n\n  if(output === 'hex') return jseu.encoder.arrayBufferToHexString(thumbPrintBuf);\n  else if(output === 'base64') return jseu.encoder.encodeBase64(thumbPrintBuf);\n  else if (output === 'binary') return thumbPrintBuf;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/thumbprint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 157,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-crypto-key-utils/src/thumbprint.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/thumbprint.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-key-utils/src/thumbprint.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "function",
    "name": "getJwkThumbprint",
    "memberof": "packages/js-crypto-key-utils/src/thumbprint.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/thumbprint.js~getJwkThumbprint",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/thumbprint.js",
    "importStyle": "{getJwkThumbprint}",
    "description": "Compute JWK public key thumbprint specified in RFC7638\nhttps://tools.ietf.org/html/rfc7638",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "A key object in JWK format"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "alg",
        "description": "Name of hash algorithm to compute the thumbprint."
      },
      {
        "nullable": null,
        "types": [
          "JwkThumbpirntFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'binary'",
        "defaultRaw": "'binary'",
        "name": "output",
        "description": "Output format, 'binary', 'hex' or 'base64'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String|Uint8Array>"
      ],
      "spread": false,
      "description": "The computed JWK thumbprint."
    }
  },
  {
    "__docId__": 159,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/typedef.js",
    "content": "/**\n * @typedef {String} PEM - ASN.1 encoded key in PEM format.\n */\n\n/**\n * @typedef {Uint8Array|Buffer} DER - ASN.1 encoded key in DER format.\n */\n\n/**\n * @typedef {Uint8Array|Buffer|String} OctetEC - SEC1 Octet form EC key.\n */\n\n/**\n * @typedef {Object} KeyExportOptions - Export options for Key Class.\n * @property {boolean} [outputPublic] - Derive public key from private key if true.\n * @property {boolean} [compact] - Generate compressed EC public key when format = 'der', 'pem' or 'oct', only for EC key if true.\n * @property {OctetFormat} [output='binary'] - Active only for OctetEC key. 'binary' or 'string'. Default value would be 'binary'.\n * @property {AsnEncryptOptionsWithPassphrase} [encryptParams] - Generate encrypted der/pem private key when format = 'der' or 'pem'.\n */\n\n/**\n * @typedef {Object} JwkExportOptionsInternal - Options for converters to JWK.\n * @property {String} [namedCurve] - Name of curve used for EC keys.\n * @property {boolean} [outputPublic] - Export public key even from private key if true.\n * @property {String} [passphrase] - Encrypt private key if this is given.\n */\n\n/**\n * @typedef {Object} AsnEncryptOptionsWithPassphrase - Encryption options for exported key in key Class.\n * @property {String} passphrase - (Re-)generate encrypted der/pem with the given passphrase\n * @property {String} [algorithm='pbes2'] - 'pbes2' (default), 'pbeWithMD5AndDES-CBC' or 'pbeWithSHA1AndDES'\n * @property {String} [prf='hmacWithSHA256] - 'hmacWithSHA256' (default), 'hmacWithSHA384', 'hmacWithSHA512' or 'hmacWithSHA1' when if algorithm = 'pbes2'.\n * @property {Number} [iterationCount = 2048] - Iteration count for PBKDF 1/2.\n * @property {String} [cipher='aes256-cbc'] - 'aes256-cbc' (default), 'aes128-cbc' or 'des-ede3-cbc'.\n */\n\n/**\n * @typedef {Entity} AsnObject - asn1.js Entity object.\n */\n\n/**\n * @typedef {'pem'|'der'} AsnFormat - Key format of ASN.1 encoded key object.\n */\n\n\n/**\n * @typedef {'string'|'binary'} OctetFormat - Representation of SEC1 Octet EC key.\n */\n\n/**\n * @typedef {'public'|'private'} PublicOrPrivate - Key type of public or private.\n */\n\n/**\n * @typedef {'binary'|'hex'|'base64'} JwkThumbpirntFormat - Representation of JWK thumbprint.\n */",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 160,
    "kind": "typedef",
    "name": "PEM",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~PEM",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "String"
      ],
      "optional": false,
      "name": "PEM"
    }
  },
  {
    "__docId__": 161,
    "kind": "typedef",
    "name": "DER",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~DER",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "Uint8Array",
        "Buffer"
      ],
      "optional": false,
      "name": "DER"
    }
  },
  {
    "__docId__": 162,
    "kind": "typedef",
    "name": "OctetEC",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~OctetEC",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "Uint8Array",
        "Buffer",
        "String"
      ],
      "optional": false,
      "name": "OctetEC"
    }
  },
  {
    "__docId__": 163,
    "kind": "typedef",
    "name": "KeyExportOptions",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~KeyExportOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "outputPublic",
        "description": "Derive public key from private key if true."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "compact",
        "description": "Generate compressed EC public key when format = 'der', 'pem' or 'oct', only for EC key if true."
      },
      {
        "nullable": null,
        "types": [
          "OctetFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'binary'",
        "defaultRaw": "'binary'",
        "name": "output",
        "description": "Active only for OctetEC key. 'binary' or 'string'. Default value would be 'binary'."
      },
      {
        "nullable": null,
        "types": [
          "AsnEncryptOptionsWithPassphrase"
        ],
        "spread": false,
        "optional": true,
        "name": "encryptParams",
        "description": "Generate encrypted der/pem private key when format = 'der' or 'pem'."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "KeyExportOptions"
    }
  },
  {
    "__docId__": 164,
    "kind": "typedef",
    "name": "JwkExportOptionsInternal",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~JwkExportOptionsInternal",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "namedCurve",
        "description": "Name of curve used for EC keys."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "outputPublic",
        "description": "Export public key even from private key if true."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "passphrase",
        "description": "Encrypt private key if this is given."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "JwkExportOptionsInternal"
    }
  },
  {
    "__docId__": 165,
    "kind": "typedef",
    "name": "AsnEncryptOptionsWithPassphrase",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~AsnEncryptOptionsWithPassphrase",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "(Re-)generate encrypted der/pem with the given passphrase"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'pbes2'",
        "defaultRaw": "'pbes2'",
        "name": "algorithm",
        "description": "'pbes2' (default), 'pbeWithMD5AndDES-CBC' or 'pbeWithSHA1AndDES'"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'hmacWithSHA256",
        "defaultRaw": "'hmacWithSHA256",
        "name": "prf",
        "description": "'hmacWithSHA256' (default), 'hmacWithSHA384', 'hmacWithSHA512' or 'hmacWithSHA1' when if algorithm = 'pbes2'."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 2048",
        "defaultRaw": 2048,
        "name": "iterationCount",
        "description": "Iteration count for PBKDF 1/2."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'aes256-cbc'",
        "defaultRaw": "'aes256-cbc'",
        "name": "cipher",
        "description": "'aes256-cbc' (default), 'aes128-cbc' or 'des-ede3-cbc'."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "AsnEncryptOptionsWithPassphrase"
    }
  },
  {
    "__docId__": 166,
    "kind": "typedef",
    "name": "AsnObject",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~AsnObject",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "Entity"
      ],
      "optional": false,
      "name": "AsnObject"
    }
  },
  {
    "__docId__": 167,
    "kind": "typedef",
    "name": "AsnFormat",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~AsnFormat",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "'pem'",
        "'der'"
      ],
      "optional": false,
      "name": "AsnFormat"
    }
  },
  {
    "__docId__": 168,
    "kind": "typedef",
    "name": "OctetFormat",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~OctetFormat",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "'string'",
        "'binary'"
      ],
      "optional": false,
      "name": "OctetFormat"
    }
  },
  {
    "__docId__": 169,
    "kind": "typedef",
    "name": "PublicOrPrivate",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~PublicOrPrivate",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "'public'",
        "'private'"
      ],
      "optional": false,
      "name": "PublicOrPrivate"
    }
  },
  {
    "__docId__": 170,
    "kind": "typedef",
    "name": "JwkThumbpirntFormat",
    "memberof": "packages/js-crypto-key-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/typedef.js~JwkThumbpirntFormat",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "'binary'",
        "'hex'",
        "'base64'"
      ],
      "optional": false,
      "name": "JwkThumbpirntFormat"
    }
  },
  {
    "__docId__": 171,
    "kind": "file",
    "name": "packages/js-crypto-key-utils/src/util.js",
    "content": "/**\n * util.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport params from './params.js';\nimport {KeyStructure} from './asn1def.js';\n\n/**\n * Check if the given key is encrypted.\n * @param {DER|PEM} key - Private key object in ASN.1 encoding.\n * @param {AsnFormat} [format='pem'] - pem or der\n * @return {boolean} - True if encrypted.\n */\nexport function isAsn1Encrypted(key, format='pem'){\n  let keyType;\n  try{ keyType = getAsn1KeyType(key, format);} catch(e) {return false;}\n  return keyType === 'encryptedPrivate';\n}\n\n/**\n * Check if the given key is public.\n * @param {DER|PEM} key - Public key object in ASN.1 encoding.\n * @param {AsnFormat} format - pem or der\n * @return {boolean} - True if public.\n */\nexport function isAsn1Public(key, format='pem'){\n  let keyType;\n  try{ keyType = getAsn1KeyType(key, format);} catch(e) {return false;}\n  return (keyType === 'public');\n}\n\n/**\n * Retrieve the key type of public or private in ASN.1 format\n * @param {DER|PEM} key - Key object in ASN.1 encoding.\n * @param {AsnFormat} format - pem or der\n * @return {'public'|'private'|'encryptedPrivate'} - The key type of the given key.\n * @throws {Error} - Throws if NotSpkiNorPkcs8Key.\n */\nexport function getAsn1KeyType(key, format='pem'){\n  // Peel the pem strings\n  const binKey = (format === 'pem') ? jseu.formatter.pemToBin(key, 'private') : key;\n\n  const decoded = KeyStructure.decode(Buffer.from(binKey), 'der');\n  if (decoded.type === 'encryptedPrivateKeyInfo') return 'encryptedPrivate';\n  else if (decoded.type === 'oneAsymmetricKey') return 'private';\n  else if (decoded.type === 'subjectPublicKeyInfo') return 'public';\n  else throw new Error('NotSpkiNorPkcs8Key');\n}\n\n/**\n * Retrieve the type of SEC1 octet key.\n * @param {OctetEC} sec1key - Key object in OctetEC encoding in String (hex string) or Uint8Array.\n * @param {String} namedCurve - Name of elliptic curve like 'P-256'.\n * @return {PublicOrPrivate} - public or private\n * @throws {Error} - Throws if UnsupportedKeyStructure.\n */\nexport function getSec1KeyType(sec1key, namedCurve){\n  let format;\n  if (sec1key instanceof Uint8Array) format = 'binary';\n  else if (typeof sec1key === 'string') format = 'string';\n  else throw new Error('InvalidObjectType');\n\n  const binKey = (format === 'string') ? jseu.encoder.hexStringToArrayBuffer(sec1key): sec1key;\n\n  const len = params.namedCurves[namedCurve].payloadSize;\n\n  // original key type\n  if (binKey.length <= len) return 'private';\n  else if (\n    (binKey.length === 2*len+1 && binKey[0] === 0x04)\n    || (binKey.length === len+1 && (binKey[0] === 0x02 || binKey[0] === 0x03))\n  ) return 'public';\n  else throw new Error('UnsupportedKeyStructure');\n}\n\n/**\n * Check key type of JWK.\n * @param {JsonWebKey} jwkey - Key object in JWK format.\n * @return {PublicOrPrivate} - public or private\n * @throws {Error} - Throws if InvalidECKey, InvalidRSAKey or UnsupportedJWKType.\n */\nexport function getJwkType(jwkey){\n  if(jwkey.kty === 'EC'){\n    if (jwkey.x && jwkey.y && jwkey.d) return 'private';\n    else if (jwkey.x && jwkey.y) return 'public';\n    else throw new Error('InvalidECKey');\n  }\n  else if (jwkey.kty === 'RSA'){\n    if (jwkey.n && jwkey.e && jwkey.d && jwkey.p && jwkey.q && jwkey.dp && jwkey.dq && jwkey.qi) return 'private';\n    else if (jwkey.n && jwkey.e) return 'public';\n    else throw new Error('InvalidRSAKey');\n  }\n  else throw new Error('UnsupportedJWKType');\n}\n\n/**\n * Prune leading zeros of an octet sequence in Uint8Array for jwk formatting of RSA.\n * https://tools.ietf.org/html/rfc7518#section-6.3\n * @param {Uint8Array} array - The octet sequence.\n * @return {Uint8Array} - An octet sequence pruned leading zeros of length equal to or shorter than the input array.\n * @throws {Error} - Throws if NonUint8Array.\n */\nexport function pruneLeadingZeros(array){\n  if(!(array instanceof Uint8Array)) throw new Error('NonUint8Array');\n\n  let offset = 0;\n  for (let i = 0; i < array.length; i++){\n    if(array[i] !== 0x00) break;\n    offset++;\n  }\n\n  const returnArray = new Uint8Array(array.length - offset);\n  returnArray.set(array.slice(offset, array.length));\n  return returnArray;\n}\n\n// for pem/oct/der formatting from jwk of RSA\n/**\n * Append leading zeros and generate an octet sequence of fixed length.\n * @param {Uint8Array} array - An octet sequence.\n * @param {Number} len - Intended length of output sequence.\n * @returns {Uint8Array} - An octet sequence with leading zeros.\n * @throws {Error} - Throws if NonUint8Array or InvalidLength.\n */\nexport function appendLeadingZeros(array, len){\n  if(!(array instanceof Uint8Array)) throw new Error('NonUint8Array');\n  if(array.length > len) throw new Error('InvalidLength');\n\n  const returnArray = new Uint8Array(len); // initialized with zeros\n  returnArray.set(array, len - array.length);\n  return returnArray;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 172,
    "kind": "function",
    "name": "isAsn1Encrypted",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~isAsn1Encrypted",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{isAsn1Encrypted}",
    "description": "Check if the given key is encrypted.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER",
          "PEM"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Private key object in ASN.1 encoding."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'pem'",
        "defaultRaw": "'pem'",
        "name": "format",
        "description": "pem or der"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if encrypted."
    }
  },
  {
    "__docId__": 173,
    "kind": "function",
    "name": "isAsn1Public",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~isAsn1Public",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{isAsn1Public}",
    "description": "Check if the given key is public.",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER",
          "PEM"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Public key object in ASN.1 encoding."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "pem or der"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if public."
    }
  },
  {
    "__docId__": 174,
    "kind": "function",
    "name": "getAsn1KeyType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getAsn1KeyType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getAsn1KeyType}",
    "description": "Retrieve the key type of public or private in ASN.1 format",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER",
          "PEM"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key object in ASN.1 encoding."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "pem or der"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "'public'",
        "'private'",
        "'encryptedPrivate'"
      ],
      "spread": false,
      "description": "The key type of the given key."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotSpkiNorPkcs8Key."
      }
    ]
  },
  {
    "__docId__": 175,
    "kind": "function",
    "name": "getSec1KeyType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getSec1KeyType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getSec1KeyType}",
    "description": "Retrieve the type of SEC1 octet key.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "OctetEC"
        ],
        "spread": false,
        "optional": false,
        "name": "sec1key",
        "description": "Key object in OctetEC encoding in String (hex string) or Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "namedCurve",
        "description": "Name of elliptic curve like 'P-256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "PublicOrPrivate"
      ],
      "spread": false,
      "description": "public or private"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedKeyStructure."
      }
    ]
  },
  {
    "__docId__": 176,
    "kind": "function",
    "name": "getJwkType",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~getJwkType",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{getJwkType}",
    "description": "Check key type of JWK.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "Key object in JWK format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "PublicOrPrivate"
      ],
      "spread": false,
      "description": "public or private"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidECKey, InvalidRSAKey or UnsupportedJWKType."
      }
    ]
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "pruneLeadingZeros",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~pruneLeadingZeros",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{pruneLeadingZeros}",
    "description": "Prune leading zeros of an octet sequence in Uint8Array for jwk formatting of RSA.\nhttps://tools.ietf.org/html/rfc7518#section-6.3",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The octet sequence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "An octet sequence pruned leading zeros of length equal to or shorter than the input array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonUint8Array."
      }
    ]
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "appendLeadingZeros",
    "memberof": "packages/js-crypto-key-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-key-utils/src/util.js~appendLeadingZeros",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-key-utils/src/util.js",
    "importStyle": "{appendLeadingZeros}",
    "description": "Append leading zeros and generate an octet sequence of fixed length.",
    "lineNumber": 126,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Uint8Array} - An octet sequence with leading zeros."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "An octet sequence."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Intended length of output sequence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "An octet sequence with leading zeros."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonUint8Array or InvalidLength."
      }
    ]
  },
  {
    "__docId__": 179,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/index.js",
    "content": "/**\n * index.js\n */\nimport {pbkdf2, pbkdf1} from './pbkdf.js';\n\nexport default {pbkdf2, pbkdf1}; // both export and export default needs to be declared for compatibility on node and browser.\nexport {pbkdf2, pbkdf1};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 180,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20}, // SHOULD NOT USE\n    'MD5': {hashSize: 16} // SHOULD NOT USE\n  }\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 181,
    "kind": "file",
    "name": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "content": "/**\n * pbkdf.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport jschash from 'js-crypto-hash';\nimport jschmac from 'js-crypto-hmac';\nimport params from './params.js';\n\n/**\n * Password-based key derivation function 2.\n * Detailed specification is given in RFC8018 Section 5.2 {@link https://tools.ietf.org/html/rfc8018#section-5.2}.\n * @param {Uint8Array|String} p - Byte array or string of password. if string is given, it will be converted to Uint8Array.\n * @param {Uint8Array} s - Byte array of salt.\n * @param {Number} c - Iteration count.\n * @param {Number} dkLen - Intended output key length in octet.\n * @param {String} hash - Name of underlying hash function for HMAC like 'SHA-256', used as a pseudorandom function.\n * @return {Promise<Uint8Array>} - Derived key.\n * @throws {Error} - Throws if the intended key length is too long.\n */\nexport async function pbkdf2(p, s, c, dkLen, hash) {\n  assertPbkdf(p, s, c, dkLen, hash);\n  if(typeof p === 'string') p = jseu.encoder.stringToArrayBuffer(p);\n\n  const hLen = params.hashes[hash].hashSize;\n  if(dkLen > (Math.pow(2, 32) - 1) * hLen) throw new Error('DerivedKeyTooLong');\n\n  const l = Math.ceil(dkLen/hLen);\n  const r = dkLen - (l-1)*hLen;\n\n  const funcF = async (i) => {\n    const seed = new Uint8Array(s.length + 4);\n    seed.set(s);\n    seed.set(nwbo(i+1, 4), s.length);\n    let u = await jschmac.compute(p, seed, hash);\n    let outputF = new Uint8Array(u);\n    for(let j = 1; j < c; j++){\n      u = await jschmac.compute(p, u, hash);\n      outputF = u.map( (elem, idx) => elem ^ outputF[idx]);\n    }\n    return {index: i, value: outputF};\n  };\n  const Tis = [];\n  const DK = new Uint8Array(dkLen);\n  for(let i = 0; i < l; i++) Tis.push(funcF(i));\n  const TisResolved = await Promise.all(Tis);\n  TisResolved.forEach( (elem) => {\n    if (elem.index !== l - 1) DK.set(elem.value, elem.index*hLen);\n    else DK.set(elem.value.slice(0, r), elem.index*hLen);\n  });\n\n  return DK;\n}\n\n// network byte order\nconst nwbo = (num, len) => {\n  const arr = new Uint8Array(len);\n  for(let i=0; i<len; i++) arr[i] = 0xFF && (num >> ((len - i - 1)*8));\n  return arr;\n};\n\n\n/**\n * Password-based key derivation function 1.\n * Detailed specification is given in RFC8018 Section 5.1 {@link https://tools.ietf.org/html/rfc8018#section-5.1}.\n * @param {Uint8Array|String} p - Byte array or string of password. if string is given, it will be converted to Uint8Array.\n * @param {Uint8Array} s - Byte array of salt.\n * @param {Number} c - Iteration count.\n * @param {Number} dkLen - Intended output key length in octet.\n * @param {String} hash - Name of underlying hash function for HMAC like 'SHA-256'\n * @return {Promise<Uint8Array>} - Derived key.\n * @throws {Error} - Throws if the intended key length is too long.\n */\nexport async function pbkdf1(p, s, c, dkLen, hash){\n  assertPbkdf(p, s, c, dkLen, hash);\n  if(typeof p === 'string') p = jseu.encoder.stringToArrayBuffer(p);\n\n  if(dkLen > params.hashes[hash].hashSize) throw new Error('DerivedKeyTooLong');\n\n  let seed = new Uint8Array(p.length + s.length);\n  seed.set(p);\n  seed.set(s, p.length);\n  for(let i = 0; i < c; i++){\n    seed = await jschash.compute(seed, hash);\n  }\n  return seed.slice(0, dkLen);\n}\n\n/** Assertion for PBKDF 1 and 2\n * @param {Uint8Array|String} p - Byte array or string of password. if string is given, it will be converted to Uint8Array.\n * @param {Uint8Array} s - Byte array of salt.\n * @param {Number} c - Iteration count.\n * @param {Number} dkLen - Intended output key length in octet.\n * @param {String} hash - Name of underlying hash function for HMAC like 'SHA-256'\n * @return {boolean} - True if given params pass the assertion check. Otherwise, throw (not false).\n * @throws {Error} - Throws if the params doesn't pass the assertion checks for given conditions.\n */\nfunction assertPbkdf(p, s, c, dkLen, hash){\n  if (typeof p !== 'string' && !(p instanceof Uint8Array)) throw new Error('PasswordIsNotUint8ArrayNorString');\n  if (!(s instanceof Uint8Array)) throw new Error('SaltMustBeUint8Array');\n  if (typeof c !== 'number' || c <= 0)throw new Error('InvalidIterationCount');\n  if (typeof dkLen !== 'number' || dkLen <= 0) throw new Error('InvalidDerivedKeyLength');\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHashAlgorithm');\n  return true;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/src/pbkdf.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 182,
    "kind": "function",
    "name": "pbkdf2",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~pbkdf2",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": "{pbkdf2}",
    "description": "Password-based key derivation function 2.\nDetailed specification is given in RFC8018 Section 5.2 {@link https://tools.ietf.org/html/rfc8018#section-5.2}.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "Byte array or string of password. if string is given, it will be converted to Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "Byte array of salt."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": "Iteration count."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "dkLen",
        "description": "Intended output key length in octet."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of underlying hash function for HMAC like 'SHA-256', used as a pseudorandom function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Derived key."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if the intended key length is too long."
      }
    ]
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "nwbo",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~nwbo",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      },
      {
        "name": "len",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "pbkdf1",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~pbkdf1",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": "{pbkdf1}",
    "description": "Password-based key derivation function 1.\nDetailed specification is given in RFC8018 Section 5.1 {@link https://tools.ietf.org/html/rfc8018#section-5.1}.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "Byte array or string of password. if string is given, it will be converted to Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "Byte array of salt."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": "Iteration count."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "dkLen",
        "description": "Intended output key length in octet."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of underlying hash function for HMAC like 'SHA-256'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Derived key."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if the intended key length is too long."
      }
    ]
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "assertPbkdf",
    "memberof": "packages/js-crypto-pbkdf/src/pbkdf.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/src/pbkdf.js~assertPbkdf",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-pbkdf/src/pbkdf.js",
    "importStyle": null,
    "description": "Assertion for PBKDF 1 and 2",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "Byte array or string of password. if string is given, it will be converted to Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "Byte array of salt."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": "Iteration count."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "dkLen",
        "description": "Intended output key length in octet."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of underlying hash function for HMAC like 'SHA-256'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if given params pass the assertion check. Otherwise, throw (not false)."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if the params doesn't pass the assertion checks for given conditions."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "packages/js-crypto-random/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {getRandomBytes, getRandomAsciiString, getRandomString} from './random.js';\n\nexport default {getRandomBytes, getRandomAsciiString, getRandomString};\nexport {getRandomBytes, getRandomAsciiString, getRandomString};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "file",
    "name": "packages/js-crypto-random/src/random.js",
    "content": "/**\n * random.js\n */\n\nimport * as util from 'js-crypto-env';\n\n/**\n * Secure random string generator based on getRandomBytes,\n * which is composed of uppercase or lowercase alphanumeric characters;\n * @param {Number} len - Length of string.\n * @return {String} - Generated random ASCII string.\n */\nexport function getRandomString(len) {\n  const array = getRandomBytes(len);\n  const types = getRandomBytes(len); // indicating alphanumeric, upper, lower\n  let finalString = '';\n\n  // Ascii code\n  // 1-0: 0x30 -- 0x39, 10 chars\n  // A-Z: 0x41 -- 0x5a,\n  // a-z: 0x61 -- 0x7a\n  for (let i = 0; i < len; i++) {\n    types[i] = (types[i] % 3);\n    array[i] = (types[i] === 0) ?\n      (array[i] % 10) + 0x30 :\n      (array[i] % 26) + ((types[i] === 1) ? 0x41 : 0x61);\n    finalString += String.fromCharCode(array[i]);\n  }\n\n  return finalString;\n}\n\n/**\n * Secure random 'ASCII' string generator based on getRandomBytes;\n * @param {Number} len - Length of ASCII string.\n * @return {String} - Generated random ASCII string.\n */\nexport function getRandomAsciiString(len) {\n  const array = getRandomBytes(len);\n  let finalString = '';\n\n  // Ascii code excluding control characters are in 0x20 -- 0x7e\n  for (let i = 0; i < len; i++) {\n    array[i] = (array[i] % 0x5e) + 0x20;\n    finalString += String.fromCharCode(array[i]);\n  }\n\n  return finalString;\n}\n\n\n/**\n * Secure random generator that returns a byte array filled with cryptographically secure random bytes\n * @param {Number} len - Byte length of random sequence.\n * @return {Uint8Array} - Generated random sequence.\n * @throws {Error} - Throws if UnsupportedEnvironment.\n */\nexport function getRandomBytes(len) {\n  const webCrypto = util.getRootWebCryptoAll(); // web crypto api or ms crypto\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let array;\n\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.getRandomValues === 'function') {\n    array = new Uint8Array(len);\n    webCrypto.getRandomValues(array); // for modern browsers or legacy ie 11\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    array = new Uint8Array(nodeCrypto.randomBytes(len));\n  } else {\n    throw new Error('UnsupportedEnvironment');\n  }\n\n  return array;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/src/random.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "getRandomString",
    "memberof": "packages/js-crypto-random/src/random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/random.js~getRandomString",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/random.js",
    "importStyle": "{getRandomString}",
    "description": "Secure random string generator based on getRandomBytes,\nwhich is composed of uppercase or lowercase alphanumeric characters;",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Length of string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "Generated random ASCII string."
    }
  },
  {
    "__docId__": 189,
    "kind": "function",
    "name": "getRandomAsciiString",
    "memberof": "packages/js-crypto-random/src/random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/random.js~getRandomAsciiString",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/random.js",
    "importStyle": "{getRandomAsciiString}",
    "description": "Secure random 'ASCII' string generator based on getRandomBytes;",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Length of ASCII string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "Generated random ASCII string."
    }
  },
  {
    "__docId__": 190,
    "kind": "function",
    "name": "getRandomBytes",
    "memberof": "packages/js-crypto-random/src/random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-random/src/random.js~getRandomBytes",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-random/src/random.js",
    "importStyle": "{getRandomBytes}",
    "description": "Secure random generator that returns a byte array filled with cryptographically secure random bytes",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Byte length of random sequence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Generated random sequence."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 191,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {generateKey, sign, verify, encrypt, decrypt} from './rsa.js';\n\nexport default {generateKey, sign, verify, encrypt, decrypt};\nexport {generateKey, sign, verify, encrypt, decrypt};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 192,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/nodeapi.js",
    "content": "/**\n * nodeapi.js\n */\n\nimport params from './params.js';\nimport {Key} from 'js-crypto-key-utils';\nimport jseu from 'js-encoding-utils';\nimport * as oaep from './oaep.js';\nimport BN from 'bn.js';\n\n/**\n * Generate RSA public/private key pair.\n * @param {Number} modulusLength - Modulus length in bits, i.e., n.\n * @param {Uint8Array} publicExponent - Public exponent, i.e, e.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>}\n * @throws {Error} - Throws if KeyGenerationFailedNode.\n */\nexport async function generateKey(modulusLength, publicExponent, nodeCrypto){\n  const pe = new BN(publicExponent);\n  const options = {\n    modulusLength: (typeof modulusLength !== 'number') ? parseInt(modulusLength, 10) : modulusLength,\n    publicExponent: pe.toNumber(),\n    publicKeyEncoding: {type: 'spki', format: 'der'},\n    privateKeyEncoding: {type: 'pkcs8', format: 'der'}\n\n  };\n  const nodeKeyGen = () => new Promise( (resolve, reject) => {\n    nodeCrypto.generateKeyPair('rsa', options,\n      (err, publicKey, privateKey) => {\n        if (err) reject('KeyGenerationFailedNode');\n        else resolve({publicKey, privateKey});\n      });\n  });\n  const keyPairDer = await nodeKeyGen().catch( () => {throw new Error('KeyGenerationFailedNode');});\n  const publicObj = new Key('der', new Uint8Array(keyPairDer.publicKey));\n  const privateObj = new Key('der', new Uint8Array(keyPairDer.privateKey));\n  return {\n    publicKey: await publicObj.export('jwk'),\n    privateKey: await privateObj.export('jwk')\n  };\n}\n\n/**\n * RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key for signing in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @param {Object} algorithm - Object to specify algorithm parameters.\n * @param {Object} nodeCrypto - NodeCrypto object\n * @return {Promise<Uint8Array>} - Byte array of raw signature.\n * @throws {Error} - Throws if NotPublicKeyForRSASign.\n */\nexport async function sign(msg, privateJwk, hash, algorithm, nodeCrypto) {\n  const keyObj = new Key('jwk', privateJwk);\n  if(!keyObj.isPrivate) throw new Error('NotPrivateKeyForRSASign');\n  const privatePem = await keyObj.export('pem');\n  const sign = nodeCrypto.createSign(params.hashes[hash].nodeName);\n  sign.update(msg);\n  const opt = (algorithm.name === 'RSA-PSS') ? {saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING} : {};\n  return new Uint8Array(sign.sign(Object.assign({key: privatePem}, opt)));\n}\n\n/**\n /**\n * Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.\n * @param {Uint8Array} msg - Byte array of message signed.\n * @param {Uint8Array} signature - Byte array of raw signature.\n * @param {JsonWebKey} publicJwk - public key for signing in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @param {Object} algorithm - Object to specify algorithm parameters.\n * @param {Object} nodeCrypto - NodeCrypto object\n * @return {Promise<boolean>} - Result of verification.\n * @throws {Error} - Throws if NotPublicKeyForRSAVerify.\n */\nexport async function verify(msg, signature, publicJwk, hash, algorithm, nodeCrypto) {\n  const keyObj = new Key('jwk', publicJwk);\n  if(keyObj.isPrivate) throw new Error('NotPublicKeyForRSAVerify');\n  const publicPem = await keyObj.export('pem', {outputPublic: true});\n  const verify = nodeCrypto.createVerify(params.hashes[hash].nodeName);\n  verify.update(msg);\n  const opt = (algorithm.name === 'RSA-PSS') ? {saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING} : {};\n  return verify.verify(Object.assign({key: publicPem}, opt), signature);\n}\n\n/**\n * RSA Encryption via NodeCrypto.\n * @param {Uint8Array} msg - Byte array of message to be encrypted\n * @param {JsonWebKey} publicJwk - Public key in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} label - RSA-OAEP label.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<Uint8Array>} - Encrypted message.\n * @throws {Error} - Throws if NotPublicKeyForRSAEncrypt.\n */\nexport async function encrypt(msg, publicJwk, hash = 'SHA-256', label = new Uint8Array([]), nodeCrypto){\n  const keyObj = new Key('jwk', publicJwk);\n  if(keyObj.isPrivate) throw new Error('NotPublicKeyForRSAEncrypt');\n  const publicPem = await keyObj.export('pem', {outputPublic: true});\n\n  let encrypted;\n  if(hash === 'SHA-1') {\n    encrypted = nodeCrypto.publicEncrypt({key: publicPem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING}, msg);\n  } else {\n    // https://tools.ietf.org/html/rfc3447\n    const em = await oaep.emeOaepEncode(msg, label, jseu.encoder.decodeBase64Url(publicJwk.n).length, hash);\n    encrypted = nodeCrypto.publicEncrypt({key: publicPem, padding: nodeCrypto.constants.RSA_NO_PADDING}, em);\n  }\n  return new Uint8Array(encrypted);\n}\n\n/**\n * RSA Decryption via NodeCrypto.\n * @param {Uint8Array} data - encrypted message byte array.\n * @param {JsonWebKey} privateJwk - Private key in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} label - RSA-OAEP label.\n * @param {Object} nodeCrypto - NodeCrypto object.\n * @return {Promise<Uint8Array>} - Decrypted message.\n * @throws {Error} - Throws if NotPrivateKeyForRSADecrypt.\n */\nexport async function decrypt(data, privateJwk, hash = 'SHA-256', label = new Uint8Array([]), nodeCrypto){\n  const keyObj = new Key('jwk', privateJwk);\n  if(!keyObj.isPrivate) throw new Error('NotPrivateKeyForRSADecrypt');\n  const privatePem = await keyObj.export('pem');\n\n  let decrypted;\n  if(hash === 'SHA-1') {\n    decrypted = nodeCrypto.privateDecrypt({key: privatePem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING}, data);\n  } else {\n    // https://tools.ietf.org/html/rfc3447\n    const em = nodeCrypto.privateDecrypt({key: privatePem, padding: nodeCrypto.constants.RSA_NO_PADDING}, data);\n    decrypted = await oaep.emeOaepDecode(new Uint8Array(em), label, jseu.encoder.decodeBase64Url(privateJwk.n).length, hash);\n  }\n  return new Uint8Array(decrypted);\n}\n\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/nodeapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 193,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{generateKey}",
    "description": "Generate RSA public/private key pair.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "modulusLength",
        "description": "Modulus length in bits, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "publicExponent",
        "description": "Public exponent, i.e, e."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if KeyGenerationFailedNode."
      }
    ]
  },
  {
    "__docId__": 194,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{sign}",
    "description": "RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Byte array of raw signature."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublicKeyForRSASign."
      }
    ]
  },
  {
    "__docId__": 195,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{verify}",
    "description": "/**\nVerification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of raw signature."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "public key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublicKeyForRSAVerify."
      }
    ]
  },
  {
    "__docId__": 196,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{encrypt}",
    "description": "RSA Encryption via NodeCrypto.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be encrypted"
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "RSA-OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Encrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPublicKeyForRSAEncrypt."
      }
    ]
  },
  {
    "__docId__": 197,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/nodeapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/nodeapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/nodeapi.js",
    "importStyle": "{decrypt}",
    "description": "RSA Decryption via NodeCrypto.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "encrypted message byte array."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "RSA-OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nodeCrypto",
        "description": "NodeCrypto object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NotPrivateKeyForRSADecrypt."
      }
    ]
  },
  {
    "__docId__": 198,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/oaep.js",
    "content": "/**\n * oaep.js\n */\nimport params from './params.js';\nimport jschash from 'js-crypto-hash';\nimport random from 'js-crypto-random';\n\n\n// RFC3447 https://tools.ietf.org/html/rfc3447\n/*\n      # Encryption\n      a. If the length of L is greater than the input limitation for the\n         hash function (2^61 - 1 octets for SHA-1), output \"label too\n         long\" and stop.\n\n      b. If mLen > k - 2hLen - 2, output \"message too long\" and stop.\n\n      # Decryption\n      a. If the length of L is greater than the input limitation for the\n         hash function (2^61 - 1 octets for SHA-1), output \"decryption\n         error\" and stop.\n\n      b. If the length of the ciphertext C is not k octets, output\n         \"decryption error\" and stop.\n\n      c. If k < 2hLen + 2, output \"decryption error\" and stop.\n */\n/**\n * Check OAEP length\n * @param {String} mode - 'encrypt' or 'decrypt'\n * @param {Number} k - Octet length of modulus length, i.e., n.\n * @param {Uint8Array} label - OAEP label.\n * @param {String} hash - Name of hash function.\n * @param {Number} mLen - Octet length of message to be encrypted.\n * @param {Number} cLen - the length of ciphertext\n * @throws {Error} - Throws if LabelTooLong, MessageTooLong, DecryptionError or InvalidMode.\n */\nexport function checkLength(mode, {k, label, hash, mLen, cLen}){\n  if (mode === 'encrypt') {\n    if (label.length > (1 << params.hashes[hash].maxInput) - 1) throw new Error('LabelTooLong');\n    if (mLen > k - 2 * params.hashes[hash].hashSize - 2) throw new Error('MessageTooLong');\n  }\n  else if (mode === 'decrypt') {\n    if (label.length > (1 << params.hashes[hash].maxInput) - 1) throw new Error('DecryptionError');\n    if (cLen !== k || k < 2 * params.hashes[hash].hashSize + 2) throw new Error('DecryptionError');\n  }\n  else throw new Error('InvalidMode');\n}\n\n\n/*\n      a. If the label L is not provided, let L be the empty string. Let\n         lHash = Hash(L), an octet string of length hLen (see the note\n         below).\n\n      b. Generate an octet string PS consisting of k - mLen - 2hLen - 2\n         zero octets.  The length of PS may be zero.\n\n      c. Concatenate lHash, PS, a single octet with hexadecimal value\n         0x01, and the message M to form a data block DB of length k -\n         hLen - 1 octets as\n\n            DB = lHash || PS || 0x01 || M.\n\n      d. Generate a random octet string seed of length hLen.\n\n      e. Let dbMask = MGF(seed, k - hLen - 1).\n\n      f. Let maskedDB = DB \\xor dbMask.\n\n      g. Let seedMask = MGF(maskedDB, hLen).\n\n      h. Let maskedSeed = seed \\xor seedMask.\n\n      i. Concatenate a single octet with hexadecimal value 0x00,\n         maskedSeed, and maskedDB to form an encoded message EM of\n         length k octets as\n\n            EM = 0x00 || maskedSeed || maskedDB.\n */\n/**\n * OAEP Encoder\n * @param {Uint8Array} msg - Message.\n * @param {Uint8Array} label - Label.\n * @param {Number} k - Octet length of modulus length, i.e., n.\n * @param {String} hash - Name of hash function.\n * @return {Promise<Uint8Array>} - OAEP encoded message.\n */\nexport async function emeOaepEncode(msg, label, k, hash='SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n\n  let ps = new Uint8Array(k - msg.length - (2*hashSize) - 2);\n  ps = ps.map( () => 0x00);\n\n  const lHash = await jschash.compute(label, hash);\n\n  const db = new Uint8Array(k - hashSize - 1);\n  db.set(lHash);\n  db.set(ps, hashSize);\n  db.set(new Uint8Array([0x01]), k- msg.length - hashSize - 2);\n  db.set(msg, k - msg.length - hashSize - 1);\n\n  const seed = await random.getRandomBytes(hashSize);\n\n  const dbMask = await mgf1(seed, k - hashSize - 1, hash);\n\n  const maskedDb = db.map( (elem, idx) => 0xFF & (elem ^ dbMask[idx]));\n\n  const seedMask = await mgf1(maskedDb, hashSize, hash);\n\n  const maskedSeed = seed.map( (elem, idx) => 0xFF & (elem ^ seedMask[idx]));\n\n  const em = new Uint8Array(k);\n  em.set(new Uint8Array([0x00]));\n  em.set(maskedSeed, 1);\n  em.set(maskedDb, hashSize + 1);\n\n  return em;\n}\n\n\n/*\n      a. If the label L is not provided, let L be the empty string. Let\n         lHash = Hash(L), an octet string of length hLen (see the note\n         in Section 7.1.1).\n\n      b. Separate the encoded message EM into a single octet Y, an octet\n         string maskedSeed of length hLen, and an octet string maskedDB\n         of length k - hLen - 1 as\n\n            EM = Y || maskedSeed || maskedDB.\n\n      c. Let seedMask = MGF(maskedDB, hLen).\n\n      d. Let seed = maskedSeed \\xor seedMask.\n\n      e. Let dbMask = MGF(seed, k - hLen - 1).\n\n      f. Let DB = maskedDB \\xor dbMask.\n\n      g. Separate DB into an octet string lHash' of length hLen, a\n         (possibly empty) padding string PS consisting of octets with\n         hexadecimal value 0x00, and a message M as\n\n            DB = lHash' || PS || 0x01 || M.\n\n         If there is no octet with hexadecimal value 0x01 to separate PS\n         from M, if lHash does not equal lHash', or if Y is nonzero,\n         output \"decryption error\" and stop.  (See the note below.)\n */\n\n/**\n * OAEP Decoder\n * @param {Uint8Array} em - OAEP encoded message.\n * @param {Uint8Array} label - Label.\n * @param {Number} k - Octet length of modulus length, i.e., n.\n * @param {String} hash - Name of hash function.\n * @return {Promise<Uint8Array>} - OAEP decoded message.\n * @throws {Error} - Throws if DecryptionError.\n */\nexport async function emeOaepDecode(em, label, k, hash='SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n\n  const lHash = await jschash.compute(label, hash); // must be equal to lHashPrime\n\n  const y = em[0]; // must be zero\n  if (y !== 0x00) throw new Error('DecryptionError');\n\n  const maskedSeed = em.slice(1, hashSize+1);\n  const maskedDb = em.slice(hashSize+1, em.length);\n\n  const seedMask = await mgf1(maskedDb, hashSize, hash);\n  const seed = maskedSeed.map( (elem, idx) => 0xFF & (elem ^ seedMask[idx]));\n\n  const dbMask = await mgf1(seed, k-hashSize-1, hash);\n  const db = maskedDb.map( (elem, idx) => 0xFF & (elem ^ dbMask[idx]));\n\n  const lHashPrime = db.slice(0, hashSize);\n\n  if(lHashPrime.toString() !== lHash.toString()) throw new Error('DecryptionError');\n\n  let offset;\n  for(let i = hashSize; i < db.length; i++){\n    if(db[i] !== 0x00){\n      offset = i;\n      break;\n    }\n  }\n  const separator = db[offset];\n  if(separator !== 0x01) throw new Error('DecryptionError');\n\n  return db.slice(offset+1, db.length);\n}\n\n\n/**\n * Mask generation function 1 (MGF1)\n * @param {Uint8Array} seed - Seed.\n * @param {Number} len - Length of mask.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm.\n * @return {Promise<Uint8Array>}: Generated mask.\n */\nasync function mgf1(seed, len, hash = 'SHA-256'){\n  const hashSize = params.hashes[hash].hashSize;\n  const blockLen = Math.ceil(len/ hashSize);\n\n  const t = new Uint8Array(blockLen*hashSize);\n\n  for(let i = 0; i < blockLen; i++) {\n    const c = i2osp(i, 4);\n    const x = new Uint8Array(seed.length + 4);\n    x.set(seed);\n    x.set(c, seed.length);\n    const y = await jschash.compute(x, hash);\n    t.set(y, i * hashSize);\n  }\n  return t.slice(0, len);\n}\n\n/**\n * I2OSP function\n * @param {Number} x - Number to be encoded to byte array in network byte order.\n * @param {Number} len - Length of byte array\n * @return {Uint8Array} - Encoded number.\n */\nfunction i2osp(x, len){\n  const r = new Uint8Array(len);\n  r.forEach( (elem, idx) => {\n    const y = 0xFF & (x >> (idx*8));\n    r[len - idx - 1] = y;\n  });\n  return r;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/oaep.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 199,
    "kind": "function",
    "name": "checkLength",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~checkLength",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{checkLength}",
    "description": "Check OAEP length",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "'encrypt' or 'decrypt'"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "Octet length of modulus length, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash function."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "mLen",
        "description": "Octet length of message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cLen",
        "description": "the length of ciphertext"
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if LabelTooLong, MessageTooLong, DecryptionError or InvalidMode."
      }
    ],
    "return": null
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "emeOaepEncode",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~emeOaepEncode",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{emeOaepEncode}",
    "description": "OAEP Encoder",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "Label."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "Octet length of modulus length, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "OAEP encoded message."
    }
  },
  {
    "__docId__": 201,
    "kind": "function",
    "name": "emeOaepDecode",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~emeOaepDecode",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": "{emeOaepDecode}",
    "description": "OAEP Decoder",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "em",
        "description": "OAEP encoded message."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "Label."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "Octet length of modulus length, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "OAEP decoded message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if DecryptionError."
      }
    ]
  },
  {
    "__docId__": 202,
    "kind": "function",
    "name": "mgf1",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~mgf1",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": null,
    "description": "Mask generation function 1 (MGF1)",
    "lineNumber": 203,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "seed",
        "description": "Seed."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Length of mask."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{Promise<Uint8Array>}: Generated mask."
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "function",
    "name": "i2osp",
    "memberof": "packages/js-crypto-rsa/src/oaep.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/oaep.js~i2osp",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/oaep.js",
    "importStyle": null,
    "description": "I2OSP function",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "Number to be encoded to byte array in network byte order."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "Length of byte array"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "Encoded number."
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  // maxInput: 2^maxInput - 1 octets\n  hashes: {\n    'SHA-256': {nodeName: 'sha256', hashSize: 32, maxInput: 61},\n    'SHA-384': {nodeName: 'sha384', hashSize: 48, maxInput: 125},\n    'SHA-512': {nodeName: 'sha512', hashSize: 64, maxInput: 125},\n    'SHA-1': {nodeName: 'sha1', hashSize: 20, maxInput: 61},\n  },\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 205,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/pss.js",
    "content": "/**\n * pss.js\n */\n\nimport params from './params.js';\n\n// RFC3447 https://tools.ietf.org/html/rfc3447\n/*\n       # Sign\n       - If the length of M is greater than the input limitation for the\n       hash function (2^61 - 1 octets for SHA-1), output \"message too\n       long\" and stop.\n\n       - If emLen < hLen + sLen + 2, output \"encoding error\" and stop.\n\n       # Verify\n       - If the length of M is greater than the input limitation for the\n       hash function (2^61 - 1 octets for SHA-1), output \"inconsistent\"\n       and stop.\n\n       - If emLen < hLen + sLen + 2, output \"inconsistent\" and stop.\n */\n// emLen = Math.ceil((modBits(=k) - 1)/8), e.g., Math.ceil(2047/8) = 256, that is exactly equal to k)\n/**\n * Check PSS Length.\n * @param {String} mode - 'sign' or 'verify'\n * @param {Number} k - Octet length of modulus length, i.e., n.\n * @param {String} hash - Name of hash function.\n * @param {Number} saltLength - Length of salt.\n * @throws {Error} - Throws if Inconsistent, EncodingError, or InvalidMode.\n */\nexport function checkLength(mode, {k, hash, saltLength}){\n  if(mode === 'sign'){\n    if (k > (1 << params.hashes[hash].maxInput) - 1) throw new Error('Inconsistent');\n    if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0) throw new Error('EncodingError');\n  }\n  else if (mode === 'verify') {\n    if (k > (1 << params.hashes[hash].maxInput) - 1) throw new Error('Inconsistent');\n    if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0) throw new Error('Inconsistent');\n  }\n  else throw new Error('InvalidMode');\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/pss.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "checkLength",
    "memberof": "packages/js-crypto-rsa/src/pss.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/pss.js~checkLength",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/pss.js",
    "importStyle": "{checkLength}",
    "description": "Check PSS Length.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "'sign' or 'verify'"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "Octet length of modulus length, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash function."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "saltLength",
        "description": "Length of salt."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if Inconsistent, EncodingError, or InvalidMode."
      }
    ],
    "return": null
  },
  {
    "__docId__": 207,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/rsa.js",
    "content": "/**\n * rsa.js\n */\n\nimport * as util from 'js-crypto-env';\nimport * as webapi from './webapi.js';\nimport * as nodeapi from './nodeapi.js';\nimport params from './params.js';\nimport {checkLength as checkOaepLength} from './oaep.js';\nimport {checkLength as checkPssLength} from './pss.js';\nimport jseu from 'js-encoding-utils';\n\n/**\n * Generate RSA public/private key pair.\n * @param {Number} [modulusLength=2048] - Modulus length in bits, i.e., n.\n * @param {Uint8Array} [publicExponent=new Uint8Array([0x01, 0x00, 0x01])] - Public exponent, i.e, e.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>}\n * @throws {Error} - Throws if UnsupportedEnvironment.\n */\nexport async function generateKey(modulusLength = 2048, publicExponent = new Uint8Array([0x01, 0x00, 0x01])){\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let errMsg;\n  let keyPair = {};\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.generateKey === 'function' && typeof webCrypto.exportKey === 'function') { // for web API\n    keyPair = await webapi.generateKey(modulusLength, publicExponent, webCrypto).catch((e) => {\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    keyPair = await nodeapi.generateKey(modulusLength, publicExponent, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n    });\n  } else throw new Error('UnsupportedEnvironment');\n\n  if (errMsg) throw new Error(`UnsupportedEnvironment: ${errMsg}`); // TODO: fallback to purejs implementation\n\n  return keyPair;\n}\n\n/**\n * RSA Signing parameter check.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} jwkey - Private/Public key for signing/verifying in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @param {RSASignAlgorithm} algorithm - Object to specify algorithm parameters.\n * @param {String} mode - 'sign' or 'verify' for PSS parameter check.\n * @return {boolean} - Always true unless thrown.\n * @throws {Error} - Throws if InvalidAlgorithm, UnsupportedHash, InvalidMessageFormat or InvalidJwkRsaKey\n */\nfunction assertSignVerify(msg, jwkey, hash, algorithm, mode){\n  if (algorithm.name !== 'RSA-PSS' && algorithm.name !== 'RSASSA-PKCS1-v1_5') throw new Error('InvalidAlgorithm');\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(msg instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (jwkey.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  if (algorithm.name === 'RSA-PSS'){\n    checkPssLength(mode, {k: jseu.encoder.decodeBase64Url(jwkey.n).length, hash, saltLength: algorithm.saltLength});\n  }\n  return true;\n}\n\n/**\n * RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key for signing in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @param {RSASignAlgorithm} [algorithm={name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}] - Object to specify algorithm parameters.\n * @return {Promise<Uint8Array>} - Byte array of raw signature.\n * @throws {Error} - Throws if UnsupportedEnvironment.\n */\nexport async function sign(msg, privateJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}) {\n  // assertion\n  assertSignVerify(msg, privateJwk, hash, algorithm, 'sign');\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let errMsg;\n  let signature;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function') { // for web API\n    signature = await webapi.sign(msg, privateJwk, hash, algorithm, webCrypto).catch((e) => {\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined' ) { // for node\n    signature = await nodeapi.sign(msg, privateJwk, hash, algorithm, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n    });\n  } else throw new Error('UnsupportedEnvironment');\n\n  if (errMsg) throw new Error(`UnsupportedEnvironment: ${errMsg}`); // TODO: fallback to purejs implementation\n\n  return signature;\n\n}\n\n/**\n * Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5.\n * @param {Uint8Array} msg - Byte array of message signed.\n * @param {Uint8Array} signature - Byte array of raw signature.\n * @param {JsonWebKey} publicJwk - public key for signing in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @param {RSASignAlgorithm} [algorithm={name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}] - Object to specify algorithm parameters.\n * @return {Promise<boolean>} - Result of verification.\n * @throws {Error} - Throws if InvalidSignatureFormat, or UnsupportedEnvironment.\n */\nexport async function verify(msg, signature, publicJwk, hash = 'SHA-256', algorithm = {name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}) {\n  // assertion\n  assertSignVerify(msg, publicJwk, hash, algorithm, 'verify');\n  if (!(signature instanceof Uint8Array)) throw new Error('InvalidSignatureFormat');\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let errMsg;\n  let valid;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.verify === 'function') { // for web API\n    valid = await webapi.verify(msg, signature, publicJwk, hash, algorithm, webCrypto).catch((e) => {\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    valid = await nodeapi.verify(msg, signature, publicJwk, hash, algorithm, nodeCrypto).catch( (e) => {\n      errMsg = e.message;\n    });\n  } else throw new Error('UnsupportedEnvironment');\n\n  if (errMsg) throw new Error(`UnsupportedEnvironment: ${errMsg}`); // TODO: fallback to purejs implementation\n\n  return valid;\n}\n\n/**\n * RSA Encryption/Decryption Parameter Check.\n * @param {Uint8Array} data - message or encrypted message byte array.\n * @param {JsonWebKey} jwkey - Public/Private key in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} label - RSA-OAEP label.\n * @param {String} mode - 'encrypt' or 'decrypt'\n * @return {boolean} - Always true, otherwise thrown.\n * @throws {Error} - Throws if UnsuppotedHash, InvalidMessageFormat, InvalidLabelFormat or InvalidJwkRsaKey.\n */\nfunction assertEncryptDecrypt(data, jwkey, hash, label, mode){\n  if (Object.keys(params.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');\n  if (!(data instanceof Uint8Array)) throw new Error('InvalidMessageFormat');\n  if (!(label instanceof Uint8Array)) throw new Error('InvalidLabelFormat');\n  if (jwkey.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');\n  checkOaepLength(mode,\n    Object.assign({ k: jseu.encoder.decodeBase64Url(jwkey.n).length, label, hash},\n      (mode === 'encrypt') ? {mLen: data.length, cLen: 0} : {mLen: 0, cLen: data.length} )\n  );\n\n  return true;\n}\n/**\n * RSA-OAEP Encryption\n * @param {Uint8Array} msg - Byte array of message to be encrypted.\n * @param {JsonWebKey} publicJwk - Public/Private key in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} [label=new Uint8Array([])] - RSA-OAEP label.\n * @return {Promise<Uint8Array>} - Encrypted message.\n * @throws {Error} - Throws if UnsupportedEnvironment.\n */\nexport async function encrypt(msg, publicJwk, hash = 'SHA-256', label = new Uint8Array([])){\n  // assertion\n  assertEncryptDecrypt(msg, publicJwk, hash, label, 'encrypt');\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let errMsg;\n  let encrypted;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function') { // for web API\n    encrypted = await webapi.encrypt(msg, publicJwk, hash, label, webCrypto).catch((e) => {\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    try {\n      encrypted = nodeapi.encrypt(msg, publicJwk, hash, label, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n    }\n  } else throw new Error('UnsupportedEnvironment'); // TODO: fallback to pure js implementation\n\n  if (errMsg) throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n\n  return encrypted;\n}\n\n/**\n * RSA-OAEP Decryption.\n * @param {Uint8Array} data - Byte array of encrypted message to be decrypted.\n * @param {JsonWebKey} privateJwk - Private key in JWK format.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} [label=new Uint8Array([])] - RSA-OAEP label.\n * @return {Promise<Uint8Array>} - Decrypted message.\n * @throws {Error} - Throws if UnsupportedEnvironment.\n */\nexport async function decrypt(data, privateJwk, hash = 'SHA-256', label = new Uint8Array([])){\n  // assertion\n  assertEncryptDecrypt(data, privateJwk, hash, label, 'decrypt');\n\n  const webCrypto = util.getWebCryptoAll(); // web crypto api\n  const nodeCrypto = util.getNodeCrypto(); // implementation on node.js\n\n  let errMsg;\n  let decrypted;\n  if (typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.decrypt === 'function') { // for web API\n    decrypted = await webapi.decrypt(data, privateJwk, hash, label, webCrypto).catch((e) => {\n      errMsg = e.message;\n    });\n  }\n  else if (typeof nodeCrypto !== 'undefined') { // for node\n    try {\n      decrypted = nodeapi.decrypt(data, privateJwk, hash, label, nodeCrypto);\n    } catch(e) {\n      errMsg = e.message;\n    }\n  } else throw new Error('UnsupportedEnvironment');\n\n  // TODO: fallback to purejs implementation\n  if (errMsg) throw new Error(`UnsupportedEnvironment: ${errMsg}`);\n\n  return decrypted;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 208,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{generateKey}",
    "description": "Generate RSA public/private key pair.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2048",
        "defaultRaw": 2048,
        "name": "modulusLength",
        "description": "Modulus length in bits, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new Uint8Array([0x01, 0x00, 0x01])",
        "defaultRaw": "new Uint8Array([0x01, 0x00, 0x01])",
        "name": "publicExponent",
        "description": "Public exponent, i.e, e."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 209,
    "kind": "function",
    "name": "assertSignVerify",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~assertSignVerify",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": null,
    "description": "RSA Signing parameter check.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "Private/Public key for signing/verifying in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASignAlgorithm"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "'sign' or 'verify' for PSS parameter check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Always true unless thrown."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidAlgorithm, UnsupportedHash, InvalidMessageFormat or InvalidJwkRsaKey"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{sign}",
    "description": "RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASignAlgorithm"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}",
        "defaultRaw": "{name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}",
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Byte array of raw signature."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 211,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{verify}",
    "description": "Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of raw signature."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "public key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASignAlgorithm"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}",
        "defaultRaw": "{name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}",
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidSignatureFormat, or UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 212,
    "kind": "function",
    "name": "assertEncryptDecrypt",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~assertEncryptDecrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": null,
    "description": "RSA Encryption/Decryption Parameter Check.",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "message or encrypted message byte array."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "jwkey",
        "description": "Public/Private key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "RSA-OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "'encrypt' or 'decrypt'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Always true, otherwise thrown."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsuppotedHash, InvalidMessageFormat, InvalidLabelFormat or InvalidJwkRsaKey."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{encrypt}",
    "description": "RSA-OAEP Encryption",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public/Private key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new Uint8Array([])",
        "defaultRaw": "new Uint8Array([])",
        "name": "label",
        "description": "RSA-OAEP label."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Encrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 214,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/rsa.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/rsa.js",
    "importStyle": "{decrypt}",
    "description": "RSA-OAEP Decryption.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Byte array of encrypted message to be decrypted."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new Uint8Array([])",
        "defaultRaw": "new Uint8Array([])",
        "name": "label",
        "description": "RSA-OAEP label."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedEnvironment."
      }
    ]
  },
  {
    "__docId__": 215,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/typedef.js",
    "content": "/**\n * @typedef {Object} RSASignAlgorithm - Object to specify algorithm parameters for RSA sign and verify functions.\n * @property {String} [name='RSA-PSS'] - 'RSA-PSS' or  'RSASSA-PKCS1-v1_5'.\n * @property {Number} [saltLength] - For RSA-PSS, this must be specified.\n */",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 216,
    "kind": "typedef",
    "name": "RSASignAlgorithm",
    "memberof": "packages/js-crypto-rsa/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-rsa/src/typedef.js~RSASignAlgorithm",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'RSA-PSS'",
        "defaultRaw": "'RSA-PSS'",
        "name": "name",
        "description": "'RSA-PSS' or  'RSASSA-PKCS1-v1_5'."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "saltLength",
        "description": "For RSA-PSS, this must be specified."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RSASignAlgorithm"
    }
  },
  {
    "__docId__": 217,
    "kind": "file",
    "name": "packages/js-crypto-rsa/src/webapi.js",
    "content": "/**\n * webapi.js\n */\n\nimport jseu from 'js-encoding-utils';\n\n/**\n * Generate RSA public/private key pair.\n * @param {Number} modulusLength - Modulus length in bits, i.e., n.\n * @param {Uint8Array} publicExponent - Public exponent, i.e, e.\n * @param {Object} webCrypto - WebCryptoSubtle object, i.e., window.crypto.subtle or window.msCrypto.subtle.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>}\n */\nexport async function generateKey(modulusLength, publicExponent, webCrypto){\n  // generate rsa key\n  // hash is used for signing and verification. never be used for key generation\n  let publicKey;\n  let privateKey;\n  const alg = {name: 'RSA-OAEP', modulusLength, publicExponent, hash: {name: 'SHA-256'}};\n\n  if(typeof window.msCrypto === 'undefined') {\n    const keys = await webCrypto.generateKey(alg, true, ['encrypt', 'decrypt']);\n    publicKey = await webCrypto.exportKey('jwk', keys.publicKey); // export keys in jwk format\n    privateKey = await webCrypto.exportKey('jwk', keys.privateKey); // export keys in jwk format\n  }\n  else {\n    const keys = await msGenerateKey(alg, true, ['encrypt', 'decrypt'], webCrypto);\n    publicKey = await msExportKey('jwk', keys.publicKey, webCrypto);\n    privateKey = await msExportKey('jwk', keys.privateKey, webCrypto);\n  }\n\n  // delete optional entries to export as general rsa sign/encrypt key\n  ['key_ops', 'alg', 'ext'].forEach((elem) => {\n    delete publicKey[elem];\n    delete privateKey[elem];\n  });\n\n  return {publicKey, privateKey};\n}\n\n/**\n * RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5 in WebAPI.\n * @param {Uint8Array} msg - Byte array of message to be signed.\n * @param {JsonWebKey} privateJwk - Private key for signing in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @param {RSASignAlgorithm} algorithm - Object to specify algorithm parameters.\n * @param {Object} webCrypto - WebCryptoSubtle object\n * @return {Promise<Uint8Array>} - Byte array of raw signature.\n * @throws {Error} - if RSA-PSS in IE.\n */\nexport async function sign(msg, privateJwk, hash, algorithm, webCrypto) {\n  const algo = {name: algorithm.name, hash: {name: hash}, saltLength: algorithm.saltLength};\n\n  let signature;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['sign']);\n    signature = await webCrypto.sign(algo, key, msg);\n  }\n  else {\n    if(algorithm.name === 'RSA-PSS') throw new Error('IE does not support RSA-PSS. Use RSASSA-PKCS1-v1_5.');\n    const key = await msImportKey('jwk', privateJwk, algo, false, ['sign'], webCrypto);\n    signature = await msSign(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(signature);\n}\n\n/**\n * Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5 in WebAPI.\n * @param {Uint8Array} msg - Byte array of message signed.\n * @param {Uint8Array} signature - Byte array of raw signature.\n * @param {JsonWebKey} publicJwk - public key for signing in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'.\n * @param {RSASignAlgorithm} algorithm - Object to specify algorithm parameters.\n * @param {Object} webCrypto - WebCryptoSubtle object\n * @return {Promise<boolean>} - Result of verification.\n * @throws {Error} - if RSA-PSS in IE.\n */\nexport async function verify(msg, signature, publicJwk, hash, algorithm, webCrypto){\n  const algo = {name: algorithm.name, hash: {name: hash}, saltLength: algorithm.saltLength};\n\n  let valid;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['verify']);\n    valid = await webCrypto.verify(algo, key, signature, msg);\n  }\n  else {\n    if(algorithm.name === 'RSA-PSS') throw new Error('IE does not support RSA-PSS. Use RSASSA-PKCS1-v1_5.');\n    const key = await msImportKey('jwk', publicJwk, algo, false, ['verify'], webCrypto);\n    valid = await msVerify(algo, key, signature, msg, webCrypto);\n  }\n  return valid;\n}\n\n/**\n * RSA Encryption via WebAPI.\n * @param {Uint8Array} msg - Byte array of message to be encrypted\n * @param {JsonWebKey} publicJwk - Public key in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} label - RSA-OAEP label.\n * @param {Object} webCrypto - WebCryptoSubtle object\n * @return {Promise<Uint8Array>} - Encrypted message.\n * @throws {Error} - if RSA-OAEP label is specified in IE.\n */\nexport async function encrypt(msg, publicJwk, hash, label, webCrypto){\n  const algo = {name: 'RSA-OAEP', hash: {name: hash}, label};\n\n  let encrypted;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', publicJwk, algo, false, ['encrypt']);\n    encrypted = await webCrypto.encrypt(algo, key, msg);\n  }\n  else {\n    if (label.toString() !== (new Uint8Array()).toString()) throw new Error('IE does not support RSA-OAEP label.');\n    const key = await msImportKey('jwk', publicJwk, algo, false, ['encrypt'], webCrypto);\n    encrypted = await msEncrypt(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(encrypted);\n}\n\n/**\n * RSA Decryption via WebAPI.\n * @param {Uint8Array} msg - encrypted message byte array.\n * @param {JsonWebKey} privateJwk - Private key in JWK format.\n * @param {String} hash - Name of hash algorithm like 'SHA-256'\n * @param {Uint8Array} label - RSA-OAEP label.\n * @param {Object} webCrypto - WebCryptoSubtle object.\n * @return {Promise<Uint8Array>} - Decrypted message.\n * @throws {Error} - if RSA-OAEP label is specified in IE.\n */\nexport async function decrypt(msg, privateJwk, hash, label, webCrypto){\n  const algo = {name: 'RSA-OAEP', hash: {name: hash}, label};\n\n  let decrypted;\n  if(typeof window.msCrypto === 'undefined') {\n    const key = await webCrypto.importKey('jwk', privateJwk, algo, false, ['decrypt']);\n    decrypted = await webCrypto.decrypt(algo, key, msg);\n  }\n  else {\n    if (label.toString() !== (new Uint8Array()).toString()) throw new Error('IE does not support RSA-OAEP label.');\n    const key = await msImportKey('jwk', privateJwk, algo, false, ['decrypt'], webCrypto);\n    decrypted = await msDecrypt(algo, key, msg, webCrypto);\n  }\n  return new Uint8Array(decrypted);\n}\n\n\n/////////////////////////////////////////////\n// function definitions for IE\nconst msGenerateKey = (alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.generateKey(alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyGenerationFailed'); };\n});\nconst msImportKey = (type, key, alg, ext, use, webCrypto) => new Promise ( (resolve, reject) => {\n  let inputKey = key;\n  if(type === 'jwk'){\n    inputKey = JSON.stringify(key);\n    inputKey = jseu.encoder.stringToArrayBuffer(inputKey);\n  }\n  const op = webCrypto.importKey(type, inputKey, alg, ext, use);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('KeyImportingFailed'); };\n});\nconst msExportKey = (type, key, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.exportKey(type, key);\n  op.oncomplete = (evt) => {\n    let output = evt.target.result;\n    if(type === 'jwk'){\n      output = jseu.encoder.arrayBufferToString(new Uint8Array(output));\n      output = JSON.parse(output);\n    }\n    resolve(output);\n  };\n  op.onerror = () => { reject('KeyExportingFailed'); };\n});\nconst msEncrypt = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  delete alg.label; // if exists, the MSCrypto doesn't work...wtf\n  const op = webCrypto.encrypt(alg, key, msg);\n  op.oncomplete = (evt) => {resolve(evt.target.result); };\n  op.onerror = () => { reject('EncryptionFailure'); };\n});\nconst msDecrypt = (alg, key, data, webCrypto) => new Promise ( (resolve, reject) => {\n  delete alg.label; // if exists, the MSCrypto doesn't work...wtf\n  const op = webCrypto.decrypt(alg, key, data);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('DecryptionFailure'); };\n});\nconst msSign = (alg, key, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.sign(alg, key, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('SigningFailed'); };\n});\nconst msVerify = (alg, key, sig, msg, webCrypto) => new Promise ( (resolve, reject) => {\n  const op = webCrypto.verify(alg, key, sig, msg);\n  op.oncomplete = (evt) => { resolve(evt.target.result); };\n  op.onerror = () => { reject('VerificationFailed'); };\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/src/webapi.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{generateKey}",
    "description": "Generate RSA public/private key pair.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "modulusLength",
        "description": "Modulus length in bits, i.e., n."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "publicExponent",
        "description": "Public exponent, i.e, e."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object, i.e., window.crypto.subtle or window.msCrypto.subtle."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{sign}",
    "description": "RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5 in WebAPI.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASignAlgorithm"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Byte array of raw signature."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if RSA-PSS in IE."
      }
    ]
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{verify}",
    "description": "Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5 in WebAPI.",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message signed."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "Byte array of raw signature."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "public key for signing in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASignAlgorithm"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Object to specify algorithm parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if RSA-PSS in IE."
      }
    ]
  },
  {
    "__docId__": 221,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{encrypt}",
    "description": "RSA Encryption via WebAPI.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Byte array of message to be encrypted"
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "Public key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "RSA-OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Encrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if RSA-OAEP label is specified in IE."
      }
    ]
  },
  {
    "__docId__": 222,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": "{decrypt}",
    "description": "RSA Decryption via WebAPI.",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "encrypted message byte array."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "RSA-OAEP label."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "webCrypto",
        "description": "WebCryptoSubtle object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted message."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if RSA-OAEP label is specified in IE."
      }
    ]
  },
  {
    "__docId__": 223,
    "kind": "function",
    "name": "msGenerateKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msGenerateKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 224,
    "kind": "function",
    "name": "msImportKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msImportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "ext",
        "types": [
          "*"
        ]
      },
      {
        "name": "use",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "function",
    "name": "msExportKey",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msExportKey",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "function",
    "name": "msEncrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msEncrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 227,
    "kind": "function",
    "name": "msDecrypt",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msDecrypt",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 228,
    "kind": "function",
    "name": "msSign",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msSign",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 188,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 229,
    "kind": "function",
    "name": "msVerify",
    "memberof": "packages/js-crypto-rsa/src/webapi.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-crypto-rsa/src/webapi.js~msVerify",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-crypto-rsa/src/webapi.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "alg",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "sig",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "webCrypto",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 230,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/index.js",
    "content": "/**\n * index.js\n * Structure of API\n * ---- Key (Key object with methods handling EC and RSA public keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA) // TODO: Encrypt/decrypt with ECDH standardized procedure\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509 // TODO verify self-signed certificate in single line\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n\nimport aes from 'js-crypto-aes';\nimport random from 'js-crypto-random';\nimport hash from 'js-crypto-hash';\nimport hmac from 'js-crypto-hmac';\nimport hkdf from 'js-crypto-hkdf';\nimport x509 from 'js-x509-utils';\nimport pbkdf from 'js-crypto-pbkdf';\n\nimport {Key} from 'js-crypto-key-utils';\nimport * as pkc from './pkc.js';\n\nexport {\n  Key,\n  pkc,\n  x509,\n  aes,\n  random,\n  hash,\n  hmac,\n  hkdf,\n  pbkdf\n};\n\nexport default {\n  Key,\n  pkc,\n  x509,\n  aes,\n  random,\n  hash,\n  hmac,\n  hkdf,\n  pbkdf\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 231,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n  ciphers: {\n    'AES-GCM': {ivLength: 12}  // 12 bytes is recommended for AES-GCM\n  },\n\n  hashes: {\n    'SHA-256': {hashSize: 32},\n    'SHA-384': {hashSize: 48},\n    'SHA-512': {hashSize: 64},\n    'SHA-1': {hashSize: 20},\n  },\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 232,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/pkc.js",
    "content": "/**\n * pkc.js\n */\n\nimport ec from 'js-crypto-ec';\nimport rsa from 'js-crypto-rsa';\nimport { Key } from 'js-crypto-key-utils/dist/key';\nimport cloneDeep from 'lodash.clonedeep';\nimport * as pkcec from './pkcec.js';\nimport params from './params.js';\n\n/**\n * Generate key pair in JWK format\n * @param {'EC'|'RSA'} [keyType='EC'] - Type of public/private key.\n * @param {ECKeyGenerationOption|RSAKeyGenerationOption} [options={}] - Key generation options.\n * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>} - Generated key pair in JWK format.\n */\nexport async function generateKey(keyType = 'EC', options = {}){\n  const localOpt = cloneDeep(options);\n\n  let kp;\n  if (keyType === 'EC'){\n    if(typeof localOpt.namedCurve === 'undefined') localOpt.namedCurve = 'P-256';\n    kp = await ec.generateKey(localOpt.namedCurve);\n  }\n  else if (keyType === 'RSA') {\n    if(typeof localOpt.modulusLength === 'undefined') localOpt.modulusLength = 2048;\n    if(typeof localOpt.publicExponent === 'undefined') localOpt.publicExponent = new Uint8Array([0x01, 0x00, 0x01]);\n    kp = await rsa.generateKey(localOpt.modulusLength, localOpt.publicExponent);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return {\n    publicKey: new Key('jwk', kp.publicKey),\n    privateKey: new Key('jwk', kp.privateKey)\n  };\n}\n\n\n/**\n * Sign message with given private key in jwk\n * @param {Uint8Array} msg - Message byte array to be signed.\n * @param {Key} privateKey - Private key object for signing.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @param {RSASigningOption|ECSigningOption} [options={}] - Signing options.\n * @return {Promise<Uint8Array>} - Signature byte array.\n * @throws {Error} - Throws if NonKeyObject or UnsupportedKeyType.\n */\nexport async function sign(msg, privateKey, hash = 'SHA-256', options = {}){\n  if(!(privateKey instanceof Key)) throw new Error('NonKeyObject');\n  const privateJwk = await privateKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let signature;\n  if (privateJwk.kty === 'EC'){\n    if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';\n    signature = await ec.sign(msg, privateJwk, hash, localOpt.format);\n  }\n  else if (privateJwk.kty === 'RSA') {\n    if(typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';\n    if(typeof localOpt.saltLength === 'undefined') localOpt.saltLength = params.hashes[hash].hashSize;\n    signature = await rsa.sign(msg, privateJwk, hash, localOpt);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return signature;\n}\n\n/**\n * Verify message with given public key\n * @param {Uint8Array} msg - A plaintext message to be verified.\n * @param {Uint8Array} sig - Signature byte array.\n * @param {Key} publicKey - Public key object for verification.\n * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.\n * @param {RSASigningOption|ECSigningOption} [options={}] - Signing options.\n * @return {Promise<boolean>} - Result of verification.\n * @throws {Error} - Throws if NonKeyObject or UnsupportedKeyType.\n */\nexport async function verify(msg, sig, publicKey, hash = 'SHA-256', options = {}){\n  if(!(publicKey instanceof Key)) throw new Error('NonKeyObject');\n  const publicJwk = await publicKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let valid;\n  if (publicJwk.kty === 'EC'){\n    if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';\n    valid = await ec.verify(msg, sig, publicJwk, hash, localOpt.format);\n  }\n  else if (publicJwk.kty === 'RSA') {\n    if(typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';\n    if(typeof localOpt.saltLength === 'undefined') localOpt.saltLength = params.hashes[hash].hashSize;\n    valid = await rsa.verify(msg, sig, publicJwk, hash, localOpt);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return valid;\n}\n\n\n\n/**\n * Encryption with public key algorithm. in case of ECDH.\n * Session key is derived from HKDF and the data itself will be encrypted by symmetric cipher.\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Key} publicKey - Public key object.\n * @param {RSAEncryptionOption|ECEncryptionOptions} [options={}] - Encryption options.\n * @return {Promise<PKCCiphertextObject>} - Encrypted message object.\n * @throws {Error} - Throws if NonKeyObject, MissingOrInvalidPrivateKeyForECDH, or UnsupportedKeyType.\n */\nexport async function encrypt(msg, publicKey, options = {}){\n  if(!(publicKey instanceof Key)) throw new Error('NonKeyObject');\n  const publicJwk = await publicKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let ciphertext = {};\n  if (publicJwk.kty === 'EC'){\n    if(!localOpt.privateKey || !(localOpt.privateKey instanceof Key)) throw new Error('MissingOrInvalidPrivateKeyForECDH');\n    localOpt.privateKey = await localOpt.privateKey.export('jwk');\n    ciphertext = await pkcec.encrypt(msg, publicJwk, localOpt);\n  }\n  else if (publicJwk.kty === 'RSA') {\n    if(typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';\n    if(typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);\n    ciphertext.data = await rsa.encrypt(msg, publicJwk, localOpt.hash, localOpt.label);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return ciphertext;\n}\n\n\n/**\n * Decryption with public key algorithm. in case of ECDH\n * Session key is derived from HKDF and the data itself will be decrypted by symmetric cipher.\n * @param {Uint8Array} data - Encrypted message body, i.e., PKCCiphertextObject.data.\n * @param {Key} privateKey - Private key object\n * @param {RSAEncryptionOption|ECDecryptionOptions} [options={}] - Decryption Options.\n * @return {Promise<Uint8Array>} - Decrypted message byte array.\n * @throws {Error} - Throws if NonKeyObject, MissingPublicKeyForECDH, or UnsupportedKeyType.\n */\nexport async function decrypt(data, privateKey, options = {}){\n  if(!(privateKey instanceof Key)) throw new Error('NonKeyObject');\n  const privateJwk = await privateKey.export('jwk');\n  const localOpt = cloneDeep(options);\n\n  let msg;\n  if (privateJwk.kty === 'EC'){\n    if(!localOpt.publicKey) throw new Error('MissingPublicKeyForECDH');\n    localOpt.publicKey = await localOpt.publicKey.export('jwk');\n    msg = await pkcec.decrypt(data, privateJwk, localOpt);\n  }\n  else if (privateJwk.kty === 'RSA') {\n    if(typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';\n    if(typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);\n    msg = await rsa.decrypt(data, privateJwk, localOpt.hash, localOpt.label);\n  }\n  else throw new Error('UnsupportedKeyType');\n\n  return msg;\n}\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/pkc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 233,
    "kind": "function",
    "name": "generateKey",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{generateKey}",
    "description": "Generate key pair in JWK format",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "'EC'",
          "'RSA'"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'EC'",
        "defaultRaw": "'EC'",
        "name": "keyType",
        "description": "Type of public/private key."
      },
      {
        "nullable": null,
        "types": [
          "ECKeyGenerationOption",
          "RSAKeyGenerationOption"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Key generation options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>"
      ],
      "spread": false,
      "description": "Generated key pair in JWK format."
    }
  },
  {
    "__docId__": 234,
    "kind": "function",
    "name": "sign",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~sign",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{sign}",
    "description": "Sign message with given private key in jwk",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message byte array to be signed."
      },
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": "Private key object for signing."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASigningOption",
          "ECSigningOption"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Signing options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Signature byte array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonKeyObject or UnsupportedKeyType."
      }
    ]
  },
  {
    "__docId__": 235,
    "kind": "function",
    "name": "verify",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~verify",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{verify}",
    "description": "Verify message with given public key",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "A plaintext message to be verified."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "sig",
        "description": "Signature byte array."
      },
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": "Public key object for verification."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'."
      },
      {
        "nullable": null,
        "types": [
          "RSASigningOption",
          "ECSigningOption"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Signing options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Result of verification."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonKeyObject or UnsupportedKeyType."
      }
    ]
  },
  {
    "__docId__": 236,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{encrypt}",
    "description": "Encryption with public key algorithm. in case of ECDH.\nSession key is derived from HKDF and the data itself will be encrypted by symmetric cipher.",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Plaintext message to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": "Public key object."
      },
      {
        "nullable": null,
        "types": [
          "RSAEncryptionOption",
          "ECEncryptionOptions"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Encryption options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<PKCCiphertextObject>"
      ],
      "spread": false,
      "description": "Encrypted message object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonKeyObject, MissingOrInvalidPrivateKeyForECDH, or UnsupportedKeyType."
      }
    ]
  },
  {
    "__docId__": 237,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-utils/src/pkc.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkc.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkc.js",
    "importStyle": "{decrypt}",
    "description": "Decryption with public key algorithm. in case of ECDH\nSession key is derived from HKDF and the data itself will be decrypted by symmetric cipher.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Encrypted message body, i.e., PKCCiphertextObject.data."
      },
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": "Private key object"
      },
      {
        "nullable": null,
        "types": [
          "RSAEncryptionOption",
          "ECDecryptionOptions"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Decryption Options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Uint8Array>"
      ],
      "spread": false,
      "description": "Decrypted message byte array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if NonKeyObject, MissingPublicKeyForECDH, or UnsupportedKeyType."
      }
    ]
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/pkcec.js",
    "content": "/**\n * pkcec.js\n */\n\nimport random from 'js-crypto-random';\nimport ec from 'js-crypto-ec';\nimport hkdf from 'js-crypto-hkdf';\nimport aes from 'js-crypto-aes';\n\nimport params from './params.js';\n\nexport async function encrypt(\n  msg, publicKey,\n  { privateKey, hash='SHA-256', encrypt='AES-GCM', keyLength=32, iv=null, info='' }\n) {\n  const sharedSecret = await ec.deriveSecret(publicKey, privateKey);\n  const sessionKeySalt = await hkdf.compute(sharedSecret, hash, keyLength, info);\n\n  // TODO: other iv-required algorithms\n  switch (encrypt) {\n  case 'AES-GCM': {\n    iv = (!iv)\n      ? await random.getRandomBytes(params.ciphers[encrypt].ivLength)\n      : iv;\n    break;\n  }\n  default:\n    throw new Error('UnsupportedSessionKeyAlgorithm');\n  }\n\n  const data = await aes.encrypt(msg, sessionKeySalt.key, {name: encrypt, iv}); // no specification of tagLength and additionalData\n\n  return {data, salt: sessionKeySalt.salt, iv};\n}\n\n\nexport async function decrypt(\n  data, privateKey,\n  { publicKey, hash='SHA-256', encrypt='AES-GCM', keyLength=32, info='', salt=null, iv=null }\n) {\n  const sharedSecret = await ec.deriveSecret(publicKey, privateKey);\n  const sessionKeySalt = await hkdf.compute(sharedSecret, hash, keyLength, info, salt);\n\n  let msg;\n  if(Object.keys(params.ciphers).indexOf(encrypt) >= 0){\n    msg = await aes.decrypt(data, sessionKeySalt.key, {name: encrypt, iv}); // no specification of tagLength and additionalData\n  }\n  else throw new Error('UnsupportedSessionKeyAlgorithm');\n\n  return msg;\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/pkcec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "function",
    "name": "encrypt",
    "memberof": "packages/js-crypto-utils/src/pkcec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkcec.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkcec.js",
    "importStyle": "{encrypt}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "publicKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"privateKey\": *, \"hash\": *, \"encrypt\": *, \"keyLength\": *, \"iv\": *, \"info\": *}"
        ],
        "defaultRaw": {
          "privateKey": null,
          "hash": null,
          "encrypt": null,
          "keyLength": null,
          "iv": null,
          "info": null
        },
        "defaultValue": "{\"privateKey\":null,\"hash\":null,\"encrypt\":null,\"keyLength\":null,\"iv\":null,\"info\":null}"
      }
    ],
    "return": {
      "types": [
        "{\"data\": *, \"salt\": *, \"iv\": *}"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "decrypt",
    "memberof": "packages/js-crypto-utils/src/pkcec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-crypto-utils/src/pkcec.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-crypto-utils/src/pkcec.js",
    "importStyle": "{decrypt}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "privateKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"publicKey\": *, \"hash\": *, \"encrypt\": *, \"keyLength\": *, \"info\": *, \"salt\": *, \"iv\": *}"
        ],
        "defaultRaw": {
          "publicKey": null,
          "hash": null,
          "encrypt": null,
          "keyLength": null,
          "info": null,
          "salt": null,
          "iv": null
        },
        "defaultValue": "{\"publicKey\":null,\"hash\":null,\"encrypt\":null,\"keyLength\":null,\"info\":null,\"salt\":null,\"iv\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "packages/js-crypto-utils/src/typedef.js",
    "content": "/**\n * typedef.js\n */\n\n/**\n * @typedef {Object} PKCCiphertextObject - Ciphertext of public key encryption.\n * @property {Uint8Array} data - Encrypted message body.\n * @property {Uint8Array} [salt] - Active only for ECDH+AES\n * @property {Uint8Array} [iv] - Active only for ECDH+AES\n */\n\n/**\n * @typedef {Object} ECKeyGenerationOption - Options for EC key generation.\n * @property {String} [namedCurve='P-256'] - Name of elliptic curve like 'P-256'.\n */\n\n/**\n * @typedef {Object} RSAKeyGenerationOption - Options for RSA key generation.\n * @property {Number} [modulusLength=2048] - Modulus length in bit.\n * @property {Uint8Array} [publicExponent=new Uint8Array([0x01, 0x00, 0x01])] - Public exponent.\n */\n\n/**\n * @typedef {Object} ECSigningOption - Options for EC key signing.\n * @property {'raw'|'der'} format - EC Signature format in DER or Raw.\n */\n\n/**\n * @typedef {Object} RSASigningOption - Options for RSA key signing.\n * @property {'RSA-PSS'|'RSASSA-PKCS1-v1_5'} [name='RSA-PSS'] - 'RSA-PSS' or  'RSASSA-PKCS1-v1_5'.\n * @property {Number} [saltLength] - For RSA-PSS, this must be specified.\n */\n\n/**\n * @typedef {Object} ECEncryptionOptions - Options for ECDH+AES encryption.\n * @property {Key} privateKey - Private Key Object for ECDH.\n * @property {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'\n * @property {String} [encrypt='AES-GCM'] - Name of encryption algorithm like AES-GCM after ECDH.\n * @property {Number} [keyLength=32] - Key length for AES in octet.\n * @property {Uint8Array|null} [iv=null] - Initial vector for AES-GCM.\n * @property {String} [info=''] - Info for AES-GCM.\n */\n\n/**\n * @typedef {Object} ECDecryptionOptions - Options for ECDH+AES decryption.\n * @property {Key} publicKey - Public Key Object for ECDH.\n * @property {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'\n * @property {String} [encrypt='AES-GCM'] - Name of encryption algorithm like AES-GCM after ECDH.\n * @property {Number} [keyLength=32] - Key length for AES in octet.\n * @property {Uint8Array|null} [iv=null] - Initial vector for AES-GCM.\n * @property {String} [info=''] - Info for AES-GCM.\n */\n\n/**\n * @typedef {Object} RSAEncryptionOption - Options for RSA-OAEP encryption.\n * @property {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'\n * @property {Uint8Array} [label=new Uint8Array([])] - RSA-OAEP label.\n */",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/src/typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "typedef",
    "name": "PKCCiphertextObject",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~PKCCiphertextObject",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Encrypted message body."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "salt",
        "description": "Active only for ECDH+AES"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "name": "iv",
        "description": "Active only for ECDH+AES"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "PKCCiphertextObject"
    }
  },
  {
    "__docId__": 243,
    "kind": "typedef",
    "name": "ECKeyGenerationOption",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~ECKeyGenerationOption",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'P-256'",
        "defaultRaw": "'P-256'",
        "name": "namedCurve",
        "description": "Name of elliptic curve like 'P-256'."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ECKeyGenerationOption"
    }
  },
  {
    "__docId__": 244,
    "kind": "typedef",
    "name": "RSAKeyGenerationOption",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~RSAKeyGenerationOption",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2048",
        "defaultRaw": 2048,
        "name": "modulusLength",
        "description": "Modulus length in bit."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new Uint8Array([0x01, 0x00, 0x01])",
        "defaultRaw": "new Uint8Array([0x01, 0x00, 0x01])",
        "name": "publicExponent",
        "description": "Public exponent."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RSAKeyGenerationOption"
    }
  },
  {
    "__docId__": 245,
    "kind": "typedef",
    "name": "ECSigningOption",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~ECSigningOption",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "'raw'",
          "'der'"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "EC Signature format in DER or Raw."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ECSigningOption"
    }
  },
  {
    "__docId__": 246,
    "kind": "typedef",
    "name": "RSASigningOption",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~RSASigningOption",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "'RSA-PSS'",
          "'RSASSA-PKCS1-v1_5'"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'RSA-PSS'",
        "defaultRaw": "'RSA-PSS'",
        "name": "name",
        "description": "'RSA-PSS' or  'RSASSA-PKCS1-v1_5'."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "saltLength",
        "description": "For RSA-PSS, this must be specified."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RSASigningOption"
    }
  },
  {
    "__docId__": 247,
    "kind": "typedef",
    "name": "ECEncryptionOptions",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~ECEncryptionOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": "Private Key Object for ECDH."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'AES-GCM'",
        "defaultRaw": "'AES-GCM'",
        "name": "encrypt",
        "description": "Name of encryption algorithm like AES-GCM after ECDH."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "32",
        "defaultRaw": 32,
        "name": "keyLength",
        "description": "Key length for AES in octet."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "null"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "iv",
        "description": "Initial vector for AES-GCM."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "info",
        "description": "Info for AES-GCM."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ECEncryptionOptions"
    }
  },
  {
    "__docId__": 248,
    "kind": "typedef",
    "name": "ECDecryptionOptions",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~ECDecryptionOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Key"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": "Public Key Object for ECDH."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'AES-GCM'",
        "defaultRaw": "'AES-GCM'",
        "name": "encrypt",
        "description": "Name of encryption algorithm like AES-GCM after ECDH."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "32",
        "defaultRaw": 32,
        "name": "keyLength",
        "description": "Key length for AES in octet."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "null"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "iv",
        "description": "Initial vector for AES-GCM."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "info",
        "description": "Info for AES-GCM."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ECDecryptionOptions"
    }
  },
  {
    "__docId__": 249,
    "kind": "typedef",
    "name": "RSAEncryptionOption",
    "memberof": "packages/js-crypto-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-crypto-utils/src/typedef.js~RSAEncryptionOption",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-256'",
        "defaultRaw": "'SHA-256'",
        "name": "hash",
        "description": "Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new Uint8Array([])",
        "defaultRaw": "new Uint8Array([])",
        "name": "label",
        "description": "RSA-OAEP label."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RSAEncryptionOption"
    }
  },
  {
    "__docId__": 250,
    "kind": "file",
    "name": "packages/js-x509-utils/src/ec.js",
    "content": "/**\n * ec.js\n */\n\nimport params from './params.js';\nimport ec from 'js-crypto-ec';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Sign encoded tbsCertificate with given signature algorithm under the JWK private key.\n * @param {Uint8Array} encodedTbsCertificate - TBS Certificate encoded to Uint8Array.\n * @param {JsonWebKey} privateJwk - Private key object in JWK format.\n * @param {String} signatureAlgorithm - Signature algorithm name like 'ecdsa-with-sha256'.\n * @returns {Promise<{data: Buffer, unused: Number}>} - ASN.1 encoded signature.\n */\nexport async function getAsn1Signature(encodedTbsCertificate, privateJwk, signatureAlgorithm){\n  const asn1sig = await ec.sign(\n    encodedTbsCertificate,\n    privateJwk,\n    params.signatureAlgorithms[signatureAlgorithm].hash,\n    'der'\n  );\n  return {unused: 0, data: Buffer.from(asn1sig)};\n}",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/ec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/ec.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/ec.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/ec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 252,
    "kind": "function",
    "name": "getAsn1Signature",
    "memberof": "packages/js-x509-utils/src/ec.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/ec.js~getAsn1Signature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/ec.js",
    "importStyle": "{getAsn1Signature}",
    "description": "Sign encoded tbsCertificate with given signature algorithm under the JWK private key.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<{data: Buffer, unused: Number}>} - ASN.1 encoded signature."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "encodedTbsCertificate",
        "description": "TBS Certificate encoded to Uint8Array."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "Private key object in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "signatureAlgorithm",
        "description": "Signature algorithm name like 'ecdsa-with-sha256'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{data: Buffer, unused: Number}>"
      ],
      "spread": false,
      "description": "ASN.1 encoded signature."
    }
  },
  {
    "__docId__": 253,
    "kind": "file",
    "name": "packages/js-x509-utils/src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {fromJwk, toJwk, parse} from './x509.js';\n\nexport default {fromJwk, toJwk, parse};\nexport {fromJwk, toJwk, parse};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 254,
    "kind": "file",
    "name": "packages/js-x509-utils/src/params.js",
    "content": "/**\n * params.js\n */\n\nexport default {\n// oid is referred to\n// rfc7427 https://tools.ietf.org/html/rfc7427\n// http://www.umich.edu/~x509/ssleay/asn1-oids.html\n  signatureAlgorithms: {\n    // ECDSA\n    'ecdsa-with-sha256': {oid: [1, 2, 840, 10045, 4, 3, 2], hash: 'SHA-256'},\n    'ecdsa-with-sha384': {oid: [1, 2, 840, 10045, 4, 3, 3], hash: 'SHA-384'},\n    'ecdsa-with-sha512': {oid: [1, 2, 840, 10045, 4, 3, 4], hash: 'SHA-512'},\n    'ecdsa-with-sha1': {oid: [1, 2, 840, 10045, 4, 3, 1], hash: 'SHA-1'},\n\n    // RSASSA-PKCS1-v1_5\n    'sha256WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 11], hash: 'SHA-256'},\n    'sha384WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 12], hash: 'SHA-384'},\n    'sha512WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 13], hash: 'SHA-512'},\n    'sha1WithRSAEncryption': {oid: [1, 2, 840, 113549, 1, 1, 5], hash: 'SHA-1'},\n\n    // RSA-PSS\n    'rsassaPss': {oid: [1, 2, 840, 113549, 1, 1, 10]}, // default params are sha-1...\n  },\n\n  maskGeneratorFunctions: {\n    'MGF1': {oid: [1, 2, 840, 113549, 1, 1, 8]}\n  },\n\n  hashes: {\n    'SHA-1': {oid: [1, 3, 14, 3, 2, 26]},\n    'SHA-256': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 1]},\n    'SHA-384': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 2]},\n    'SHA-512': {oid: [2, 16, 840, 1, 101, 3, 4, 2, 3]},\n  },\n\n  ans1null: [0x05, 0x00]\n};\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/params.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 255,
    "kind": "file",
    "name": "packages/js-x509-utils/src/rsa.js",
    "content": "/**\n * rsa.js\n */\n\nimport params from './params.js';\nimport * as util from './util.js';\nimport rsa from 'js-crypto-rsa';\nimport asn from 'asn1.js';\nconst BN = asn.bignum;\nimport rfc5280 from 'asn1.js-rfc5280';\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Sign TBSCertificate under the issuer's RSA private key in JWK format.\n * @param {Uint8Array} encodedTbsCertificate - Message body to be signed.\n * @param {JsonWebKey} privateJwk - A RSA signing key in JWK format.\n * @param {String} algorithm - Name of signing algorithm like 'sha256WithRSAEncryption'.\n * @param {RSAPSSObject} [pssParams] - Effective only for RSASSA-PSS.\n * @returns {Promise<{data: Buffer, unused: number}>} - ASN.1 parsed signature object.\n */\nexport async function getSignature(encodedTbsCertificate, privateJwk, algorithm, pssParams){\n  let signature;\n  if(algorithm === 'rsassaPss'){\n    signature = await rsa.sign( encodedTbsCertificate, privateJwk, pssParams.hash, { name: 'RSA-PSS', saltLength: pssParams.saltLength });\n  }\n  else {\n    signature = await rsa.sign( encodedTbsCertificate, privateJwk, params.signatureAlgorithms[algorithm].hash, { name: 'RSASSA-PKCS1-v1_5' });\n  }\n  return {unused: 0, data: Buffer.from(signature)};\n}\n\n/**\n * Encode RSA-PSS parsed params to ASN.1 Uint8Array binary\n * @param {RSAPSSObject} options - RSA-PSS params as a parsed object.\n * @returns {DER} - Encoded RSA-PSS object.\n */\nexport function encodeRsassaPssParams(options){\n  if (options.hash === 'SHA-1' && options.saltLength === 20 && options.explicit === false) return Buffer.from([0x30, 0x00]);\n  else {\n    const pssParams = {\n      hashAlgorithm: {\n        algorithm: params.hashes[options.hash].oid,\n        parameters: Buffer.from(params.ans1null)\n      },\n      maskGenAlgorithm: {\n        algorithm: params.maskGeneratorFunctions.MGF1.oid, // only MGF1 is available\n        parameters: rfc5280.AlgorithmIdentifier.encode({\n          algorithm: params.hashes[options.hash].oid,\n          parameters: Buffer.from(params.ans1null)\n        }, 'der')\n      },\n      saltLength: new BN(options.saltLength),\n      trailerField: new BN(1) // default\n    };\n\n    return RSASSAPSSParams.encode(pssParams, 'der');\n  }\n}\n\n\n/**\n * Parse encoded RSA-PSS parameters represented in Uint8Array.\n * @param {Buffer|Uint8Array} pssParams - Extracted RSA-PSS parameter byte sequence.\n * @returns {{hashForMgf: string, saltLength: number, mgf: string, hash: string}}\n * @throws {Error} - Throws if InvalidCertificateFormat.\n */\nexport function decodeRsassaPssParams(pssParams){\n  let returnParams;\n  if((new Uint8Array(pssParams)).toString() !== (new Uint8Array([0x30, 0x00]).toString())){\n    // non empty params\n    const decodedParams = RSASSAPSSParams.decode(pssParams, 'der');\n    decodedParams.maskGenAlgorithm.parameters\n      = rfc5280.AlgorithmIdentifier.decode(decodedParams.maskGenAlgorithm.parameters, 'der');\n    decodedParams.saltLength = decodedParams.saltLength.toNumber();\n    decodedParams.trailerField = decodedParams.trailerField.toNumber();\n\n    const hash = util.getKeyFromOid(decodedParams.hashAlgorithm.algorithm, params.hashes);\n    const mgf = util.getKeyFromOid(decodedParams.maskGenAlgorithm.algorithm, params.maskGeneratorFunctions);\n    const hashForMgf = util.getKeyFromOid(decodedParams.maskGenAlgorithm.parameters.algorithm, params.hashes);\n    if(hash.length === 0 || mgf.length === 0 || hashForMgf === 0) throw new Error('InvalidCertificateFormat');\n\n    returnParams = {hash: hash[0], mgf: mgf[0], hashForMgf: hashForMgf[0], saltLength: decodedParams.saltLength};\n  }\n  else {\n    // if empty, defaults are SHA-1 for Sign and MGF1 with SHA-1, using salt of length 20\n    returnParams = {hash: 'SHA-1', mgf: 'MGF1', hashForMgf: 'SHA-1', saltLength: 20};\n  }\n\n  return returnParams;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n// RFC4055 https://tools.ietf.org/html/rfc4055\n// RFC7427 https://tools.ietf.org/html/rfc7427\n// RSASSA-PSS-params  ::=  SEQUENCE  {\n//          hashAlgorithm      [0] HashAlgorithm DEFAULT\n//                                    sha1Identifier,\n//          maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\n//                                    mgf1SHA1Identifier,\n//          saltLength         [2] INTEGER DEFAULT 20,\n//          trailerField       [3] INTEGER DEFAULT 1  }\nconst RSASSAPSSParams = asn.define('rsassaPssParams', function() {\n  this.seq().obj(\n    this.key('hashAlgorithm').explicit(0).use(rfc5280.AlgorithmIdentifier),\n    this.key('maskGenAlgorithm').explicit(1).use(rfc5280.AlgorithmIdentifier),\n    this.key('saltLength').explicit(2).int(),\n    this.key('trailerField').explicit(3).int()\n  );\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/rsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "variable",
    "name": "BN",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~BN",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 257,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 258,
    "kind": "function",
    "name": "getSignature",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~getSignature",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{getSignature}",
    "description": "Sign TBSCertificate under the issuer's RSA private key in JWK format.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<{data: Buffer, unused: number}>} - ASN.1 parsed signature object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "encodedTbsCertificate",
        "description": "Message body to be signed."
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "A RSA signing key in JWK format."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "algorithm",
        "description": "Name of signing algorithm like 'sha256WithRSAEncryption'."
      },
      {
        "nullable": null,
        "types": [
          "RSAPSSObject"
        ],
        "spread": false,
        "optional": true,
        "name": "pssParams",
        "description": "Effective only for RSASSA-PSS."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{data: Buffer, unused: number}>"
      ],
      "spread": false,
      "description": "ASN.1 parsed signature object."
    }
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "encodeRsassaPssParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~encodeRsassaPssParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{encodeRsassaPssParams}",
    "description": "Encode RSA-PSS parsed params to ASN.1 Uint8Array binary",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{DER} - Encoded RSA-PSS object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "RSAPSSObject"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "RSA-PSS params as a parsed object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DER"
      ],
      "spread": false,
      "description": "Encoded RSA-PSS object."
    }
  },
  {
    "__docId__": 260,
    "kind": "function",
    "name": "decodeRsassaPssParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~decodeRsassaPssParams",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": "{decodeRsassaPssParams}",
    "description": "Parse encoded RSA-PSS parameters represented in Uint8Array.",
    "lineNumber": 68,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{hashForMgf: string, saltLength: number, mgf: string, hash: string}}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer",
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "pssParams",
        "description": "Extracted RSA-PSS parameter byte sequence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{hashForMgf: string, saltLength: number, mgf: string, hash: string}"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidCertificateFormat."
      }
    ]
  },
  {
    "__docId__": 261,
    "kind": "variable",
    "name": "RSASSAPSSParams",
    "memberof": "packages/js-x509-utils/src/rsa.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/rsa.js~RSASSAPSSParams",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/rsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 262,
    "kind": "file",
    "name": "packages/js-x509-utils/src/typedef.js",
    "content": "/**\n * typedef.js\n */\n\n/**\n * @typedef {'der'|'pem'} AsnFormat - 'der' or 'pem'\n */\n\n/**\n * @typedef {Buffer|Uint8Array} DER - ASN.1 DER.\n */\n\n/**\n * @typedef {String} PEM - ASN.1 PEM.\n */\n\n/**\n * @typedef {Object} X509EncodingOptions - Options to generate X.509 public key certificate.\n * @property {String} [signature='ecdsa-with-sha256'] - Signature algorithm like 'ecdsa-with-sha256'.\n * @property {Number} [days=3650] - The number of days to expire.\n * @property {X509Issuer} issuer - Object specifying the issuer of the certificate.\n * @property {X509Subject} subject - Object specifying subject of the certificate.\n * @property {RSAPSSObject} [pssParams={}] - RSASSA-PSS parameters.\n */\n\n/**\n * @typedef {Object} X509Issuer - An object specifying the X.509 issuer.\n * @property {String} [organizationName='Self'] - Name of issuer organization.\n */\n\n/**\n * @typedef {Object} X509Subject - An object specifying the X.509 subject.\n * @property {String} [organizationName='Self'] - Name of subject organization.\n */\n\n/**\n * @typedef {Object} RSAPSSObject - RSASSA-PSS ASN.1 encoding object.\n * @property {Number} [saltLength=20] - RSA-PSS param. Length of salt in octet.\n * @property {String} [hash='SHA-1'] - RSA-PSS param. Name of hash algorithm like 'SHA-256'\n * @property {boolean} [explicit=false] - RSA-PSS param. True if it is explicit.\n */",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 263,
    "kind": "typedef",
    "name": "AsnFormat",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~AsnFormat",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "'der'",
        "'pem'"
      ],
      "optional": false,
      "name": "AsnFormat"
    }
  },
  {
    "__docId__": 264,
    "kind": "typedef",
    "name": "DER",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~DER",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "Buffer",
        "Uint8Array"
      ],
      "optional": false,
      "name": "DER"
    }
  },
  {
    "__docId__": 265,
    "kind": "typedef",
    "name": "PEM",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~PEM",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "String"
      ],
      "optional": false,
      "name": "PEM"
    }
  },
  {
    "__docId__": 266,
    "kind": "typedef",
    "name": "X509EncodingOptions",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~X509EncodingOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'ecdsa-with-sha256'",
        "defaultRaw": "'ecdsa-with-sha256'",
        "name": "signature",
        "description": "Signature algorithm like 'ecdsa-with-sha256'."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3650",
        "defaultRaw": 3650,
        "name": "days",
        "description": "The number of days to expire."
      },
      {
        "nullable": null,
        "types": [
          "X509Issuer"
        ],
        "spread": false,
        "optional": false,
        "name": "issuer",
        "description": "Object specifying the issuer of the certificate."
      },
      {
        "nullable": null,
        "types": [
          "X509Subject"
        ],
        "spread": false,
        "optional": false,
        "name": "subject",
        "description": "Object specifying subject of the certificate."
      },
      {
        "nullable": null,
        "types": [
          "RSAPSSObject"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "pssParams",
        "description": "RSASSA-PSS parameters."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "X509EncodingOptions"
    }
  },
  {
    "__docId__": 267,
    "kind": "typedef",
    "name": "X509Issuer",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~X509Issuer",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'Self'",
        "defaultRaw": "'Self'",
        "name": "organizationName",
        "description": "Name of issuer organization."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "X509Issuer"
    }
  },
  {
    "__docId__": 268,
    "kind": "typedef",
    "name": "X509Subject",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~X509Subject",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'Self'",
        "defaultRaw": "'Self'",
        "name": "organizationName",
        "description": "Name of subject organization."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "X509Subject"
    }
  },
  {
    "__docId__": 269,
    "kind": "typedef",
    "name": "RSAPSSObject",
    "memberof": "packages/js-x509-utils/src/typedef.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/typedef.js~RSAPSSObject",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "20",
        "defaultRaw": 20,
        "name": "saltLength",
        "description": "RSA-PSS param. Length of salt in octet."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SHA-1'",
        "defaultRaw": "'SHA-1'",
        "name": "hash",
        "description": "RSA-PSS param. Name of hash algorithm like 'SHA-256'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "explicit",
        "description": "RSA-PSS param. True if it is explicit."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RSAPSSObject"
    }
  },
  {
    "__docId__": 270,
    "kind": "file",
    "name": "packages/js-x509-utils/src/util.js",
    "content": "/**\n * util.js\n */\n\n/**\n *\n * @param {Array} oid - ASN.1 object identifier.\n * @param {Object} dict - dictionary to be searched.\n * @returns {string[]} - Returns array of keys that match the oid.\n */\nexport const getKeyFromOid = (oid, dict) => Object.keys(dict).filter(\n  (key) => dict[key].oid.toString() === oid.toString()\n);",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 271,
    "kind": "function",
    "name": "getKeyFromOid",
    "memberof": "packages/js-x509-utils/src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/util.js~getKeyFromOid",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/util.js",
    "importStyle": "{getKeyFromOid}",
    "description": "",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string[]} - Returns array of keys that match the oid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "oid",
        "description": "ASN.1 object identifier."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "dict",
        "description": "dictionary to be searched."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "Returns array of keys that match the oid."
    }
  },
  {
    "__docId__": 272,
    "kind": "file",
    "name": "packages/js-x509-utils/src/x509.js",
    "content": "/**\n * x509.js\n */\n\nimport params from './params.js';\nimport * as rsa from './rsa.js';\nimport * as ecdsa from './ec.js';\nimport BN from 'bn.js';\nimport rfc5280 from 'asn1.js-rfc5280';\nimport jseu from 'js-encoding-utils';\nimport random from 'js-crypto-random';\nimport {Key} from 'js-crypto-key-utils';\n\nimport BufferMod from 'buffer';\nconst Buffer = BufferMod.Buffer;\n\n/**\n * Convert public key in JWK format to X.509 PEM or DER object.\n * @param {JsonWebKey} publicJwk - A public key object in JWK format to be encoded and signed to X.509\n * @param {JsonWebKey} privateJwk - A private key object in JWK format by which would be used to sign the public key.\n * @param {AsnFormat} [format='pem'] - Output format of X.509 certificate, 'pem' or 'der'\n * @param {X509EncodingOptions} [options={}] - X.509 encoding options\n * @return {Promise<DER|PEM>} - Generated X.509 public key certificate in intended format.\n * @throws {Error} - Throws if InvalidFormatSpecification or UnsupportedKeyType.\n */\nexport async function fromJwk(publicJwk, privateJwk, format = 'pem', options = {}) {\n  // default values\n  if (typeof options.signature === 'undefined') options.signature = 'ecdsa-with-sha256';\n  if (typeof options.days === 'undefined') options.days = 3650;\n  if (typeof options.issuer === 'undefined') options.issuer = {organizationName: 'Self'};\n  if (typeof options.subject === 'undefined') options.subject = {organizationName: 'Self'};\n\n  // default params for RSA-PSS\n  if (typeof options.pssParams === 'undefined') options.pssParams = {};\n  if (typeof options.pssParams.saltLength === 'undefined' && options.signature === 'rsassaPss') options.pssParams.saltLength = 20;\n  if (typeof options.pssParams.hash === 'undefined' && options.signature === 'rsassaPss') options.pssParams.hash = 'SHA-1';\n  if (typeof options.pssParams.explicit === 'undefined' && options.signature === 'rsassaPss') options.pssParams.explicit = true;\n\n  ///////////////////////////////\n  // elements of TBSCertificate\n  ///////////////////////////////\n\n  const version = 0; // default, TODO: other versions?\n\n  // random serial numbers\n  const rand = await random.getRandomBytes(20); // max 20 octets\n  const serialNumber = new BN(rand);\n\n  // TODO: throw exception if private jwk keytype doesn't match signatureAlgorithm\n  const signature = { algorithm: params.signatureAlgorithms[options.signature].oid };\n  if (options.signature === 'rsassaPss') {\n    signature.parameters = rsa.encodeRsassaPssParams(options.pssParams);\n  } else signature.parameters = Buffer.from(params.ans1null);\n\n  const issuer = {type: 'rdnSequence', value: setRDNSequence(options.issuer)};\n\n  const current = (Date.now() / 1000) * 1000;\n  const validity = {\n    notBefore: {type: 'utcTime', value: current},\n    notAfter: {type: 'utcTime', value: (current + options.days * 86400 * 1000)}\n  };\n\n  const subject = {type: 'rdnSequence', value: setRDNSequence(options.subject)};\n\n  const publicObj = new Key('jwk', publicJwk);\n  const spkiDer = Buffer.from(await publicObj.export('der', {compact: false, outputPublic: true})); // {compact: false} is active only for ecc keys\n  const subjectPublicKeyInfo = rfc5280.SubjectPublicKeyInfo.decode(spkiDer, 'der');\n\n  // elements of Certificate\n  const tbsCertificate = {version, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo};\n  const signatureAlgorithm = tbsCertificate.signature; // This must be the same as tbsCertificate.signature field (as specified in RFC).\n\n  // generate signature value\n  const encodedTbsCertificate = rfc5280.TBSCertificate.encode(tbsCertificate, 'der');\n  let signatureValue;\n  if (privateJwk.kty === 'EC'){\n    signatureValue = await ecdsa.getAsn1Signature(encodedTbsCertificate, privateJwk, options.signature);\n  } else if (privateJwk.kty === 'RSA') {\n    signatureValue = await rsa.getSignature(\n      encodedTbsCertificate, privateJwk, options.signature, options.pssParams\n    );\n  } else throw new Error ('UnsupportedKeyType');\n\n  // construct Certificate\n  const certBin = rfc5280.Certificate.encode({tbsCertificate, signatureAlgorithm, signature: signatureValue}, 'der');\n\n  if (format === 'pem') {\n    return jseu.formatter.binToPem(certBin, 'certificate');\n  }\n  else if (format === 'der') {\n    return certBin;\n  }\n  else throw new Error('InvalidFormatSpecification');\n}\n\n/**\n * Convert X.509 certificate to a JWK object.\n * @param {PEM|DER} certX509 - X.509 public key certificate in DER or PEM format.\n * @param {AsnFormat} format - 'der' or 'pem'\n * @return {Promise<JsonWebKey>} - Extracted key object in JWK format.\n * @throws {Error} - Throws if InvalidFormatSpecification.\n */\nexport async function toJwk(certX509, format = 'pem'){\n  let x509bin;\n  if (format === 'pem') x509bin = jseu.formatter.pemToBin(certX509);\n  else if (format === 'der') x509bin = certX509;\n  else throw new Error('InvalidFormatSpecification');\n\n  const binKeyBuffer = Buffer.from(x509bin); // This must be Buffer object to get decoded;\n\n  const decoded = rfc5280.Certificate.decode(binKeyBuffer, 'der'); // decode binary x509-formatted public key to parsed object\n  const binSpki = rfc5280.SubjectPublicKeyInfo.encode(decoded.tbsCertificate.subjectPublicKeyInfo, 'der');\n  const publicObj = new Key('der', binSpki);\n  return await publicObj.export('jwk', {outputPublic: true});\n}\n\n\n/**\n * Parse X.509 certificate and return DER-encoded TBSCertificate and DER encoded signature\n * @param {DER|PEM} certX509 - X.509 public key certificate in DER or PEM format.\n * @param {AsnFormat} format - 'der' or 'pem'\n * @return {{tbsCertificate: Uint8Array, signatureValue: Uint8Array, signatureAlgorithm: String}} - Parsed object.\n * @throws {Error} - Throws if UnsupportedSignatureAlgorithm or InvalidFormatSpecification.\n */\nexport function parse(certX509, format = 'pem'){\n\n  let x509bin;\n  if (format === 'pem') x509bin = jseu.formatter.pemToBin(certX509);\n  else if (format === 'der') x509bin = certX509;\n  else throw new Error('InvalidFormatSpecification');\n\n  const binKeyBuffer = Buffer.from(x509bin); // This must be Buffer object to get decoded;\n\n  const decoded = rfc5280.Certificate.decode(binKeyBuffer, 'der'); // decode binary x509-formatted public key to parsed object\n  const sigOid = decoded.signatureAlgorithm.algorithm;\n  const sigParam = decoded.signatureAlgorithm.parameters;\n\n  const filter = Object.keys(params.signatureAlgorithms).filter(\n    (name) => params.signatureAlgorithms[name].oid.toString() === sigOid.toString()\n  );\n  if(filter.length <= 0) throw new Error('UnsupportedSignatureAlgorithm');\n  const signatureAlgorithm = {algorithm: filter[0]};\n\n  if (filter[0] === 'rsassaPss') signatureAlgorithm.parameters = rsa.decodeRsassaPssParams(sigParam);\n  else signatureAlgorithm.parameters = { hash: params.signatureAlgorithms[signatureAlgorithm.algorithm].hash };\n\n  const binTBSCertificate = rfc5280.TBSCertificate.encode(decoded.tbsCertificate, 'der');\n\n  return {\n    tbsCertificate: new Uint8Array(binTBSCertificate),\n    signatureValue: new Uint8Array(decoded.signature.data),\n    signatureAlgorithm\n  };\n}\n\n\n\n/**\n * Set RDN sequence for issuer and subject fields\n * @param {Object} options - RDN Sequence\n * @return {{type: *, value: *}[][]}\n * @throws {Error} - throws if InvalidOptionSpecification or InvalidCountryNameCode.\n */\nfunction setRDNSequence(options) {\n  const encodedArray = Object.keys(options).map((k) => {\n    if (Object.keys(attributeTypeOIDMap).indexOf(k) < 0) throw new Error('InvalidOptionSpecification');\n\n    const type = attributeTypeOIDMap[k];\n    let value;\n    if (['dnQualifier, countryName, serialNumber'].indexOf(k) >= 0) {\n      if (k === 'countryName' && options[k].length !== 2) throw new Error('InvalidCountryNameCode');\n      value = rfc5280.DirectoryString.encode({type: 'printableString', value: options[k]}, 'der');\n    }\n    else value = rfc5280.DirectoryString.encode({type: 'utf8String', value: options[k]}, 'der');\n\n    return {type, value};\n  });\n\n  return [encodedArray];\n}\n\n// https://tools.ietf.org/html/rfc5280#appendix-A\nconst attributeTypeOIDMap = {\n  // X509name DirectoryName\n  name: [2, 5, 4, 41],\n  surname: [2, 5, 4, 4],\n  givenName: [2, 5, 4, 42],\n  initials: [2, 5, 4, 43],\n  generationQualifier: [2, 5, 4, 44],\n\n  commonName: [2, 5, 4, 3], // DirectoryName\n  localityName: [2, 5, 4, 7], // DirectoryName\n  stateOrProvinceName: [2, 5, 4, 8], // DirectoryName\n  organizationName: [2, 5, 4, 10], // DirectoryName\n  organizationalUnitName: [2, 5, 4, 11], // DirectoryName\n  title: [2, 5, 4, 12], // DirectoryName\n\n  dnQualifier: [2, 5, 4, 46], // PrintableString\n  countryName: [2, 5, 4, 6], // PrintableString(2)\n  serialNumber: [2, 5, 4, 5], // PrintableString\n\n  pseudonym: [2, 5, 4, 65], // DirectoryName\n\n  domainComponent: [0, 9, 2342, 19200300, 100, 1, 25], // IA5String https://tools.ietf.org/html/rfc4519\n};",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/src/x509.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 273,
    "kind": "variable",
    "name": "Buffer",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~Buffer",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "fromJwk",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~fromJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{fromJwk}",
    "description": "Convert public key in JWK format to X.509 PEM or DER object.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "publicJwk",
        "description": "A public key object in JWK format to be encoded and signed to X.509"
      },
      {
        "nullable": null,
        "types": [
          "JsonWebKey"
        ],
        "spread": false,
        "optional": false,
        "name": "privateJwk",
        "description": "A private key object in JWK format by which would be used to sign the public key."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'pem'",
        "defaultRaw": "'pem'",
        "name": "format",
        "description": "Output format of X.509 certificate, 'pem' or 'der'"
      },
      {
        "nullable": null,
        "types": [
          "X509EncodingOptions"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "X.509 encoding options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DER|PEM>"
      ],
      "spread": false,
      "description": "Generated X.509 public key certificate in intended format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidFormatSpecification or UnsupportedKeyType."
      }
    ]
  },
  {
    "__docId__": 275,
    "kind": "function",
    "name": "toJwk",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~toJwk",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{toJwk}",
    "description": "Convert X.509 certificate to a JWK object.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "PEM",
          "DER"
        ],
        "spread": false,
        "optional": false,
        "name": "certX509",
        "description": "X.509 public key certificate in DER or PEM format."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "'der' or 'pem'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<JsonWebKey>"
      ],
      "spread": false,
      "description": "Extracted key object in JWK format."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if InvalidFormatSpecification."
      }
    ]
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "parse",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~parse",
    "access": "public",
    "export": true,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": "{parse}",
    "description": "Parse X.509 certificate and return DER-encoded TBSCertificate and DER encoded signature",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "DER",
          "PEM"
        ],
        "spread": false,
        "optional": false,
        "name": "certX509",
        "description": "X.509 public key certificate in DER or PEM format."
      },
      {
        "nullable": null,
        "types": [
          "AsnFormat"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": "'der' or 'pem'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{tbsCertificate: Uint8Array, signatureValue: Uint8Array, signatureAlgorithm: String}"
      ],
      "spread": false,
      "description": "Parsed object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Throws if UnsupportedSignatureAlgorithm or InvalidFormatSpecification."
      }
    ]
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "setRDNSequence",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~setRDNSequence",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": "Set RDN sequence for issuer and subject fields",
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "RDN Sequence"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{type: *, value: *}[][]"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "throws if InvalidOptionSpecification or InvalidCountryNameCode."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 278,
    "kind": "variable",
    "name": "attributeTypeOIDMap",
    "memberof": "packages/js-x509-utils/src/x509.js",
    "static": true,
    "longname": "packages/js-x509-utils/src/x509.js~attributeTypeOIDMap",
    "access": "public",
    "export": false,
    "importPath": "jscu/packages/js-x509-utils/src/x509.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "type": {
      "types": [
        "{\"name\": *, \"surname\": *, \"givenName\": *, \"initials\": *, \"generationQualifier\": *, \"commonName\": *, \"localityName\": *, \"stateOrProvinceName\": *, \"organizationName\": *, \"organizationalUnitName\": *, \"title\": *, \"dnQualifier\": *, \"countryName\": *, \"serialNumber\": *, \"pseudonym\": *, \"domainComponent\": *}"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "jscu: A Universal Cryptographic Library for JavaScript\n--\n\n[![CircleCI](https://circleci.com/gh/junkurihara/jscu.svg?style=svg)](https://circleci.com/gh/junkurihara/jscu)\n[![Coverage Status](https://coveralls.io/repos/github/junkurihara/jscu/badge.svg?branch=develop)](https://coveralls.io/github/junkurihara/jscu?branch=develop)\n[![Maintainability](https://api.codeclimate.com/v1/badges/3e20cff0e8e062363a13/maintainability.svg)](https://codeclimate.com/github/junkurihara/jscu/maintainability)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n> **NOTE**: This repository is a *monorepo* of a universal cryptographic library for JavaScript called `js-crypto-utils` (`jscu`), which is designed so as to work in most modern browsers and Node.js. The detailed explanation would be given in each package repository. The root package is given [here](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-utils) (in `develop` branch).\n\n# Introduction and Overview of this monorepo\nThis project called `jscu` is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nIn particular, this library provides unified APIs of the following cryptographic functions that works in most modern browsers and Node.js.\n\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\n\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. This implies the `jscu` is composed of the several subpackages and can be seen as a cryptographic suite like [`openpgpjs`](https://openpgpjs.org/). The root package, `js-crypto-utils`, of the suite and its subpackages are listed as follows.\n\n- [`crypto-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypt-utils): Root cryptographic package providing unified APIs.\n- [`x509-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils): Subpackage handling X509 certificates.\n- [`key-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils): Subpackage handling various key formats like PEM, DER, and JWK.\n- [`ec`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec): Subpackage providing naive encryption and signing of elliptic curve cryptography.\n- [`rsa`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa): Subpackage providing naive encryption and signing of RSA cryptography. \n- [`aes`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes): Subpackage for AES encryption.\n- [`random`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random): Subpackage for cryptographic random generator.\n- [`hash`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash): Subpackage providing hash functions including SHA-2.\n- [`hkdf`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf): Subpackage providing hash-based key derivation function.\n- [`pbkdf`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf): Subpackage providing password-based key derivation function 1 and 2.\n- [`hmac`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac): Subpackage providing hash-based message authentication code.\n\nThe structure of the package is described in the README.md of the [root package](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypt-utils), and hence we should start from there. But we can use various cryptographic functions not only via the root package, [`js-crypto-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypt-utils), but also by directly importing subpackages of intended functions. We should refer to README.md of each subpackage for its detailed usage.\n\n# For Developers and Contributors\n\nUsing `npm` package is the simplest way to fully leverage `jscu` functions. Considering you fork, develop, and update `jscu` packages themselves, i.e., as developers and contributors, usage of this monorepo and procedures for NPM deployment are summarized as follows.\n\n- This monorepo is managed via [Yarn Workspace](https://yarnpkg.com/en/docs/workspaces) and [Lerna](https://github.com/lerna/lerna). After cloning this Git repo, just do `yarn install` at the root of the cloned folder. Then the setup is all done.\n- Versioning pattern of each package is completely independent, but the version of this Git repository specified in the root `package.json` is tied with the root package, i.e., `packages/js-crypto-utils`. The name of root package is also given in the root `package.json`.\n- Deployment of packages to NPM must be done through CircleCI, and **the deployment operation is only triggered by tags associated with Git repo version**. Any commits to any branch and any tags of individual package version won't kicks the deployment mechanism. The versioning and tagging would be done through the following combination of GitFlow and Lerna procedures.\n  1. First execute `yarn flow:version` and bump a version of each package that has been modified on `develop` branch. Here we note that for each updated package, the updated tag would be committed (not pushed), and hence we should almost finalize the release operation at least for each package. This simultaneously update the repo version specified in the root `package.json` without committing.\n  2. Add final changes for release at the level of GitHub repo. Then, commit changes and then execute `yarn release:start` to start release process on a release branch. Here we note the release version will be the updated Git repo version.\n  3. To finalize the release operation, execute `yarn release:finish` to merge the release branch to `master`, and then merge `master` to `develop`. It will also tag the `master` branch with the updated Git repo version, i.e., the root package (`packages/js-crypto-utils`) version.\n  4. Execute `yarn release:push` and push all branches and the generated tag of Git repo version to GitHub.\n\n# Contributing\n\n`jscu` is free, open source software licensed under MIT License.\n\nYou can open issues for bugs you've found or features you think are missing. You can also submit pull requests to this repository, or submit translations using Weblate.\n\nContributors are more than welcome!\n\n# Documentation\nThe [`jscu` documentation](https://junkurihara.github.io/jscu-webpage/) is a dynamically generated site from this monorepo via [esdoc](https://esdoc.org/). You can submit pull requests to 'docs' of this monorepo for document update.\n",
    "longname": "/home/circleci/repo/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils\n- `aes`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes\n- `random`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random\n- `hash`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypto-utils // yarn\n  ```\n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  $ cd js-crypto-utils/packages/js-crypto-utils\n  & yarn build\n  ```\n\nThen you should import the package as follows.\n\n```shell\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'path/to/js-crypto-utils/dist/index.js'; // for github\n```\n\nThe bundled file is also given as `js-crypto-utils/dist/jscu.bundle.js` for a use case where the module is imported as a `window.jscu` object via `script` tags.\n\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in IE and Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509 (may not work in IE due to RSA)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint (SHA-512/SHA-1 does not work in IE, SHA-1 doesn't in Edge)\n  * WebCrypto API for browsers\n  * MsCrypto for IE\n  * NodeCrypto for Node.js\n\n# License\nLicensed under the MIT license, see `LICENSE` file.",
    "longname": "/home/circleci/repo/docs/js-crypto-utils.md",
    "name": "./docs/js-crypto-utils.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/circleci/repo/docs/js-crypto-utils.md",
    "name": "./docs/js-crypto-utils.md",
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils\n- `aes`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes\n- `random`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random\n- `hash`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypto-utils // yarn\n  ```\n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  $ cd js-crypto-utils/packages/js-crypto-utils\n  & yarn build\n  ```\n\nThen you should import the package as follows.\n\n```shell\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'path/to/js-crypto-utils/dist/index.js'; // for github\n```\n\nThe bundled file is also given as `js-crypto-utils/dist/jscu.bundle.js` for a use case where the module is imported as a `window.jscu` object via `script` tags.\n\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in IE and Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509 (may not work in IE due to RSA)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint (SHA-512/SHA-1 does not work in IE, SHA-1 doesn't in Edge)\n  * WebCrypto API for browsers\n  * MsCrypto for IE\n  * NodeCrypto for Node.js\n\n# License\nLicensed under the MIT license, see `LICENSE` file.",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 279,
    "kind": "testFile",
    "name": "packages/js-crypto-aes/test/cbc.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst aes = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Encryption and Decryption with AES-CBC Test`, () => {\n  const keyLength = [16, 32]; // 24 bytes (192 bits) AES key is not supported in Chrome at this point\n  let msg;\n  let iv;\n  before( async () => {\n    msg = new Uint8Array(1024);\n    iv = new Uint8Array(16);\n    for(let i = 0; i < 1024; i++) msg[i] = 0xFF & i;\n    for(let i = 0; i < 16; i++) iv[i] = 0xFF & i;\n  });\n\n  it('Encrypt and decrypt with AES-CBC succeeds correctly', async function() {\n    this.timeout(5000);\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-CBC', iv});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-CBC', iv});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n\n  it('IV must be 16 bytes for AES-CBC', async () => {\n    let result = true;\n    const key = await random.getRandomBytes(12);\n    const ivz = new Uint8Array(12);\n    await aes.encrypt(msg, key, {name: 'AES-CBC', ivz}).catch( () => {result = false; });\n    expect(result).to.be.false;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/test/cbc.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0.it1",
    "access": null,
    "description": "Encrypt and decrypt with AES-CBC succeeds correctly",
    "lineNumber": 23
  },
  {
    "__docId__": 282,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "packages/js-crypto-aes/test/cbc.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/cbc.spec.js~describe0.it2",
    "access": null,
    "description": "IV must be 16 bytes for AES-CBC",
    "lineNumber": 34
  },
  {
    "__docId__": 283,
    "kind": "testFile",
    "name": "packages/js-crypto-aes/test/gcm.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst aes = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Encryption and Decryption with AES-GCM Test`, () => {\n  const keyLength = [16, 32]; // 24 bytes (192 bits) AES key is not supported in Chrome at this point\n  let msg;\n  let iv;\n  before( async () => {\n    msg = new Uint8Array(1024);\n    iv = new Uint8Array(12);\n    for(let i = 0; i < 1024; i++) msg[i] = 0xFF & i;\n    for(let i = 0; i < 12; i++) iv[i] = 0xFF & i;\n  });\n\n  it('Encrypt and decrypt with AES-GCM succeeds correctly', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv, tagLength: 16});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv, tagLength: 16});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n  it('Encrypt and decrypt with AES-GCM succeeds correctly with AAD', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      const additionalData = await random.getRandomBytes(32);\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv, additionalData, tagLength: 16});\n      const decrypted = await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv, additionalData, tagLength: 16});\n      expect(msg.toString() === decrypted.toString()).to.be.true;\n    }));\n  });\n\n  it('Ciphertext alternation can be detected in AES-GCM', async function () {\n    this.timeout(2000);\n    const key = await random.getRandomBytes(32);\n    const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv});\n    encrypted[0] = 0xFF;\n\n    let result = true;\n    await aes.decrypt(encrypted, key, {name: 'AES-GCM', iv}).catch( () => { result = false; });\n    expect(result).to.be.false;\n  });\n\n  it('IV must be 12 bytes for AES-GCM', async () => {\n    let result = true;\n    const key = await random.getRandomBytes(16);\n    const ivz = new Uint8Array(16);\n    await aes.encrypt(msg, key, {name: 'AES-GCM', ivz}).catch( () => {result = false; });\n    expect(result).to.be.false;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/test/gcm.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 284,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 285,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it4",
    "access": null,
    "description": "Encrypt and decrypt with AES-GCM succeeds correctly",
    "lineNumber": 23
  },
  {
    "__docId__": 286,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it5",
    "access": null,
    "description": "Encrypt and decrypt with AES-GCM succeeds correctly with AAD",
    "lineNumber": 32
  },
  {
    "__docId__": 287,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it6",
    "access": null,
    "description": "Ciphertext alternation can be detected in AES-GCM",
    "lineNumber": 42
  },
  {
    "__docId__": 288,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "packages/js-crypto-aes/test/gcm.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/gcm.spec.js~describe3.it7",
    "access": null,
    "description": "IV must be 12 bytes for AES-GCM",
    "lineNumber": 53
  },
  {
    "__docId__": 289,
    "kind": "testFile",
    "name": "packages/js-crypto-aes/test/misc.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst aes = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Miscellaneous Test`, () => {\n  const keyLength = [16, 32]; // 24 bytes (192 bits) AES key is not supported in Chrome at this point\n  let msg;\n  let iv;\n  before( async () => {\n    msg = new Uint8Array(1024);\n    iv = new Uint8Array(12);\n    for(let i = 0; i < 1024; i++) msg[i] = 0xFF & i;\n    for(let i = 0; i < 12; i++) iv[i] = 0xFF & i;\n  });\n\n  it('Unsupported Cipher in encryption', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      let fail = false;\n      await aes.encrypt(msg, key, {name: 'AES-UNSUPPORT', iv, tagLength: 16})\n        .catch( () => { fail = true; });\n      expect(fail).to.be.true;\n    }));\n  });\n\n  it('Unsupported Cipher in decryption', async () => {\n    await Promise.all( keyLength.map( async (keyLen) => {\n      const key = await random.getRandomBytes(keyLen);\n      let fail = false;\n      const encrypted = await aes.encrypt(msg, key, {name: 'AES-GCM', iv, tagLength: 16});\n      await aes.decrypt(encrypted, key, {name: 'AES-UNSUPPORT', iv, tagLength: 16})\n        .catch( () => { fail = true; });\n      expect(fail).to.be.true;\n    }));\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-aes/test/misc.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 290,
    "kind": "test",
    "name": "describe8",
    "testId": 8,
    "memberof": "packages/js-crypto-aes/test/misc.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-aes/test/misc.spec.js~describe8",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 291,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "packages/js-crypto-aes/test/misc.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/misc.spec.js~describe8.it9",
    "access": null,
    "description": "Unsupported Cipher in encryption",
    "lineNumber": 23
  },
  {
    "__docId__": 292,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "packages/js-crypto-aes/test/misc.spec.js~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-aes/test/misc.spec.js~describe8.it10",
    "access": null,
    "description": "Unsupported Cipher in decryption",
    "lineNumber": 33
  },
  {
    "__docId__": 293,
    "kind": "testFile",
    "name": "packages/js-crypto-ec/test/ec.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst elliptic = env.library;\nconst envName = env.envName;\n\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe(`${envName}: Elliptic curve cryptography test`, () => {\n\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  const keys = [];\n  const msgLen = 128;\n  const msg = new Uint8Array(msgLen);\n  before( async () => {\n    for(let i = 0; i < msgLen; i++) msg[i] = 0xFF & i;\n  });\n\n  it('JWK key pair is correctly generated', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(curves.map( async (crv) => {\n      let result = true;\n      const key = await elliptic.generateKey(crv).catch( (e) => {result = false;});\n      keys.push(key);\n      // console.log(key);\n      return result;\n    }));\n    console.log(results);\n    console.log(keys);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Message is successfully signed and verified with generated JWK pairs', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const sign = await elliptic.sign(msg, kp.privateKey, 'SHA-256').catch( (e) => {result = false;});\n      //console.log(sign);\n      const valid = await elliptic.verify(msg, sign, kp.publicKey, 'SHA-256').catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Shared secret is correctly computed at each side', async function() {\n    this.timeout(10000);\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const newKey = await elliptic.generateKey(kp.privateKey.crv).catch( (e) => {result = false;});\n      const shared1 = await elliptic.deriveSecret(kp.publicKey, newKey.privateKey).catch( (e) => {result = false;});\n      const shared2 = await elliptic.deriveSecret(newKey.publicKey, kp.privateKey).catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return (shared1.toString() === shared2.toString());\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  it('Message is successfully signed and verified with generated JWK pairs with DER signature', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(keys.map( async (kp) => {\n      let result = true;\n      const sign = await elliptic.sign(msg, kp.privateKey, 'SHA-256', 'der').catch( (e) => {result = false;});\n      //console.log(sign);\n      const valid = await elliptic.verify(msg, sign, kp.publicKey, 'SHA-256', 'der').catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-ec/test/ec.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 294,
    "kind": "test",
    "name": "describe11",
    "testId": 11,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe11",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 295,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe11.it12",
    "access": null,
    "description": "JWK key pair is correctly generated",
    "lineNumber": 22
  },
  {
    "__docId__": 296,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe11.it13",
    "access": null,
    "description": "Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 36
  },
  {
    "__docId__": 297,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe11.it14",
    "access": null,
    "description": "Shared secret is correctly computed at each side",
    "lineNumber": 51
  },
  {
    "__docId__": 298,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "packages/js-crypto-ec/test/ec.spec.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-ec/test/ec.spec.js~describe11.it15",
    "access": null,
    "description": "Message is successfully signed and verified with generated JWK pairs with DER signature",
    "lineNumber": 66
  },
  {
    "__docId__": 299,
    "kind": "testFile",
    "name": "packages/js-crypto-env/test/env.spec.js",
    "content": "import env from '../src/index.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\ndescribe('Common env test', () => {\n\n  it('Common env test', () => {\n    console.log(typeof env.getNodeCrypto());\n    console.log(typeof env.getWebCrypto());\n    console.log(typeof env.getMsCrypto());\n    console.log(typeof env.getWebCryptoAll());\n    expect(typeof env.getNodeCrypto() === 'undefined' || typeof env.getNodeCrypto() === 'object').to.be.true;\n    expect(typeof env.getWebCrypto() === 'undefined' || typeof env.getWebCrypto() === 'object').to.be.true;\n    expect(typeof env.getMsCrypto() === 'undefined' || typeof env.getMsCrypto() === 'object').to.be.true;\n    expect(typeof env.getWebCryptoAll() === 'undefined' || typeof env.getWebCryptoAll() === 'object').to.be.true;\n  });\n\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-env/test/env.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "packages/js-crypto-env/test/env.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-env/test/env.spec.js~describe16",
    "access": null,
    "description": "Common env test",
    "lineNumber": 8
  },
  {
    "__docId__": 301,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "packages/js-crypto-env/test/env.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-env/test/env.spec.js~describe16.it17",
    "access": null,
    "description": "Common env test",
    "lineNumber": 10
  },
  {
    "__docId__": 302,
    "kind": "testFile",
    "name": "packages/js-crypto-hash/test/hash.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hash = env.library;\nconst envName = env.envName;\n\n\n\nimport params from '../src/params.js';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: Hash generation test`, () => {\n  let msg;\n  before( async () => {\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('Hash should be generated for each hash algorithms', async () => {\n    await Promise.all(hashes.map( async (alg) => {\n      const d = await hash.compute(msg, alg).catch( (e) => console.error(e));\n      console.log(`${alg}: ${d}`);\n      expect(d, `failed at ${alg}`).to.be.a('Uint8Array');\n      const len = params.hashes[alg].hashSize;\n      expect(d, `failed at ${alg}`).to.be.length(len);\n    }));\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/test/hash.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 303,
    "kind": "test",
    "name": "describe18",
    "testId": 18,
    "memberof": "packages/js-crypto-hash/test/hash.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hash/test/hash.spec.js~describe18",
    "access": null,
    "lineNumber": 15
  },
  {
    "__docId__": 304,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "packages/js-crypto-hash/test/hash.spec.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hash/test/hash.spec.js~describe18.it19",
    "access": null,
    "description": "Hash should be generated for each hash algorithms",
    "lineNumber": 22
  },
  {
    "__docId__": 305,
    "kind": "testFile",
    "name": "packages/js-crypto-hash/test/purejs.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hash = env.library;\nconst envName = env.envName;\n\n\n\nimport params from '../src/params.js';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: Hash generation test in PureJS for webcrypto`, () => {\n  let msg;\n  before( async () => {\n    if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined') window.crypto.subtle.digest = undefined;\n    if (typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') window.msCrypto.subtle.digest = undefined;\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('Hash should be generated for each hash algorithms in Pure JS for webcrypto', async () => {\n    await Promise.all(hashes.map( async (alg) => {\n      const d = await hash.compute(msg, alg).catch( (e) => console.error(e));\n      console.log(`${alg}: ${d}`);\n      expect(d, `failed at ${alg}`).to.be.a('Uint8Array');\n      const len = params.hashes[alg].hashSize;\n      expect(d, `failed at ${alg}`).to.be.length(len);\n    }));\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hash/test/purejs.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 306,
    "kind": "test",
    "name": "describe20",
    "testId": 20,
    "memberof": "packages/js-crypto-hash/test/purejs.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hash/test/purejs.spec.js~describe20",
    "access": null,
    "lineNumber": 15
  },
  {
    "__docId__": 307,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "packages/js-crypto-hash/test/purejs.spec.js~describe20",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hash/test/purejs.spec.js~describe20.it21",
    "access": null,
    "description": "Hash should be generated for each hash algorithms in Pure JS for webcrypto",
    "lineNumber": 24
  },
  {
    "__docId__": 308,
    "kind": "testFile",
    "name": "packages/js-crypto-hkdf/test/hkdf.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hkdf = env.library;\nconst envName = env.envName;\n\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nlet hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: HKDF test`, () => {\n  let masterSecret;\n  const length = 144;\n  before( async () => {\n    masterSecret = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) masterSecret[i] = 0xFF & i;\n  });\n\n  it('HKDF is done with automatic salt generation', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', null);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.byteLength, `failed at ${hash}`).to.be.equal(length);\n    }));\n\n  });\n\n  it('When the same salt is given, the same hash is obtained with HKDF', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', null);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.byteLength, `failed at ${hash}`).to.be.equal(length);\n\n      const dash = await hkdf.compute(masterSecret, hash, length, '', d.salt);\n      expect(dash.key).to.be.a('Uint8Array');\n      expect(dash.salt).to.be.a('Uint8Array');\n      expect(dash.key.toString() === d.key.toString(), `failed at ${hash}`).to.be.true;\n    }));\n  });\n\n  const fixedMACs = {\n    'SHA-256': '124,145,193,234,149,107,107,61,61,58,9,228,216,212,69,71,240,202,118,194,180,114,113,80,57,24,232,113,213,155,191,166,26,1,94,230,244,185,171,102,20,246,59,203,245,200,17,25,92,22,196,106,168,145,125,94,125,84,101,149,119,146,250,243,152,225,232,129,232,101,106,19,55,157,34,240,146,204,162,5,235,156,31,230,188,36,176,44,67,35,99,135,83,197,177,236,167,63,60,93,47,189,225,162,175,151,241,234,151,223,136,25,249,206,88,208,28,111,166,235,128,33,40,15,90,219,238,153,152,79,97,115,33,89,55,168,181,141,76,237,144,181,57,117',\n    'SHA-384': '226,40,99,209,178,247,5,3,166,90,9,57,196,54,29,65,191,119,205,64,47,173,233,116,113,173,210,1,8,30,44,233,142,251,189,192,98,33,183,94,253,87,14,102,50,209,55,67,226,34,229,19,69,88,120,205,147,250,207,6,190,188,129,162,142,51,6,94,198,13,52,245,178,65,101,49,1,35,97,111,92,164,181,162,227,6,13,233,115,237,140,241,0,94,195,189,92,45,79,229,249,176,59,226,25,219,176,12,37,70,220,234,182,3,199,37,63,197,185,145,65,12,133,26,152,177,154,89,5,110,49,205,30,57,50,9,111,119,211,27,189,48,162,248',\n    'SHA-512': '77,119,111,188,124,95,226,127,20,170,196,226,159,131,36,202,21,73,204,211,247,102,23,159,105,161,241,64,50,116,222,170,254,66,55,162,60,1,101,29,45,47,15,139,247,111,136,142,99,191,28,155,218,49,174,135,126,218,59,64,167,134,208,165,16,247,6,10,59,62,132,83,23,168,218,212,7,22,213,52,101,9,30,1,228,227,88,185,196,5,50,49,100,24,84,15,58,45,93,90,119,135,41,224,224,53,39,176,107,150,138,99,113,161,111,145,83,241,68,46,151,134,169,76,254,20,58,160,91,177,62,71,12,106,54,35,116,101,34,115,23,103,199,33',\n    'SHA-1': '231,154,101,85,67,166,227,46,107,169,115,168,122,162,93,194,10,128,27,249,153,198,172,180,27,209,12,238,163,12,98,163,236,102,63,223,161,210,134,122,189,22,131,17,171,185,178,228,115,0,218,206,137,173,245,206,223,69,72,248,241,58,225,7,23,151,118,82,196,123,65,14,205,160,64,3,225,9,124,178,27,174,18,48,251,3,59,132,162,81,151,191,178,11,202,26,233,214,5,254,87,32,229,112,122,149,27,28,87,252,204,243,161,2,123,48,131,94,121,188,147,143,232,247,105,96,151,230,76,180,214,185,71,188,78,23,251,225,102,131,107,231,158,87',\n    'MD5': '34,114,11,173,87,235,112,155,161,97,171,57,143,74,153,140,175,88,254,87,93,61,179,88,60,142,74,41,117,97,62,89,80,168,115,6,130,109,48,166,162,35,217,104,241,208,238,57,121,26,33,71,247,81,97,99,62,96,225,167,118,46,176,104,212,119,127,248,29,0,165,36,183,238,250,171,155,179,152,55,236,224,58,4,1,22,144,146,92,123,240,96,1,46,82,221,253,32,216,171,51,137,130,88,53,209,151,50,204,151,231,90,56,171,97,250,101,225,150,198,242,161,216,91,196,89,103,163,106,120,61,59,26,150,23,226,244,149,161,40,106,90,106,32'\n  };\n\n  it('When the fixed salt is given, the mac is always fixed', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', masterSecret);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.toString() === fixedMACs[hash]).to.be.true;\n    }));\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/test/hkdf.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 309,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22",
    "access": null,
    "lineNumber": 13
  },
  {
    "__docId__": 310,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22.it23",
    "access": null,
    "description": "HKDF is done with automatic salt generation",
    "lineNumber": 21
  },
  {
    "__docId__": 311,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22.it24",
    "access": null,
    "description": "When the same salt is given, the same hash is obtained with HKDF",
    "lineNumber": 33
  },
  {
    "__docId__": 312,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/hkdf.spec.js~describe22.it25",
    "access": null,
    "description": "When the fixed salt is given, the mac is always fixed",
    "lineNumber": 57
  },
  {
    "__docId__": 313,
    "kind": "testFile",
    "name": "packages/js-crypto-hkdf/test/purejs.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hkdf = env.library;\nconst envName = env.envName;\n\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\n\nlet hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\ndescribe(`${envName}: HKDF test in PureJS environment`, () => {\n  let masterSecret;\n  const length = 144;\n  before( async () => {\n    if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined') window.crypto.subtle.deriveBits = undefined;\n    masterSecret = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) masterSecret[i] = 0xFF & i;\n  });\n\n  it('HKDF is done with automatic salt generation in PureJS Environment', async function () {\n    this.timeout(20000);\n    if(typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') hashes = ['SHA-256', 'SHA-384']; // SHA-512 doesn't work in IE\n    await Promise.all(hashes.map( async (hash) => {\n      const d = await hkdf.compute(masterSecret, hash, length, '', null);\n      expect(d.key).to.be.a('Uint8Array');\n      expect(d.salt).to.be.a('Uint8Array');\n      expect(d.key.byteLength, `failed at ${hash}`).to.be.equal(length);\n    }));\n\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hkdf/test/purejs.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 314,
    "kind": "test",
    "name": "describe26",
    "testId": 26,
    "memberof": "packages/js-crypto-hkdf/test/purejs.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/purejs.spec.js~describe26",
    "access": null,
    "lineNumber": 13
  },
  {
    "__docId__": 315,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "packages/js-crypto-hkdf/test/purejs.spec.js~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hkdf/test/purejs.spec.js~describe26.it27",
    "access": null,
    "description": "HKDF is done with automatic salt generation in PureJS Environment",
    "lineNumber": 22
  },
  {
    "__docId__": 316,
    "kind": "testFile",
    "name": "packages/js-crypto-hmac/test/hmac.spec.js",
    "content": "import random from 'js-crypto-random';\nimport jseu from 'js-encoding-utils';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hmac = env.library;\nconst envName = env.envName;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'MD5', 'SHA-1'];\ndescribe(`${envName}: HMAC test`, () => {\n  let msg;\n  before( async () => {\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('HMAC successfully generates and verify a MAC', async function () {\n    this.timeout(20000);\n    const array = await Promise.all(hashes.map( async (hash) => {\n      const key = await random.getRandomBytes(32);\n      const d = await hmac.compute(key, msg, hash);\n      expect(d).to.be.a('Uint8Array');\n      return hmac.verify(key, msg, d, hash);\n    }));\n    console.log(array);\n    expect(array.every((a) => (a === true))).to.be.true;\n  });\n\n  it('HMAC successfully generates unique MAC for unique key', async function () {\n    this.timeout(20000);\n    const array = await Promise.all(hashes.map( async (hash) => {\n      const keya = await random.getRandomBytes(32);\n      const keyb = await random.getRandomBytes(32);\n      const da = await hmac.compute(keya, msg, hash);\n      const db = await hmac.compute(keyb, msg, hash);\n      expect(da).to.be.a('Uint8Array');\n      expect(db).to.be.a('Uint8Array');\n      return da.toString() !== db.toString();\n    }));\n    console.log(array);\n    expect(array.every((a) => (a === true))).to.be.true;\n  });\n\n  it('If msg is overwritten, it can be detected via MAC', async function () {\n    this.timeout(20000);\n    const key = await random.getRandomBytes(32);\n    const newMsg = new Uint8Array(msg);\n    newMsg[1] = 0xFF&0x33;\n\n    const origArray = await Promise.all(hashes.map( async (hash) => jseu.encoder.encodeBase64(await hmac.compute(key, msg, hash))));\n    const altArray = await Promise.all(hashes.map( async (hash) => jseu.encoder.encodeBase64(await hmac.compute(key, newMsg, hash))));\n\n    const array = origArray.map( (orig, idx) => orig !== altArray[idx]);\n    console.log(array);\n    console.log(origArray);\n    console.log(altArray);\n\n    expect(array.every( (x) => x)).to.be.true;\n\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/test/hmac.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 317,
    "kind": "test",
    "name": "describe28",
    "testId": 28,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe28",
    "access": null,
    "lineNumber": 14
  },
  {
    "__docId__": 318,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe28.it29",
    "access": null,
    "description": "HMAC successfully generates and verify a MAC",
    "lineNumber": 21
  },
  {
    "__docId__": 319,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe28.it30",
    "access": null,
    "description": "HMAC successfully generates unique MAC for unique key",
    "lineNumber": 33
  },
  {
    "__docId__": 320,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "packages/js-crypto-hmac/test/hmac.spec.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/hmac.spec.js~describe28.it31",
    "access": null,
    "description": "If msg is overwritten, it can be detected via MAC",
    "lineNumber": 48
  },
  {
    "__docId__": 321,
    "kind": "testFile",
    "name": "packages/js-crypto-hmac/test/purejs.spec.js",
    "content": "import random from 'js-crypto-random';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst hmac = env.library;\nconst envName = env.envName;\n\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'MD5', 'SHA-1'];\ndescribe(`${envName}: HMAC test in PureJS environment`, () => {\n  let msg;\n  before( async () => {\n    if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined') window.crypto.subtle.sign = undefined;\n    if (typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') window.msCrypto.subtle.sign = undefined;\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('HMAC successfully generates and verify a MAC in PureJS environment', async function () {\n    this.timeout(20000);\n    const array = await Promise.all(hashes.map( async (hash) => {\n      const key = await random.getRandomBytes(32);\n      const d = await hmac.compute(key, msg, hash);\n      expect(d).to.be.a('Uint8Array');\n      return hmac.verify(key, msg, d, hash);\n    }));\n    console.log(array);\n    expect(array.every((a) => (a === true))).to.be.true;\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-hmac/test/purejs.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 322,
    "kind": "test",
    "name": "describe32",
    "testId": 32,
    "memberof": "packages/js-crypto-hmac/test/purejs.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/purejs.spec.js~describe32",
    "access": null,
    "lineNumber": 13
  },
  {
    "__docId__": 323,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "packages/js-crypto-hmac/test/purejs.spec.js~describe32",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-hmac/test/purejs.spec.js~describe32.it33",
    "access": null,
    "description": "HMAC successfully generates and verify a MAC in PureJS environment",
    "lineNumber": 22
  },
  {
    "__docId__": 324,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/convertEC.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport ecKey from './ec_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nfunction prune(jwk){\n  delete jwk.ext;\n  delete jwk.alg;\n  delete jwk.key_ops;\n  return jwk;\n}\n\n\nconst curves = ['P-256', 'P-384', 'P-521'];\ndescribe(`${envName}: EC Key conversion from/to JWK test.`, () => {\n  \n  let ECKeySet = [];\n  before(async function (){\n    this.timeout(20000);\n    ECKeySet = ecKey.ecKey;//await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('JWK EC should be successfully converted to PEM and re-converted to JWK correctly', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const pempub = await publicKey.export('pem', {compact: false});\n      const pempri = await privateKey.export('pem', {compact: false});\n\n      const publicKey2 = new keyutils.Key('pem', pempub);\n      const privateKey2 = new keyutils.Key('pem', pempri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      const res =  (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n      if (!res) {\n        console.log(objectSort(jwkpub));\n        console.log(objectSort(key.publicKey));\n        console.log(objectSort(jwkpri));\n        console.log(objectSort(key.privateKey));\n        // console.log(pempub);\n        // console.log(pempri);\n      }\n      return res;\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to PEM and re-converted to JWK correctly with public key compact form', async () => {\n\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const pempub = await publicKey.export('pem', {compact: true});\n      const pempri = await privateKey.export('pem', {compact: true});\n\n      const publicKey2 = new keyutils.Key('pem', pempub);\n      const privateKey2 = new keyutils.Key('pem', pempri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n\n  it('JWK EC should be successfully converted to DER and re-converted to JWK correctly', async () => {\n\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const derpub = await publicKey.export('der', {compact: false});\n      const derpri = await privateKey.export('der', {compact: false});\n\n      const publicKey2 = new keyutils.Key('der', derpub);\n      const privateKey2 = new keyutils.Key('der', derpri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to DER and re-converted to JWK correctly with public key compact form', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const derpub = await publicKey.export('der', {compact: true});\n      const derpri = await privateKey.export('der', {compact: true});\n\n      const publicKey2 = new keyutils.Key('der', derpub);\n      const privateKey2 = new keyutils.Key('der', derpri);\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to uncompressed-octet formed key and vice varsa', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const octpub = await publicKey.export('oct', {compact: false});\n      const octpri = await privateKey.export('oct', {compact: false});\n\n      const publicKey2 = new keyutils.Key('oct', octpub, {namedCurve: key.publicKey.crv});\n      const privateKey2 = new keyutils.Key('oct', octpri, {namedCurve: key.privateKey.crv});\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n          && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('JWK EC should be successfully converted to compact-octet formed key and vice varsa', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const publicKey = new keyutils.Key('jwk', key.publicKey);\n      const privateKey = new keyutils.Key('jwk', key.privateKey);\n\n      const octpub = await publicKey.export('oct', {compact: true});\n      const octpri = await privateKey.export('oct', {compact: true});\n      // console.log(octpub);\n\n      const publicKey2 = new keyutils.Key('oct', octpub, {namedCurve: key.publicKey.crv});\n      const privateKey2 = new keyutils.Key('oct', octpri, {namedCurve: key.privateKey.crv});\n\n      const jwkpub = await publicKey2.export('jwk');\n      const jwkpri = await privateKey2.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(key.publicKey))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(key.privateKey))));\n    }));\n    console.log(array);\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/convertEC.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 325,
    "kind": "test",
    "name": "describe34",
    "testId": 34,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "access": null,
    "lineNumber": 28
  },
  {
    "__docId__": 326,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it35",
    "access": null,
    "description": "JWK EC should be successfully converted to PEM and re-converted to JWK correctly",
    "lineNumber": 36
  },
  {
    "__docId__": 327,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it36",
    "access": null,
    "description": "JWK EC should be successfully converted to PEM and re-converted to JWK correctly with public key compact form",
    "lineNumber": 66
  },
  {
    "__docId__": 328,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it37",
    "access": null,
    "description": "JWK EC should be successfully converted to DER and re-converted to JWK correctly",
    "lineNumber": 89
  },
  {
    "__docId__": 329,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it38",
    "access": null,
    "description": "JWK EC should be successfully converted to DER and re-converted to JWK correctly with public key compact form",
    "lineNumber": 112
  },
  {
    "__docId__": 330,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it39",
    "access": null,
    "description": "JWK EC should be successfully converted to uncompressed-octet formed key and vice varsa",
    "lineNumber": 133
  },
  {
    "__docId__": 331,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertEC.spec.js~describe34.it40",
    "access": null,
    "description": "JWK EC should be successfully converted to compact-octet formed key and vice varsa",
    "lineNumber": 154
  },
  {
    "__docId__": 332,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sampleRSA from './rsa_sample.js';\n\nimport jseu from 'js-encoding-utils';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nfunction prune(jwk){\n  delete jwk.ext;\n  delete jwk.alg;\n  delete jwk.key_ops;\n  return jwk;\n}\n\n\n\nconst bits = ['2048', '4096'];\ndescribe(`${envName}: RSA Key conversion from/to JWK test.`, () => {\n  before(async () => {\n  });\n\n  it('JWK RSA should be successfully converted from PEM', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('pem', sampleRSA[bitLen].publicKey.pem);\n      const jwkpub = await publicKey.export('jwk');\n      // private key\n      const privateKey = new keyutils.Key('pem', sampleRSA[bitLen].privateKey.pem);\n      const jwkpri = await privateKey.export('jwk');\n\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].publicKey.jwk))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].privateKey.jwk))));\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('PEM RSA should be successfully converted from JWK', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n      const pempub = await publicKey.export('pem');\n      // private key\n      const privateKey = new keyutils.Key('jwk', sampleRSA[bitLen].privateKey.jwk);\n      const pempri = await privateKey.export('pem');\n\n      return (pempub === sampleRSA[bitLen].publicKey.pem) && (pempri === sampleRSA[bitLen].privateKey.pem);\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('JWK RSA should be successfully converted from DER', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      const derpub = jseu.formatter.pemToBin(sampleRSA[bitLen].publicKey.pem);\n      const derpri = jseu.formatter.pemToBin(sampleRSA[bitLen].privateKey.pem);\n\n      // public key\n      const publicKey = new keyutils.Key('der', derpub);\n      const jwkpub = await publicKey.export('jwk');\n      // private key\n      const privateKey = new keyutils.Key('der', derpri);\n      const jwkpri = await privateKey.export('jwk');\n\n      return (JSON.stringify(objectSort(jwkpub)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].publicKey.jwk))))\n        && (JSON.stringify(objectSort(jwkpri)) === JSON.stringify(objectSort(prune(sampleRSA[bitLen].privateKey.jwk))));\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('DER RSA should be successfully converted from JWK', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      // public key\n      const publicKey = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n      const derpub = await publicKey.export('der');\n      // private key\n      const privateKey = new keyutils.Key('jwk', sampleRSA[bitLen].privateKey.jwk);\n      const derpri = await privateKey.export('der');\n\n      return (derpub.toString() === jseu.formatter.pemToBin(sampleRSA[bitLen].publicKey.pem).toString())\n        && (derpri.toString() === jseu.formatter.pemToBin(sampleRSA[bitLen].privateKey.pem).toString());\n    }));\n    console.log(array);\n    expect( array.every( (a) => a)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 333,
    "kind": "test",
    "name": "describe41",
    "testId": 41,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41",
    "access": null,
    "lineNumber": 31
  },
  {
    "__docId__": 334,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41.it42",
    "access": null,
    "description": "JWK RSA should be successfully converted from PEM",
    "lineNumber": 35
  },
  {
    "__docId__": 335,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41.it43",
    "access": null,
    "description": "PEM RSA should be successfully converted from JWK",
    "lineNumber": 52
  },
  {
    "__docId__": 336,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41.it44",
    "access": null,
    "description": "JWK RSA should be successfully converted from DER",
    "lineNumber": 67
  },
  {
    "__docId__": 337,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/convertRSA.spec.js~describe41.it45",
    "access": null,
    "description": "DER RSA should be successfully converted from JWK",
    "lineNumber": 86
  },
  {
    "__docId__": 338,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sample from './encrypted_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\ndescribe(`${envName}: RSA/EC Key conversion from/to JWK test.`, () => {\n  const encOptionArray = [\n    {algorithm: 'pbes2'}, // = AES256 with hmachWithSHA256\n    {algorithm: 'pbes2', cipher: 'aes128-cbc', prf: 'hmacWithSHA256'},\n    // {algorithm: 'pbes2', cipher: 'aes192-cbc', prf: 'hmacWithSHA256'}, // not supported in Chrome\n    {algorithm: 'pbes2', cipher: 'aes256-cbc', prf: 'hmacWithSHA256'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA256'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA384'},\n    {algorithm: 'pbes2', cipher: 'des-ede3-cbc', prf: 'hmacWithSHA512'},\n    {algorithm: 'pbeWithMD5AndDES-CBC'},\n    {algorithm: 'pbeWithSHA1AndDES-CBC'}\n  ];\n  const rsaSample = sample.RSA;\n  const ecSample = sample.EC;\n\n  before(async () => {\n  });\n\n  it('RSA PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK', async function (){\n    this.timeout(10000);\n    const array = await Promise.all(Object.keys(rsaSample).map( async (key) => {\n      const elem = await Promise.all(encOptionArray.map( async (encOptions) => {\n        let result = true;\n        const privateKey = new keyutils.Key('pem', rsaSample[key]);\n        result = result && privateKey.isEncrypted;\n\n        await privateKey.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey.isEncrypted;\n\n        const jwkpri = await privateKey.export('pem').catch( () => {result = false; });\n        const pempri = await privateKey.export(\n          'pem', {\n            encryptParams: Object.assign({ passphrase: 'kddilabs' }, encOptions)\n          }\n        ).catch( () => {result = false; });\n\n        const privateKey2 = new keyutils.Key('pem', pempri);\n        result = result && privateKey2.isEncrypted;\n        await privateKey2.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey2.isEncrypted;\n\n        const jwkpri2 = await privateKey2.export('pem').catch( () => {result = false;});\n\n\n        return result && (objectSort(jwkpri).toString() === objectSort(jwkpri2).toString());\n      }));\n      console.log(elem);\n      return elem.every( (x) => x);\n    }));\n    expect(array.every( (x) => x)).to.be.true;\n\n    // AES256 encrypted key sample\n    // const test = '-----BEGIN ENCRYPTED PRIVATE KEY-----\\n' +\n    //   'MIIFLTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQI24WwHkKy4+0CAggA\\n' +\n    //   'MAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBDHasukS1RwbDihH6StdYmnBIIE\\n' +\n    //   '0A9gsWExWzLVV74rnE3PIKJuiophU6SxTpf5zNPaThM2vU7BqwIqNtGIpSMVEQbP\\n' +\n    //   'UsbKt5OOgm4cWgLQ4mp6ZVj84kym2IOv+OYKKw5qKsDG2egcYCXG0RtSoRaBM8Us\\n' +\n    //   'ju3j7lL0A4dEuiUqeun9m742HuQ+8VDZU4+4eO5V5AcaVvwex+tROqyhTsdDO8BB\\n' +\n    //   'LPuCC05dt4pn7bn3pgBm0ZVUAF1FJLs/rncPhJnJDflpbDApsFaRWNpD3878F9L8\\n' +\n    //   'BLKHZr/srJu1ajcM6E5avyzTvnpeRYqLMqanXqGy957yOg23NANcny20NHktkZJz\\n' +\n    //   '/oqdWrjiXT4gPHAskx2KYPaVySOVa55tBGoqVovzCHFNuIjwamucg5ZWZY8C6sJC\\n' +\n    //   '0ZaFAW9TV3Rs2GqxcL3LFx9zEgDWT+VJxQaNFXoXLz8ROYKh6QKAV7jgV4JOUYc6\\n' +\n    //   'ow3gGUqkhEyIYDuKzZOWeZ1IMHltMUaRz7S+ygPxBvgnjthA1XU9JRv3QSNleLGz\\n' +\n    //   'WcZBWDhNXLIKepefrBgvrYim3qdfK5H72FjYOx3Ir8K52dPB4BMqqz8JJjSRMfYM\\n' +\n    //   'ak5abTy6znSnHHHYOrYQE47E9RTYqu2rMp3B75Xru2KUxoVFV49xXXEYNzCNwFg+\\n' +\n    //   'PwE8gF04mEoqBiwFn40woVQUN8WpWFl3pzKai9HvIPYUOSpZrmPzE8Mu/SVpV//G\\n' +\n    //   '3fkVwmOyCOs3Tg/tA5aKKjMbSXMJULhCbtxUwx2Kxn8K0PfrRk7+MmLOQlp9JDvN\\n' +\n    //   'esrONUx/7R0SyuGkEYCQyEHzlURNrWG0ZQDlBOMIuItj2ikoNYvoNTctPsYIQdkr\\n' +\n    //   'ZwHSJR0DvxCA4/Vso72tnTNrZS2CoNJfJVfE8VwtA0QX9jgkS1b8nkPk1tcrvYsw\\n' +\n    //   '9uPYXDvmucQyKIKWomA9s27vDw0QqIwgMJ6vIWnaRDDXuIF4CpAOrwaW78ZHee1M\\n' +\n    //   'fvBq571/NMJFemqh8KMLZfBzkj/JoUfxRbZmBfKs/JdRZ/W6OOO5NZLcGprslpJd\\n' +\n    //   'u29LBMIx+cmgUZCjDtbKHDMeeG6ptSl4omLrcTE7+ZowOSUaTVxlRqweMqKNJmuc\\n' +\n    //   'esfWhGEbppk+oPyXDzQ9ENIUcrKin5RJ8QKcxvpiWHxAqwzfXB9eqzUkAuDmQOel\\n' +\n    //   'jbnigof4XL+KKnANoHHOgs47kKNJm2PzHOvxsKKiI4LIC2AMp2nGrpiMtyP/7uie\\n' +\n    //   'tZ6Po5HffFSTjlYEE9jEfQ/tipIqyxvEEK+aPYdZ5P3vW2OI0CTcrXJxLlBVPaxB\\n' +\n    //   'JVD4oMxKdIEIpmV0qnBtaD7aEF2lSIk0gYNnz+DKbXi12zmHNuJ77u6lbXN6lhlr\\n' +\n    //   'lcPWHQq4btWKDPR79+0lyQiY0UmdwQOUaihvdU6mY07PmslnUbtj5XVDDNP22Qdz\\n' +\n    //   '3jk9pGVlTcgPQqmcDVdMbHtT8khpIimriI186BvcbPOWI5H4UThyXTSisDPzEGQR\\n' +\n    //   'F9Z9mNb6p71nqARRNcNIMlA7JJombnR4Ws1NDv5y9szp6WH/lkTDyWw3k9sjrx8a\\n' +\n    //   'is2Ke0G4AAq0uP+ev5TMtnFZrLnGvt4KkWpJgibiIje+e3rya9jk+GH8qf2nldlj\\n' +\n    //   'ywUZpixaRCAyxa2Bbjcm/lKsUfdMq8cgzRW51wTpFlMs\\n' +\n    //   '-----END ENCRYPTED PRIVATE KEY-----';\n    // console.log(await keyutils.toJwkFrom('pem', test, {passphrase: 'kddilabs'}).catch( () => {result = false;}));\n  });\n\n\n  it('EC PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK', async function() {\n    this.timeout(10000);\n    const array = await Promise.all(Object.keys(ecSample).map( async (key) => {\n      const elem = await Promise.all(encOptionArray.map( async (encOptions) => {\n        let result = true;\n        const privateKey = new keyutils.Key('pem', ecSample[key]);\n        result = result && privateKey.isEncrypted;\n\n        await privateKey.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey.isEncrypted;\n\n        const jwkpri = await privateKey.export('pem').catch( () => {result = false; });\n        const pempri = await privateKey.export(\n          'pem', {\n            encryptParams: Object.assign({ passphrase: 'kddilabs' }, encOptions)\n          }\n        ).catch( () => {result = false; });\n\n        const privateKey2 = new keyutils.Key('pem', pempri);\n        result = result && privateKey2.isEncrypted;\n        await privateKey2.decrypt('kddilabs').catch( () => {result = false;});\n        result = result && !privateKey2.isEncrypted;\n\n        const jwkpri2 = await privateKey2.export('pem').catch( () => {result = false;});\n\n\n        return result && (objectSort(jwkpri).toString() === objectSort(jwkpri2).toString());\n      }));\n      console.log(elem);\n      return elem.every( (x) => x);\n    }));\n    expect(array.every( (x) => x)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 339,
    "kind": "test",
    "name": "describe46",
    "testId": 46,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe46",
    "access": null,
    "lineNumber": 19
  },
  {
    "__docId__": 340,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe46.it47",
    "access": null,
    "description": "RSA PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK",
    "lineNumber": 37
  },
  {
    "__docId__": 341,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/encryptedPrivateKey.spec.js~describe46.it48",
    "access": null,
    "description": "EC PBES1 and PBES2 PEM keys can be successfully converted and reconverted to/from JWK",
    "lineNumber": 105
  },
  {
    "__docId__": 342,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst keyutils = env.library;\nconst envName = env.envName;\n\nimport sampleEC from './ec_sample.js';\nimport sampleRSA from './rsa_sample.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\nconst bits = ['2048', '4096'];\nconst hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\ndescribe(`${envName}: JWK thumbprint generation test.`, () => {\n\n  let keySet = [];\n  before(async () => {\n    keySet = sampleEC.ecKey; //await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('EC: JWK thumbprint in array buffer is generated successfully for each curve and hashes', async () => {\n    const tps = await Promise.all( keySet.map(\n      async (jwkey) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', jwkey.publicKey);\n          const tp = await key.getJwkThumbprint(h);\n          expect(tp instanceof Uint8Array).to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('EC: JWK thumbprint in hex string is generated successfully for each curve and hashes', async () => {\n    const tps = await Promise.all( keySet.map(\n      async (jwkey) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', jwkey.publicKey);\n          const tp = await key.getJwkThumbprint(h, 'hex');\n          expect(typeof(tp)==='string').to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('RSA: JWK thumbprint in array buffer is generated successfully for each bits and hashes', async () => {\n    const tps = await Promise.all( bits.map(\n      async (bitLen) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n          const tp = await key.getJwkThumbprint(h);\n          expect(tp instanceof Uint8Array).to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n  it('RSA: JWK thumbprint in hex string is generated successfully for each bits and hashes', async () => {\n    const tps = await Promise.all( bits.map(\n      async (bitLen) => await Promise.all( hashes.map(\n        async (h) => {\n          const key = new keyutils.Key('jwk', sampleRSA[bitLen].publicKey.jwk);\n          const tp = await key.getJwkThumbprint(h, 'hex');\n          expect(typeof(tp)==='string').to.be.true;\n          return tp;\n        }\n      ))\n    ));\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 343,
    "kind": "test",
    "name": "describe49",
    "testId": 49,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49",
    "access": null,
    "lineNumber": 16
  },
  {
    "__docId__": 344,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49.it50",
    "access": null,
    "description": "EC: JWK thumbprint in array buffer is generated successfully for each curve and hashes",
    "lineNumber": 23
  },
  {
    "__docId__": 345,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49.it51",
    "access": null,
    "description": "EC: JWK thumbprint in hex string is generated successfully for each curve and hashes",
    "lineNumber": 36
  },
  {
    "__docId__": 346,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49.it52",
    "access": null,
    "description": "RSA: JWK thumbprint in array buffer is generated successfully for each bits and hashes",
    "lineNumber": 49
  },
  {
    "__docId__": 347,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/jwkthumbprint.spec.js~describe49.it53",
    "access": null,
    "description": "RSA: JWK thumbprint in hex string is generated successfully for each bits and hashes",
    "lineNumber": 62
  },
  {
    "__docId__": 348,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/misc.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst Key = env.library.Key;\nconst envName = env.envName;\n\n\nimport sampleRSA from './rsa_sample.js';\nimport sampleEC from './ec_sample.js';\nimport jseu from 'js-encoding-utils';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\nconst bits = ['2048', '4096'];\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\ndescribe(`${envName}: RSA/EC Key conversion from/to JWK test.`, () => {\n\n  let ECKeySet = [];\n  before(async function (){\n    this.timeout(20000);\n    ECKeySet = sampleEC.ecKey;//await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n  });\n\n  it('EC: Derive public key to private key', async function () {\n    this.timeout(4000);\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const keyObj = new Key('jwk', key.privateKey);\n      expect(keyObj.isPrivate).to.be.true;\n\n      const pubpemCompact = await keyObj.export('pem', {compact: true, outputPublic: true});  // export public from private\n      const koc = new Key('pem', pubpemCompact);\n      expect(koc.isPrivate).to.be.false;\n      const kocjwk = await koc.export('jwk');\n\n      const pubpem = await keyObj.export('pem', {compact: false, outputPublic: true});  // export public from private\n      const ko = new Key('pem', pubpem);\n      expect(ko.isPrivate).to.be.false;\n      const kojwk = await ko.export('jwk');\n\n      expect(\n        JSON.stringify(objectSort(kocjwk)) === JSON.stringify(objectSort(key.publicKey))\n        && JSON.stringify(objectSort(kojwk)) === JSON.stringify(objectSort(key.publicKey))\n      ).to.be.true;\n\n      const octpemCompact = await keyObj.export('oct', {compact: true, output:'string', outputPublic: true});\n      const ooc = new Key('oct', jseu.encoder.hexStringToArrayBuffer(octpemCompact), {namedCurve: key.publicKey.crv});\n      // console.log(getKeyStatus(ooc));\n      expect(ooc.isPrivate).to.be.false;\n      const oocjwk = await ooc.export('jwk');\n\n\n      const octpem = await keyObj.export('oct', {compact: false, output:'string', outputPublic: true}); // export public from private\n      const oo = new Key('oct', jseu.encoder.hexStringToArrayBuffer(octpem), {namedCurve: key.publicKey.crv});\n      expect(oo.isPrivate).to.be.false;\n      const oojwk = await oo.export('jwk');\n\n      expect(\n        JSON.stringify(objectSort(oocjwk)) === JSON.stringify(objectSort(key.publicKey))\n        && JSON.stringify(objectSort(oojwk)) === JSON.stringify(objectSort(key.publicKey))\n      ).to.be.true;\n\n\n    }));\n    // console.log(array);\n    // expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n\n  it('Status Change Test', async () => {\n    const array = await Promise.all(bits.map( async (bitLen) => {\n      const key = new Key('pem', sampleRSA[bitLen].privateKey.pem);\n      let status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 0 && !status.status.jwk\n      ).to.be.true;\n\n      const jwk = await key.export('jwk');\n      status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 9 && status.status.jwk\n      ).to.be.true;\n\n      await key.encrypt('password');\n      status = getKeyStatus(key);\n      expect(\n        status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength > 0 && status.status.der\n        && status.jwkKeyLength === 0 && !status.status.jwk\n      ).to.be.true;\n      // console.log(status);\n\n      const asis = await key.export('pem');\n      // console.log(asis);\n\n      await key.decrypt('password');\n      status = getKeyStatus(key);\n      expect(\n        !status.isEncrypted\n        && status.octLength === 0 && !status.status.oct\n        && status.derLength === 0 && !status.status.der\n        && status.jwkKeyLength === 9 && status.status.jwk\n      ).to.be.true;\n      // console.log(status);\n\n      // console.log(await key.getJwkThumbprint('SHA-256', 'hex'));\n\n\n    }));\n    // console.log(array);\n    // expect( array.every( (a) => a)).to.be.true;\n  });\n\n  it('Misc', async () => {\n    const array = await Promise.all(ECKeySet.map( async (key) => {\n      const keyObj = new Key('jwk', key.privateKey);\n      const kty = await keyObj.keyType;\n      expect(kty === 'EC').to.be.true;\n\n      console.log(jseu.encoder.arrayBufferToHexString(await keyObj.jwkThumbprint));\n    }));\n  });\n\n});\n\nconst getKeyStatus = (k) => ({\n  type: k._type,\n  private: k.isPrivate,\n  derLength: (k._der) ? k._der.length : 0,\n  octLength: (k._oct) ? Object.keys(k._oct).length : 0,\n  jwkKeyLength: (k._jwk) ? Object.keys(k._jwk).length : 0,\n  status: k._current,\n  isEncrypted: k.isEncrypted\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/misc.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 349,
    "kind": "test",
    "name": "describe54",
    "testId": 54,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe54",
    "access": null,
    "lineNumber": 24
  },
  {
    "__docId__": 350,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe54",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe54.it55",
    "access": null,
    "description": "EC: Derive public key to private key",
    "lineNumber": 32
  },
  {
    "__docId__": 351,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe54",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe54.it56",
    "access": null,
    "description": "Status Change Test",
    "lineNumber": 77
  },
  {
    "__docId__": 352,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "packages/js-crypto-key-utils/test/misc.spec.js~describe54",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc.spec.js~describe54.it57",
    "access": null,
    "description": "Misc",
    "lineNumber": 128
  },
  {
    "__docId__": 353,
    "kind": "testFile",
    "name": "packages/js-crypto-key-utils/test/misc2.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst Key = env.library.Key;\nconst envName = env.envName;\n\nimport jseu from 'js-encoding-utils';\nimport {pruneLeadingZeros, appendLeadingZeros} from '../src/util.js';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nfunction objectSort(obj){\n  const keys = Object.keys(obj).sort();\n  const map = {};\n  keys.forEach((key) => { map[key] = obj[key]; });\n  return map;\n}\n\ndescribe(`${envName}: RSA Key pruning leading zeros and appending leading zeros`, () => {\n\n  const badRSA = {\n    'kty': 'RSA',\n    'e': 'AAEAAQ', // 00 01 00 01\n    'n': 'qLOyhK-OtQs4cDSoYPFGxJGfMYdjzWxVmMiuSBGh4KvEx-CwgtaTpef87Wdc9GaFEncsDLxkp0LGxjD1M8jMcvYq6DPEC_JYQumEu3i9v5fAEH1VvbZi9cTg-rmEXLUUjvc5LdOq_5OuHmtme7PUJHYW1PW6ENTP0ibeiNOfFvs'\n  };\n  before(async() => {\n  });\n\n  it('Bad RSA JWK', async function () {\n    this.timeout(4000);\n    const key = new Key('jwk', badRSA);\n    const der = await key.export('der');\n    const newKey = new Key('der', der);\n    const newJwk = await newKey.export('jwk');\n    expect(newJwk.e === 'AQAB').to.be.true;\n\n  });\n\n  it('util test', async () => {\n    const leading = jseu.encoder.decodeBase64Url('AAEAAQ');\n    const nonleading = jseu.encoder.decodeBase64Url('AQAB');\n\n    expect(pruneLeadingZeros(leading).toString() === nonleading.toString()).to.be.true;\n    expect(appendLeadingZeros(nonleading, leading.length).toString() === leading.toString()).to.be.true;\n\n    const msg = new Uint8Array(256);\n    const offset = 17;\n    msg.forEach( (x, idx) => { msg[idx] = (offset > idx) ? 0x00 : 0xFF & idx; });\n\n    const b64uLeading = jseu.encoder.encodeBase64Url(msg);\n    const binLeading = jseu.encoder.decodeBase64Url(b64uLeading);\n    const b64uNonLeading = jseu.encoder.encodeBase64Url(msg.slice(offset));\n    const binNonLeading = jseu.encoder.decodeBase64Url(b64uNonLeading);\n\n    expect(pruneLeadingZeros(binLeading).toString() === binNonLeading.toString()).to.be.true;\n\n    expect(appendLeadingZeros(binNonLeading, binLeading.length).toString() === binLeading.toString()).to.be.true;\n\n\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-key-utils/test/misc2.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 354,
    "kind": "test",
    "name": "describe58",
    "testId": 58,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe58",
    "access": null,
    "lineNumber": 20
  },
  {
    "__docId__": 355,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js~describe58",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe58.it59",
    "access": null,
    "description": "Bad RSA JWK",
    "lineNumber": 30
  },
  {
    "__docId__": 356,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "packages/js-crypto-key-utils/test/misc2.spec.js~describe58",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-key-utils/test/misc2.spec.js~describe58.it60",
    "access": null,
    "description": "util test",
    "lineNumber": 40
  },
  {
    "__docId__": 357,
    "kind": "testFile",
    "name": "packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "content": "import chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\nimport jseu from 'js-encoding-utils';\n\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst pbkdf = env.library;\nconst envName = env.envName;\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'MD5'];\nconst sample = {\n  pbkdf1: {\n    p: 'password',\n    pbuf: '70617373776f7264',\n    s: 'dc04deff5a33c22df3aa82085f9c2d0f5477af73cd500dfe53162d70ba096a03',\n    c: 2048,\n    dkLen: 16,\n    key: {\n      'SHA-256': '2e460082f6002d377042bbfd7c3fcf61',\n      'SHA-384': 'bc3d241bd9975babb7bb7fd0c843c9e0',\n      'SHA-512': '2b875a1a163ade05f788ba386033c20a',\n      'SHA-1': '55ce9e9aa9bf733f193e66620365fe0e',\n      'MD5': '9238c6bfe098e5c4e7b68549233cc8ef'\n    }\n  },\n  pbkdf2: {\n    p: 'password',\n    pbuf: '70617373776f7264',\n    s: 'dc04deff5a33c22df3aa82085f9c2d0f5477af73cd500dfe53162d70ba096a03',\n    c: 2048,\n    dkLen: 32,\n    key: {\n      'SHA-256': 'bf3d09d429fbf71bbb384a6421447da32096ff8a010c7042d3e29194237792d2',\n      'SHA-384': 'f4e9e3377bfdb37695b41d163b67f6a8de017db98ea69bd5163f9d771a141878',\n      'SHA-512': 'ff055f4a1f3b9b70de87ecd942c7aed9d1e5b77d5b4d36f92389ead9f6c359bf',\n      'SHA-1': 'ca95cba5373ca0b86ad1dd7b31fb51d77f4cdc424c1d9b704620cee505bdc772',\n      'MD5': '28ecf8c0c5435581175b094cb7626fff5dca051755dcab43add58cff48abfe8f'\n    }\n  }\n};\n\ndescribe(`${envName}: Test for PBKDF 1 and 2`, () => {\n  before( async () => {\n  });\n\n  it('PBKDF2 with password string', async function() {\n    this.timeout(10000);\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf2(\n        sample.pbkdf2.p,\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.s),\n        sample.pbkdf2.c,\n        sample.pbkdf2.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf2.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF2 with password buffer', async function() {\n    this.timeout(10000);\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf2(\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.pbuf),\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf2.s),\n        sample.pbkdf2.c,\n        sample.pbkdf2.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf2.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF1 with password string', async function() {\n    this.timeout(10000);\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf1(\n        sample.pbkdf1.p,\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.s),\n        sample.pbkdf1.c,\n        sample.pbkdf1.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf1.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n  it('PBKDF1 with password buffer', async function() {\n    this.timeout(10000);\n    const array = await Promise.all( hashes.map( async (h) => {\n      const key = await pbkdf.pbkdf1(\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.pbuf),\n        jseu.encoder.hexStringToArrayBuffer(sample.pbkdf1.s),\n        sample.pbkdf1.c,\n        sample.pbkdf1.dkLen,\n        h\n      );\n      return jseu.encoder.arrayBufferToHexString(key) === sample.pbkdf1.key[h];\n    }));\n    expect(array.every( (elem) => elem)).to.be.true;\n  });\n\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "test",
    "name": "describe61",
    "testId": 61,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61",
    "access": null,
    "lineNumber": 43
  },
  {
    "__docId__": 359,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61.it62",
    "access": null,
    "description": "PBKDF2 with password string",
    "lineNumber": 47
  },
  {
    "__docId__": 360,
    "kind": "test",
    "name": "it63",
    "testId": 63,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61.it63",
    "access": null,
    "description": "PBKDF2 with password buffer",
    "lineNumber": 62
  },
  {
    "__docId__": 361,
    "kind": "test",
    "name": "it64",
    "testId": 64,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61.it64",
    "access": null,
    "description": "PBKDF1 with password string",
    "lineNumber": 77
  },
  {
    "__docId__": 362,
    "kind": "test",
    "name": "it65",
    "testId": 65,
    "memberof": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-pbkdf/test/pbkdf.spec.js~describe61.it65",
    "access": null,
    "description": "PBKDF1 with password buffer",
    "lineNumber": 92
  },
  {
    "__docId__": 363,
    "kind": "testFile",
    "name": "packages/js-crypto-random/test/random.spec.js",
    "content": "import chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\nimport {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst random = env.library;\nconst envName = env.envName;\n\n\ndescribe(`${envName}: Random generation test`, () => {\n\n  it('Random bytes of desired length should be generated successfully', () => {\n    const r = random.getRandomBytes(32);\n    expect(r).to.be.a('Uint8Array');\n    expect(r).to.be.length(32);\n  });\n\n  it('Random ascii string of desired length should be generated successfully', () => {\n    const r = random.getRandomAsciiString(32);\n    expect(r).to.be.a('String');\n    expect(r).to.be.length(32);\n  });\n\n  it('Random string (uppercase, lowercase and alphanumeric chars) of desired length should be generated successfully', () => {\n    const r = random.getRandomString(32);\n    console.log(r);\n    expect(r).to.be.a('String');\n    expect(r).to.be.length(32);\n  });\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-random/test/random.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 364,
    "kind": "test",
    "name": "describe66",
    "testId": 66,
    "memberof": "packages/js-crypto-random/test/random.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe66",
    "access": null,
    "lineNumber": 10
  },
  {
    "__docId__": 365,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "packages/js-crypto-random/test/random.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe66.it67",
    "access": null,
    "description": "Random bytes of desired length should be generated successfully",
    "lineNumber": 12
  },
  {
    "__docId__": 366,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "packages/js-crypto-random/test/random.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe66.it68",
    "access": null,
    "description": "Random ascii string of desired length should be generated successfully",
    "lineNumber": 18
  },
  {
    "__docId__": 367,
    "kind": "test",
    "name": "it69",
    "testId": 69,
    "memberof": "packages/js-crypto-random/test/random.spec.js~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-random/test/random.spec.js~describe66.it69",
    "access": null,
    "description": "Random string (uppercase, lowercase and alphanumeric chars) of desired length should be generated successfully",
    "lineNumber": 24
  },
  {
    "__docId__": 368,
    "kind": "testFile",
    "name": "packages/js-crypto-rsa/test/rsa.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst rsa = env.library;\nconst envName = env.envName;\n\n\nimport rsaSmaple from './rsa_sample.js';\n// import * as oaep from '../src/oaep.js';\nimport jseu from 'js-encoding-utils';\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\ndescribe(`${envName}: RSA cryptography test`, () => {\n\n  const modulusLength = ['2048', '4096'];\n  const keys = [];\n  const msgLen = 128;\n  const msg = new Uint8Array(msgLen);\n  before( async () => {\n    for(let i = 0; i < msgLen; i++) msg[i] = 0xFF & i;\n  });\n\n  it('JWK key pair is correctly generated', async function () {\n    this.timeout(500000);\n    const results = await Promise.all(modulusLength.map(async (n) => {\n      let result = true;\n      const key = await rsa.generateKey(n).catch((e) => {\n        result = false;\n      });\n      keys.push(key);\n      // console.log(key);\n      return result;\n    }));\n    console.log(results);\n    console.log(keys);\n    expect(results.every((r) => r)).to.be.true;\n  });\n\n  it('Message is successfully encrypted and encrypted', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(Object.keys(rsaSmaple).map( async (kp) => {\n      let result = true;\n      const encrypted = await rsa.encrypt(msg, rsaSmaple[kp].publicKey.jwk, 'SHA-256').catch( (e) => {result = false;});\n      // console.log(jseu.encoder.encodeBase64(encrypted));\n      const decrypted = await rsa.decrypt(encrypted, rsaSmaple[kp].privateKey.jwk, 'SHA-256').catch( (e) => {result = false;});\n\n      expect(result).to.be.true;\n      return (decrypted.toString() === msg.toString());\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  // it('OAEP', async function (){\n  //   this.timeout(50000);\n  //   const em = await oaep.emeOaepEncode(msg, new Uint8Array([]), 256, 'SHA-256');\n  //   // console.log(em);\n  //   const msgPrime = await oaep.emeOaepDecode(em, new Uint8Array([]), 256, 'SHA-256');\n  //   expect(msg.toString() === msgPrime.toString()).to.be.true;\n  // });\n\n  it('RSASSA-PKCS1-v1_5: Message is successfully signed and verified with generated JWK pairs', async function () {\n    this.timeout(5000);\n    const results = await Promise.all(Object.keys(rsaSmaple).map( async (kp) => {\n      let result = true;\n      const sign = await rsa.sign(msg, rsaSmaple[kp].privateKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'}).catch( (e) => {result = false; console.error(e);});\n      // console.log(sign);\n      // console.log(jseu.encoder.encodeBase64(sign));\n      const valid = await rsa.verify(msg, sign, rsaSmaple[kp].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'}).catch( (e) => {result = false;});\n      expect(result).to.be.true;\n\n      return valid;\n    }));\n    console.log(results);\n    expect(results.every( (r) => r)).to.be.true;\n  });\n\n  if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n    it('RSA-PSS: Message is successfully signed and verified with generated JWK pairs', async function () {\n      this.timeout(5000);\n      const results = await Promise.all(Object.keys(rsaSmaple).map(async (kp) => {\n        let result = true;\n        const sign = await rsa.sign(msg, rsaSmaple[kp].privateKey.jwk, 'SHA-256').catch((e) => {\n          result = false;\n        });\n        // console.log(jseu.encoder.encodeBase64(sign));\n        const valid = await rsa.verify(msg, sign, rsaSmaple[kp].publicKey.jwk, 'SHA-256').catch((e) => {\n          result = false;\n        });\n        expect(result).to.be.true;\n\n        return valid;\n      }));\n      console.log(results);\n      expect(results.every((r) => r)).to.be.true;\n    });\n  }\n\n\n  it('Compatibility test', async () => {\n    const webEnc = 'd8ehCiJyQjqjrWnKSNBJ+5Q7SS+5Xdv+Bevcn+3xYX4zMMsY2BCDux75rvexiUcIZphXf3HRNsrL340wlGhg0sNKGBaFR1Nv2D3Ta5FyEnuDbSxl6hItF6pvZ628c0DW5/YTfPE1xJLZwE+8bHAgjJO3eob5vU7/h8X9tZtf37FUfPIMLDWNc4v7E2uynrzV0xHpg6J7QZbwvJmz9uShEVraR0pkR86MPvNnRw8y2iB+xAK5V+CqZLT6I5+rZuWWxaI5+9BypeR2JmNXogrqg88/JiKy1N/TdwJ2ZJ8inu1VW97soJbLmtNPH2Ur5Dd+9dZSNKhdNQwS0QLXZn3C6A==';\n    const webSig = 'CHoyzFCHWBPv6cXPplD8P0IRIO/683lfMMcMYmyukkotegyNnP+BtwID3e7f41tRe7sxUXJtb/MjUkDtxv08T2dBTAgNJtk/LLDvNVJ0AJ7MwATQpojzY1xoyEOnRhrDsYjYI+ITYDMLFbvAng2x8hf5mNrR+GoAZLxsBFtq+4n4av7FFmPMpwpFJ/R6arQky3OIt6/dm3d5jQQ6kTPSHKb3gVrutsXUUrSosXQiMDz0Qu6T2bdwKHWX5zO9P00AYwgpoLaWV+vHXQNEyyxLA/VgB2C8obpTNNJF5rqcuVp9KNGmffV43UnzWZX0YAB5JSIc+9JXKqj71JO3Q7AjTA==\\n';\n    const webSigPKCS1V15 = 'HOe0gTJIHojBv5M0cMIZLIH4k/ZQu8fl2ko3vU+lwx7W24KvQMp8FwjtZt7Cg+7A4PV0BO/w/pHdpaA6SM22er2fYy0jQsC+TWpkd4Z7jPNsQDSRK7UI/xTRrAlYvat4wb5DZrN6x73/m9MZqXXpfIGrmIe0wu7MHW2iRk063bA/A2rxD9bveO6H3l4zYdMRxjwA6I2Wvgc1KxDZrPxGdDDt4EUzekj3rBSOB7S1EUKlc7hC1BicgIUe3Z1hGaCS0T7EwWuqZ091lyiJGrR2aayn8bKLQmeROKEcO51CWLLM5pF6M3hTACt1saz9kGufDvqWPw8uyMP+aPGlV+ASsw==';\n    const nodeEnc = 'oryyTFEC/BEgCjML93pibShvvQws120JQ41jFFhY8qm2ceGfknkBXmZYuafsCk2tUGO82mYoS0vGRd22jcQ35Bz5AcnBRlCSk90GUUPYvoRe3ED6k8rzYsi7JkMRWbXOSaI2UBx6cxWHS6ooY/XYsjubz7D+sV6okQkBbGpVCOhw0biBI6QYw54YaMryW3yxSKIoq56Z6mWNMmSTbY1DC9l6ckDn0XDePdZs/SQox1g35OmBNnALRn92Nltg6Bw1wuV/FKNsosiwdwZW7VoQqpvHORDsBBIVG++tIx/T2E5D1tddGOt0vqEWuEA3zn6x/FmKSeLzO6KGaD1xzoivTA==';\n    const nodeSig = 'c9vdu4tmstRJEk1fLLLqU/r6cNZ9Tp74Zw2VsJxNvoAEFP/BXkwq27drupqajvxj+QKxP7ggs83Oi/cppmqAFghXMU1OJRRdMIbcn9O8RBZ0SJkY/LHy8NUrNvJ3AY8EjL3zqH1X0YaQltnKs9xgne4p+DpL45fQlFz8BJML+Tw1bIS59uZ87RNIEcAytiwH6VXb/HLJdLZD40OWfG2lD4g5oobZz/Gdd1ncAFuFcl0ut7SZu/wltp8DCXeQ6zl4lUG7YS3+RG0Iigq45pBYhq2Hrag+t0YQwTQQRGhKEjFlr8cKIdUaTSDgEwNcRf25cSVSJrrFepaKswM8QDkpVw==';\n    const nodeSigPKCS1V15 = 'HOe0gTJIHojBv5M0cMIZLIH4k/ZQu8fl2ko3vU+lwx7W24KvQMp8FwjtZt7Cg+7A4PV0BO/w/pHdpaA6SM22er2fYy0jQsC+TWpkd4Z7jPNsQDSRK7UI/xTRrAlYvat4wb5DZrN6x73/m9MZqXXpfIGrmIe0wu7MHW2iRk063bA/A2rxD9bveO6H3l4zYdMRxjwA6I2Wvgc1KxDZrPxGdDDt4EUzekj3rBSOB7S1EUKlc7hC1BicgIUe3Z1hGaCS0T7EwWuqZ091lyiJGrR2aayn8bKLQmeROKEcO51CWLLM5pF6M3hTACt1saz9kGufDvqWPw8uyMP+aPGlV+ASsw==';\n\n    const decrypted = await rsa.decrypt(jseu.encoder.decodeBase64(webEnc), rsaSmaple['2048'].privateKey.jwk, 'SHA-256');\n    console.log(decrypted.toString() === msg.toString());\n    expect(decrypted.toString() === msg.toString()).to.be.true;\n\n    if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n      const valid = await rsa.verify(msg, jseu.encoder.decodeBase64(webSig), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {\n        name: 'RSA-PSS',\n        saltLength: 192\n      });\n      console.log(valid);\n      expect(valid).to.be.true;\n    }\n    const validP = await rsa.verify(msg, jseu.encoder.decodeBase64(webSigPKCS1V15), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'});\n    console.log(validP);\n    expect(validP).to.be.true;\n\n    const decryptedNode = await rsa.decrypt(jseu.encoder.decodeBase64(nodeEnc), rsaSmaple['2048'].privateKey.jwk, 'SHA-256');\n    console.log(decryptedNode.toString() === msg.toString());\n    expect(decryptedNode.toString() === msg.toString()).to.be.true;\n\n    if(typeof window === 'undefined' || (typeof window !== 'undefined' && typeof window.msCrypto === 'undefined')) {\n      const validNode = await rsa.verify(msg, jseu.encoder.decodeBase64(nodeSig), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {\n        name: 'RSA-PSS',\n        saltLength: 192\n      });\n      console.log(validNode);\n      expect(validNode).to.be.true;\n    }\n\n    const validNodeP = await rsa.verify(msg, jseu.encoder.decodeBase64(nodeSigPKCS1V15), rsaSmaple['2048'].publicKey.jwk, 'SHA-256', {name: 'RSASSA-PKCS1-v1_5'});\n    console.log(validNodeP);\n    expect(validNodeP).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-rsa/test/rsa.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 369,
    "kind": "test",
    "name": "describe70",
    "testId": 70,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "access": null,
    "lineNumber": 14
  },
  {
    "__docId__": 370,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70.it71",
    "access": null,
    "description": "JWK key pair is correctly generated",
    "lineNumber": 24
  },
  {
    "__docId__": 371,
    "kind": "test",
    "name": "it72",
    "testId": 72,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70.it72",
    "access": null,
    "description": "Message is successfully encrypted and encrypted",
    "lineNumber": 40
  },
  {
    "__docId__": 372,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70.it73",
    "access": null,
    "description": "RSASSA-PKCS1-v1_5: Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 63
  },
  {
    "__docId__": 373,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70.it74",
    "access": null,
    "description": "RSA-PSS: Message is successfully signed and verified with generated JWK pairs",
    "lineNumber": 80
  },
  {
    "__docId__": 374,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "packages/js-crypto-rsa/test/rsa.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-rsa/test/rsa.spec.js~describe70.it75",
    "access": null,
    "description": "Compatibility test",
    "lineNumber": 101
  },
  {
    "__docId__": 375,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.encrypt-sym.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\n//const jscu = env.library;\nconst envName = env.envName;\n\nimport random from 'js-crypto-random';\nimport aes from 'js-crypto-aes';\nimport pbdkf from 'js-crypto-pbkdf';\n\ndescribe(`${envName}: Symmetric Encryption test with PBKDF2`, () => {\n  let msg;\n  const password = 'HelloWorldMyPassword';\n  before( async function () {\n    this.timeout(10000);\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('AES Encryption/Decryption with Passwords via PBKDF2', async () => {\n    //////////////////////\n    // Sender\n    //////////////////////\n    // derive key from password\n    // following params (salt, iterationCount, aesKeyLen, hash) must be shared with receiver.\n    const salt = random.getRandomBytes(32); // Uint8Array -> must be shared with receiver\n    const iterationCount = 2048; // must be shared with receiver\n    const aesKeyLen = 32; // AES key length, 16 or 32.\n    const hash = 'SHA-256'; // SHA-384, SHA-512, etc.\n\n    const aesKeySender = await pbdkf.pbkdf2(\n      password,\n      salt,\n      iterationCount,\n      aesKeyLen,\n      hash\n    );\n\n    // encryption\n    // following iv must be shared with receiver.\n    const iv = random.getRandomBytes(12); // 12 bytes IV in Uint8Array for AES-GCM mode\n    const additionalData = new Uint8Array([]); // optional AAD\n    const encrypted = await aes.encrypt(\n      msg,\n      aesKeySender,\n      { name: 'AES-GCM',\n        iv,\n        additionalData,\n        tagLength: 16 // default\n      });\n\n    // sender sends the following object attached to encrypted message (ciphertext).\n    // password must be notified to receiver via different way.\n    const ciphertextObject = {\n      // encrypted message\n      data: encrypted,\n      // key derivation parameters\n      pbkdf2params: {\n        salt,\n        iterationCount,\n        aesKeyLen,\n        hash\n      },\n      // encryption parameters\n      aesParams: {\n        name: 'AES-GCM',\n        iv,\n        additionalData,\n        tagLength: 16\n      }\n    };\n\n\n    //////////////////////\n    // Receiver\n    //////////////////////\n    // derive key from password\n    const aesKeyReceiver = await pbdkf.pbkdf2(\n      password,\n      ciphertextObject.pbkdf2params.salt,\n      ciphertextObject.pbkdf2params.iterationCount,\n      ciphertextObject.pbkdf2params.aesKeyLen,\n      ciphertextObject.pbkdf2params.hash\n    );\n\n    // encryption\n    const decrypted = await aes.decrypt(\n      ciphertextObject.data,\n      aesKeyReceiver,\n      ciphertextObject.aesParams\n    );\n    expect(decrypted.toString() === msg.toString()).to.be.true;\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.encrypt-sym.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 376,
    "kind": "test",
    "name": "describe76",
    "testId": 76,
    "memberof": "packages/js-crypto-utils/test/api.encrypt-sym.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt-sym.spec.js~describe76",
    "access": null,
    "lineNumber": 10
  },
  {
    "__docId__": 377,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "packages/js-crypto-utils/test/api.encrypt-sym.spec.js~describe76",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt-sym.spec.js~describe76.it77",
    "access": null,
    "description": "AES Encryption/Decryption with Passwords via PBKDF2",
    "lineNumber": 19
  },
  {
    "__docId__": 378,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.encrypt.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\ndescribe(`${envName}: Encryption test`, () => {\n  const curves = ['P-256', 'P-384', 'P-521'];\n  const hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\n  let ecKeySet = [];\n  let rsaKeySet = [];\n  let msg;\n  before( async function () {\n    this.timeout(10000);\n    ecKeySet = await Promise.all(curves.map( async (crv) => [ await jscu.pkc.generateKey('EC', {namedCurve: crv}), await jscu.pkc.generateKey('EC', {namedCurve: crv})]));\n    rsaKeySet = await Promise.all([2048, 4096].map( async (nLen) => await jscu.pkc.generateKey('RSA', {modulusLength: nLen})));\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('ECDH: Encrypted message is successfully generated and decrypted', async () => {\n    for (let i = 0; i < curves.length; i++) {\n      for (let j = 0; j < hashes.length; j++) {\n        let options = {\n          privateKey: ecKeySet[i][1].privateKey,\n          hash: hashes[j],\n          encrypt: 'AES-GCM',\n          keyLength: 32,\n          info: ''\n        };\n        const encrypted = await jscu.pkc.encrypt(msg, ecKeySet[i][0].publicKey, options);\n\n        options = {\n          publicKey: ecKeySet[i][1].publicKey,\n          hash: hashes[j],\n          encrypt: 'AES-GCM',\n          keyLength: 32,\n          info: '',\n          salt: encrypted.salt,\n          iv: encrypted.iv\n        };\n        const decrypted = await jscu.pkc.decrypt(encrypted.data, ecKeySet[i][0].privateKey, options);\n\n        expect(msg.toString() === decrypted.toString()).to.be.true;\n      }\n    }\n  });\n\n  it('RSA-OAEP: Encrypted message is successfully generated and decrypted', async () => {\n    const results = await Promise.all(rsaKeySet.map( async (kp) => {\n      let result = true;\n      const encrypted = await jscu.pkc.encrypt(msg, kp.publicKey, {hash: 'SHA-256'}).catch( (e) => {console.error(e); result = false;});\n      const decrypted = await jscu.pkc.decrypt(encrypted.data, kp.privateKey, {hash: 'SHA-256'}).catch( (e) => {result = false;});\n\n      expect(result).to.be.true;\n      return (decrypted.toString() === msg.toString());\n    }));\n    expect(results.every( (r) => r)).to.be.true;\n  });\n});\n\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.encrypt.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 379,
    "kind": "test",
    "name": "describe78",
    "testId": 78,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe78",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 380,
    "kind": "test",
    "name": "it79",
    "testId": 79,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe78",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe78.it79",
    "access": null,
    "description": "ECDH: Encrypted message is successfully generated and decrypted",
    "lineNumber": 20
  },
  {
    "__docId__": 381,
    "kind": "test",
    "name": "it80",
    "testId": 80,
    "memberof": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe78",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.encrypt.spec.js~describe78.it80",
    "access": null,
    "description": "RSA-OAEP: Encrypted message is successfully generated and decrypted",
    "lineNumber": 48
  },
  {
    "__docId__": 382,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.keygen.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\nasync function ecKeyPairAssert(kp){\n  expect(kp.publicKey instanceof jscu.Key).to.be.true;\n  expect(kp.privateKey instanceof jscu.Key).to.be.true;\n\n  const publicJwk = await kp.publicKey.export('jwk');\n  const privateJwk = await kp.privateKey.export('jwk');\n\n  expect(privateJwk.x).to.be.a('string');\n  expect(privateJwk.y).to.be.a('string');\n  expect(privateJwk.d).to.be.a('string');\n  expect(publicJwk.x).equal(privateJwk.x);\n  expect(publicJwk.y).equal(privateJwk.y);\n}\n\nasync function rsaKeyPairAssert(kp){\n  expect(kp.publicKey instanceof jscu.Key).to.be.true;\n  expect(kp.privateKey instanceof jscu.Key).to.be.true;\n\n  const publicJwk = await kp.publicKey.export('jwk');\n  const privateJwk = await kp.privateKey.export('jwk');\n\n  expect(privateJwk.n).to.be.a('string');\n  expect(privateJwk.e).to.be.a('string');\n  expect(privateJwk.d).to.be.a('string');\n  expect(privateJwk.p).to.be.a('string');\n  expect(privateJwk.q).to.be.a('string');\n  expect(privateJwk.dp).to.be.a('string');\n  expect(privateJwk.dq).to.be.a('string');\n  expect(privateJwk.qi).to.be.a('string');\n  expect(publicJwk.n).equal(privateJwk.n);\n  expect(publicJwk.e).equal(privateJwk.e);\n}\n\ndescribe(`${envName}: Key generation test via exported api`, () => {\n\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  it('ECDSA Key Generation should be done successfully', async function () {\n    this.timeout(10000);\n    await Promise.all(curves.map( async (crv) => {\n      const kp = await jscu.pkc.generateKey('EC', {namedCurve: crv});\n      await ecKeyPairAssert(kp);\n    }));\n  });\n\n  it('ECDSA Key Generation should be done unsuccessfully', async function () {\n    this.timeout(10000);\n    const crv = '256'; // unsupported // K-256 is supported sometimes.\n    let err;\n    try {\n      const kp = await jscu.pkc.generateKey('EC', {namedCurve: crv});\n      await ecKeyPairAssert(kp);\n    } catch (e) { err = e; }\n    expect(err).to.be.a('error');\n  });\n\n  it('RSA Key Generation should be done successfully', async function () {\n    this.timeout(10000);\n    let result = true;\n    await Promise.all([2048, 4096].map( async (nLen) => {\n      const kp = await jscu.pkc.generateKey('RSA', {modulusLength: nLen});\n      await rsaKeyPairAssert(kp);\n    })).catch( () => { result = false; });\n    // console.log(keys);\n    expect(result).to.be.true;\n  });\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.keygen.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 383,
    "kind": "test",
    "name": "describe81",
    "testId": 81,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81",
    "access": null,
    "lineNumber": 39
  },
  {
    "__docId__": 384,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81.it82",
    "access": null,
    "description": "ECDSA Key Generation should be done successfully",
    "lineNumber": 42
  },
  {
    "__docId__": 385,
    "kind": "test",
    "name": "it83",
    "testId": 83,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81.it83",
    "access": null,
    "description": "ECDSA Key Generation should be done unsuccessfully",
    "lineNumber": 50
  },
  {
    "__docId__": 386,
    "kind": "test",
    "name": "it84",
    "testId": 84,
    "memberof": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.keygen.spec.js~describe81.it84",
    "access": null,
    "description": "RSA Key Generation should be done successfully",
    "lineNumber": 61
  },
  {
    "__docId__": 387,
    "kind": "testFile",
    "name": "packages/js-crypto-utils/test/api.sign.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst jscu = env.library;\nconst envName = env.envName;\n\ndescribe(`${envName}: Signing and verification test via exported api`, () => {\n  const curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\n  const hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];\n  let ecKeySet = [];\n  let rsaKeySet = [];\n  let msg;\n  before( async function () {\n    this.timeout(10000);\n    ecKeySet = await Promise.all(curves.map( async (crv) => await jscu.pkc.generateKey('EC', {namedCurve: crv})));\n    rsaKeySet = await Promise.all([2048, 4096].map( async (nLen) => await jscu.pkc.generateKey('RSA', {modulusLength: nLen})));\n    msg = new Uint8Array(32);\n    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n\n\n  it('ECDSA Signing and verification should be done successfully', async () => {\n    for (let i = 0; i < curves.length; i++){\n      for (let j = 0; j < hashes.length; j++){\n        const sig = await jscu.pkc.sign(msg, ecKeySet[i].privateKey, hashes[j]);\n        const result = await jscu.pkc.verify(msg, sig, ecKeySet[i].publicKey, hashes[j]);\n        expect(result).to.be.true;\n      }\n    }\n  });\n\n  it('RSA-PSS Signing and verification should be done successfully', async () => {\n    const array = await Promise.all(\n      rsaKeySet.map( async (kp) => {\n        let result = true;\n        for(let i = 0; i < hashes.length; i++) {\n          const sig = await jscu.pkc.sign(msg, kp.privateKey, hashes[i], {name: 'RSA-PSS', saltLength: 32});\n          const valid = await jscu.pkc.verify(msg, sig, kp.publicKey, hashes[i], {name: 'RSA-PSS', saltLength: 32});\n          result = valid && result;\n        }\n        return result;\n      }));\n      expect(array.every( (r) => r)).to.be.true;\n  });\n\n  it('RSASSA-PKCS1-v1_5 Signing and verification should be done successfully', async () => {\n    const array = await Promise.all(\n      rsaKeySet.map( async (kp) => {\n        let result = true;\n        for(let i = 0; i < hashes.length; i++) {\n          const sig = await jscu.pkc.sign(msg, kp.privateKey, hashes[i], {name: 'RSASSA-PKCS1-v1_5'});\n          const valid = await jscu.pkc.verify(msg, sig, kp.publicKey, hashes[i], {name: 'RSASSA-PKCS1-v1_5'});\n          result = valid && result;\n        }\n        return result;\n      }));\n    expect(array.every( (r) => r)).to.be.true;\n  });\n\n});",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-crypto-utils/test/api.sign.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 388,
    "kind": "test",
    "name": "describe85",
    "testId": 85,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe85",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 389,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe85",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe85.it86",
    "access": null,
    "description": "ECDSA Signing and verification should be done successfully",
    "lineNumber": 22
  },
  {
    "__docId__": 390,
    "kind": "test",
    "name": "it87",
    "testId": 87,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe85",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe85.it87",
    "access": null,
    "description": "RSA-PSS Signing and verification should be done successfully",
    "lineNumber": 32
  },
  {
    "__docId__": 391,
    "kind": "test",
    "name": "it88",
    "testId": 88,
    "memberof": "packages/js-crypto-utils/test/api.sign.spec.js~describe85",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-crypto-utils/test/api.sign.spec.js~describe85.it88",
    "access": null,
    "description": "RSASSA-PKCS1-v1_5 Signing and verification should be done successfully",
    "lineNumber": 46
  },
  {
    "__docId__": 392,
    "kind": "testFile",
    "name": "packages/js-x509-utils/test/x509.ec.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst x509 = env.library;\nconst envName = env.envName;\n\nimport ec from 'js-crypto-ec';\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst curves = ['P-256', 'P-384', 'P-521', 'P-256K'];\nconst sigopt = ['ecdsa-with-sha256', 'ecdsa-with-sha384', 'ecdsa-with-sha512', 'ecdsa-with-sha1'];\nconst crtsample = '-----BEGIN CERTIFICATE-----\\n' +\n  'MIIBxjCCAWwCCQCEZlhfc33wtzAKBggqhkjOPQQDAjBrMQswCQYDVQQGEwJKUDEO\\n' +\n  'MAwGA1UECAwFVG9reW8xEDAOBgNVBAcMB0NoaXlvZGExFjAUBgNVBAoMDVNlbGYg\\n' +\n  'RW1wbG95ZWQxDDAKBgNVBAsMA1ImRDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcN\\n' +\n  'MTgwOTE4MTA0OTM0WhcNMjgwOTE1MTA0OTM0WjBrMQswCQYDVQQGEwJKUDEOMAwG\\n' +\n  'A1UECAwFVG9reW8xEDAOBgNVBAcMB0NoaXlvZGExFjAUBgNVBAoMDVNlbGYgRW1w\\n' +\n  'bG95ZWQxDDAKBgNVBAsMA1ImRDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wWTATBgcq\\n' +\n  'hkjOPQIBBggqhkjOPQMBBwNCAAScXEKv9GvV8EHzB+d9E0EgS3JFJxgz/uAQYwpZ\\n' +\n  'gI5+9KVuoGhkPk7Y3DuFbKQ20snMA5W7p5YhXxwo82pspWvDMAoGCCqGSM49BAMC\\n' +\n  'A0gAMEUCIQDG0lRQgVAYaXVkkIYQ8YC1A/NzvtlzlP2Kk07Ox6GCVwIgNS5BnBHj\\n' +\n  'UR3om5rYSWmj7rgz0uJxoaZkkNH4xM2Zfss=\\n' +\n  '-----END CERTIFICATE-----';\n\ndescribe(`${envName}: Generated JWK EC public key should be successfully converted to X509 PEM certificate and vice versa`, () => {\n  let keySet = [];\n  let msg;\n  before(async function () {\n    this.timeout(20000);\n    keySet = await Promise.all(curves.map(async (crv) => await ec.generateKey(crv)));\n    msg = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  });\n\n  it('Transform JWKs to X509 PEMs as self certs and verify generated ones', async function () {\n    this.timeout(20000);\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const array = await Promise.all(\n      keySet.map( async (kp) => {\n        let result = true;\n        await Promise.all(sigopt.map(async (so) => {\n          let re;\n          try {\n            const crt = await x509.fromJwk(\n              kp.publicKey,\n              kp.privateKey,\n              'pem',\n              {\n                signature: so,\n                days: 365,\n                issuer: name,\n                subject: name\n              }\n            );\n            const parsed = await x509.parse(crt, 'pem');\n            // console.log(parsed.signatureAlgorithm);\n            re = await ec.verify(parsed.tbsCertificate, parsed.signatureValue, kp.publicKey, parsed.signatureAlgorithm.parameters.hash, 'der');\n          } catch (e) { re = false; }\n          expect(re, `failed at ${so}`).to.be.true;\n          result = re && result;\n        }));\n        return result;\n      })\n    );\n    console.log(array);\n    expect(array.every( (x) => x)).to.be.true;\n  });\n\n  it('Transform X509 Self Signed PEM to JWK, and verify it', async function () {\n    this.timeout(20000);\n    const jwkey = await x509.toJwk(crtsample, 'pem');\n\n    const parsed = x509.parse(crtsample, 'pem');\n    const re = await ec.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.signatureAlgorithm.parameters.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/test/x509.ec.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 393,
    "kind": "test",
    "name": "describe89",
    "testId": 89,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe89",
    "access": null,
    "lineNumber": 27
  },
  {
    "__docId__": 394,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js~describe89",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe89.it90",
    "access": null,
    "description": "Transform JWKs to X509 PEMs as self certs and verify generated ones",
    "lineNumber": 37
  },
  {
    "__docId__": 395,
    "kind": "test",
    "name": "it91",
    "testId": 91,
    "memberof": "packages/js-x509-utils/test/x509.ec.spec.js~describe89",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.ec.spec.js~describe89.it91",
    "access": null,
    "description": "Transform X509 Self Signed PEM to JWK, and verify it",
    "lineNumber": 79
  },
  {
    "__docId__": 396,
    "kind": "testFile",
    "name": "packages/js-x509-utils/test/x509.rsa.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst env = getTestEnv();\nconst x509 = env.library;\nconst envName = env.envName;\n\nimport sample from './sample_crt.js';\n\nimport rsa from 'js-crypto-rsa';\nimport {Key} from 'js-crypto-key-utils';\nimport chai from 'chai';\nimport sample_crt from './sample_crt';\n// const should = chai.should();\nconst expect = chai.expect;\n\nconst hashes = ['SHA-256', 'SHA-384', 'SHA-512'];//, 'SHA-1'];\nconst pkcs1s = [ 'sha256WithRSAEncryption', 'sha384WithRSAEncryption', 'sha512WithRSAEncryption']; // RSASSA-PKCS1-v1_5\nconst constantSaltLen = 32;\n\ndescribe(`${envName}: RSA: Generated JWK public key should be successfully converted to X509 PEM certificate and vice versa`, () => {\n  before(async () => {\n  });\n\n  it('Transform JWKs to X509 RSASSA-PKCS1-v1_5 PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const results = await Promise.all(pkcs1s.map( async (signatureAlgorithm) => {\n      const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n      const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n      const crt = await x509.fromJwk(\n        await publicObj.export('jwk'),\n        await privateObj.export('jwk'),\n        'pem',\n        {\n          signature: signatureAlgorithm,\n          days: 365,\n          issuer: name,\n          subject: name\n        }\n      );\n      const parsed = await x509.parse(crt, 'pem');\n      // console.log(parsed.signatureAlgorithm);\n      const re = await rsa.verify(\n        parsed.tbsCertificate,\n        parsed.signatureValue,\n        await publicObj.export('jwk'),\n        parsed.signatureAlgorithm.parameters.hash,\n        {name: 'RSASSA-PKCS1-v1_5'}\n      );\n      return re;\n    }));\n    console.log(results);\n    expect(results.every( (elem) => elem === true)).to.be.true;\n  });\n\n  it('Transform JWKs to X509 RSA-PSS Empty Parameter PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n    const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n\n    const crt = await x509.fromJwk(\n      await publicObj.export('jwk'),\n      await privateObj.export('jwk'),\n      'pem',\n      {\n        signature: 'rsassaPss',\n        days: 365,\n        issuer: name,\n        subject: name\n      }\n    );\n    const parsed = await x509.parse(crt, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      await publicObj.export('jwk'),\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform JWKs to X509 RSA-PSS Explicit Parameter PEM as self signed cert and verify generated one', async () => {\n    const name = {\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n    const publicObj = new Key('pem', sample_crt.rsa.publicKey);\n    const privateObj = new Key('pem', sample_crt.rsa.privateKey);\n\n    const results = await Promise.all(hashes.map( async (hash) => {\n      const crt = await x509.fromJwk(\n        await publicObj.export('jwk'),\n        await privateObj.export('jwk'),\n        'pem',\n        {\n          signature: 'rsassaPss',\n          days: 365,\n          issuer: name,\n          subject: name,\n          pssParams: {saltLength: constantSaltLen, hash}\n        }\n      );\n      const parsed = await x509.parse(crt, 'pem');\n      // console.log(parsed.signatureAlgorithm);\n      const re = await rsa.verify(\n        parsed.tbsCertificate,\n        parsed.signatureValue,\n        await publicObj.export('jwk'),\n        parsed.signatureAlgorithm.parameters.hash,\n        {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n      );\n      return re;\n    }));\n    console.log(results);\n    expect(results.every( (elem) => elem === true)).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSASSA-PKCS1-v1_5 PEM to JWK, and verify it', async () => {\n    const jwkey = await x509.toJwk(sample.rsa.certificatePKCS1v1_5, 'pem');\n    const parsed = x509.parse(sample.rsa.certificatePKCS1v1_5, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSASSA-PKCS1-v1_5'}\n    );\n    // = await rsa.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSA-PSS Explicit Parameter PEM to JWK, and verify it', async () => {\n    const samplePss = '-----BEGIN CERTIFICATE-----\\n' +\n      'MIIFazCCBCKgAwIBAgIJAKmJV6cI/tYpMD4GCSqGSIb3DQEBCjAxoAswCQYFKw4D\\n' +\n      'AhoFAKEYMBYGCSqGSIb3DQEBCDAJBgUrDgMCGgUAogMCARSjAwIBATCBszELMAkG\\n' +\n      'A1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjESMBAGA1UEBxMJRnJhbmtmdXJ0MR4w\\n' +\n      'HAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0ZXMxOTA3BgNVBAsTMGNyZWF0ZWQg\\n' +\n      'YnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3dy5rYWlzZXIuY3gvKTEkMCIGA1UE\\n' +\n      'AxMbUFNTIHRlc3RSb290IENBIENlcnRpZmljYXRlMB4XDTEwMDcxMzE5NTc1NVoX\\n' +\n      'DTE2MDEwMzE5NTc1NVowgbMxCzAJBgNVBAYTAkRFMQ8wDQYDVQQIEwZIZXNzZW4x\\n' +\n      'EjAQBgNVBAcTCUZyYW5rZnVydDEeMBwGA1UEChMVUFNTIHRlc3QgY2VydGlmaWNh\\n' +\n      'dGVzMTkwNwYDVQQLEzBjcmVhdGVkIGJ5IE1hcnRpbiBLYWlzZXIgKGh0dHA6Ly93\\n' +\n      'd3cua2Fpc2VyLmN4LykxJDAiBgNVBAMTG1BTUyB0ZXN0Um9vdCBDQSBDZXJ0aWZp\\n' +\n      'Y2F0ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMZnLiVdh/4aR2Gj\\n' +\n      'FKBiDmuNe8o6NJSgNRMXv+zweb1CQRUQ4HzdiZDRBTxAGM+83/ofeD3ALUyDGniX\\n' +\n      'fbjxv05QyPGnJDjJYpdQ3ilM4MXoEYz7ZfB4/AVh1zvqELFR3a2TZ78oQGYJBeF3\\n' +\n      'vAmVuDwCrZ8J7xddABt7ceqDtzhhNcvOWDZxXtzK5yDtb4N/RMJZtbK6ZNsLV/+J\\n' +\n      'OMHT+22xycE6tE2gMCqUUC2b2MpnW71GqtkKxaA36VXl/c4Z0IhNE2Zx3qy5NVsU\\n' +\n      'Z+NYw6JrWtEw+kf2j0bKj5w0LMlERKbNib4kofcMJ8qPEIvk1u6T30vKUb7HQdU7\\n' +\n      '2OuTWQ8CAwEAAaOCARwwggEYMB0GA1UdDgQWBBTfH+IBoj70+Wn4OseW1pkNL7bO\\n' +\n      'MzCB6AYDVR0jBIHgMIHdgBTfH+IBoj70+Wn4OseW1pkNL7bOM6GBuaSBtjCBszEL\\n' +\n      'MAkGA1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjESMBAGA1UEBxMJRnJhbmtmdXJ0\\n' +\n      'MR4wHAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0ZXMxOTA3BgNVBAsTMGNyZWF0\\n' +\n      'ZWQgYnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3dy5rYWlzZXIuY3gvKTEkMCIG\\n' +\n      'A1UEAxMbUFNTIHRlc3RSb290IENBIENlcnRpZmljYXRlggkAqYlXpwj+1ikwDAYD\\n' +\n      'VR0TBAUwAwEB/zA+BgkqhkiG9w0BAQowMaALMAkGBSsOAwIaBQChGDAWBgkqhkiG\\n' +\n      '9w0BAQgwCQYFKw4DAhoFAKIDAgEUowMCAQEDggEBAJ8GcFT/Jdhz65JK0c9EFdAq\\n' +\n      '8FKa9VWX7QDQlIuu0UbZaHYaFmY1NbXcxlvTOD1ArByCHpFQ8+wrXgLrxedlm/fI\\n' +\n      '9WkvFsyvC1kSeV88C90E3mh+w9i2Qsz0Gjj2RjD98cPsqqQO7q/7uvKNcHMN5nKi\\n' +\n      'VuIPMr5fisx0C/IBQAunBfzBfdGmjoNaahDBYCKiyAaU7A+dYorRbMJF7SxBhTr1\\n' +\n      'WI/N3LlBKLF5mvtDYg7sXx6ULR/xAKKkVeUTIgGMYq/s46ZMP11QrfRHx4zNAwP9\\n' +\n      'aARZeUz1X0/LM6LgaQvVIhZqbyB637eZhusOP3226TDn7hGx/UdS0UxSwfjrzS8=\\n' +\n      '-----END CERTIFICATE-----';\n    const jwkey = await x509.toJwk(samplePss, 'pem');\n    console.log(jwkey);\n    const parsed = x509.parse(samplePss, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    // = await rsa.verify(parsed.tbsCertificate, parsed.signatureValue, jwkey, parsed.hash, 'der');\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n  it('Transform X509 Self Signed RSA-PSS Empty Parameter PEM to JWK, and verify it', async () => {\n    const samplePss = '-----BEGIN CERTIFICATE-----\\n' +\n      'MIIFCTCCA/GgAwIBAgIJALCOVlO1QTu1MA0GCSqGSIb3DQEBCjAAMIGzMQswCQYD\\n' +\n      'VQQGEwJERTEPMA0GA1UECBMGSGVzc2VuMRIwEAYDVQQHEwlGcmFua2Z1cnQxHjAc\\n' +\n      'BgNVBAoTFVBTUyB0ZXN0IGNlcnRpZmljYXRlczE5MDcGA1UECxMwY3JlYXRlZCBi\\n' +\n      'eSBNYXJ0aW4gS2Fpc2VyIChodHRwOi8vd3d3LmthaXNlci5jeC8pMSQwIgYDVQQD\\n' +\n      'ExtQU1MgdGVzdFJvb3QgQ0EgQ2VydGlmaWNhdGUwHhcNMTAwNzEzMTk1NjAzWhcN\\n' +\n      'MTYwMTAzMTk1NjAzWjCBszELMAkGA1UEBhMCREUxDzANBgNVBAgTBkhlc3NlbjES\\n' +\n      'MBAGA1UEBxMJRnJhbmtmdXJ0MR4wHAYDVQQKExVQU1MgdGVzdCBjZXJ0aWZpY2F0\\n' +\n      'ZXMxOTA3BgNVBAsTMGNyZWF0ZWQgYnkgTWFydGluIEthaXNlciAoaHR0cDovL3d3\\n' +\n      'dy5rYWlzZXIuY3gvKTEkMCIGA1UEAxMbUFNTIHRlc3RSb290IENBIENlcnRpZmlj\\n' +\n      'YXRlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2haEKyn8mtVODAPA\\n' +\n      'EMV9VlNm+HPBh+Mve5nPoU4PZ198E2JQ1llvXbDWmhuKzn/ZyB2janx/imvylkOq\\n' +\n      'Jmkdqka+VC+69/pDmhHKp2qHL6S/alPG6E2kQhy4FVIEU2Qme6niMZY4005237Pi\\n' +\n      'fWc1MBEU2c6jdkUIbw5SrWub5dbMIi71lUPHzaLqGovkLaWg2+BnPOSdg13t3jLt\\n' +\n      'N6Dm9VMpDE0sOu/t582bc2MfCmO/vIsSpu2/iA+gB4vecDBJGyOISYKKvjnc4N2s\\n' +\n      'Obok9ZgJKeTM40hGXEGzE+cTEDkkh8ydlGVRIJe3o5wjuLH3P51/EFVu0PhCSyV6\\n' +\n      'FGIO1wIDAQABo4IBHDCCARgwHQYDVR0OBBYEFM4ICyE/5cAobWjQ7LPGLrAU/gbD\\n' +\n      'MIHoBgNVHSMEgeAwgd2AFM4ICyE/5cAobWjQ7LPGLrAU/gbDoYG5pIG2MIGzMQsw\\n' +\n      'CQYDVQQGEwJERTEPMA0GA1UECBMGSGVzc2VuMRIwEAYDVQQHEwlGcmFua2Z1cnQx\\n' +\n      'HjAcBgNVBAoTFVBTUyB0ZXN0IGNlcnRpZmljYXRlczE5MDcGA1UECxMwY3JlYXRl\\n' +\n      'ZCBieSBNYXJ0aW4gS2Fpc2VyIChodHRwOi8vd3d3LmthaXNlci5jeC8pMSQwIgYD\\n' +\n      'VQQDExtQU1MgdGVzdFJvb3QgQ0EgQ2VydGlmaWNhdGWCCQCwjlZTtUE7tTAMBgNV\\n' +\n      'HRMEBTADAQH/MA0GCSqGSIb3DQEBCjAAA4IBAQCBgFRdPf+k9up9PwwbHORNe8HP\\n' +\n      'c7+yXPDK/qH74bJMQvaNOpXhvb0KWDcj5GPJ0l+eVatV1UzyDZT6exqaBTeWjgKW\\n' +\n      '1HMfF9z3Ybs1PTKt8IASFNMe4Nizx6vuAvnP/GXTz7LwOZt7QYBTaAOKUQqB/yBQ\\n' +\n      'D9Vn+P+nqgQCBfFhVXPurUFpAt6npnKpKIG8wmMBoeeuWpzMFs0Rnf9TFJt9SkAn\\n' +\n      'M8J806yQWShmibcQWmmveHtN8s/69FUUIu6q1h0A8qxISj87CdC4XKvLRV6DSu4C\\n' +\n      '+b/CfhHaOR8lINDcVYg4j3VZU24nmPlWcH4yXO8gbnoMOLnf36/Ezw3wnVIV\\n' +\n      '-----END CERTIFICATE-----';\n    const jwkey = await x509.toJwk(samplePss, 'pem');\n    const parsed = x509.parse(samplePss, 'pem');\n    const re = await rsa.verify(\n      parsed.tbsCertificate,\n      parsed.signatureValue,\n      jwkey,\n      parsed.signatureAlgorithm.parameters.hash,\n      {name: 'RSA-PSS', saltLength: parsed.signatureAlgorithm.parameters.saltLength}\n    );\n    console.log(re);\n    expect(re).to.be.true;\n  });\n\n});\n",
    "static": true,
    "longname": "/home/circleci/repo/packages/js-x509-utils/test/x509.rsa.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 397,
    "kind": "test",
    "name": "describe92",
    "testId": 92,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "access": null,
    "lineNumber": 19
  },
  {
    "__docId__": 398,
    "kind": "test",
    "name": "it93",
    "testId": 93,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it93",
    "access": null,
    "description": "Transform JWKs to X509 RSASSA-PKCS1-v1_5 PEM as self signed cert and verify generated one",
    "lineNumber": 23
  },
  {
    "__docId__": 399,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it94",
    "access": null,
    "description": "Transform JWKs to X509 RSA-PSS Empty Parameter PEM as self signed cert and verify generated one",
    "lineNumber": 62
  },
  {
    "__docId__": 400,
    "kind": "test",
    "name": "it95",
    "testId": 95,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it95",
    "access": null,
    "description": "Transform JWKs to X509 RSA-PSS Explicit Parameter PEM as self signed cert and verify generated one",
    "lineNumber": 98
  },
  {
    "__docId__": 401,
    "kind": "test",
    "name": "it96",
    "testId": 96,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it96",
    "access": null,
    "description": "Transform X509 Self Signed RSASSA-PKCS1-v1_5 PEM to JWK, and verify it",
    "lineNumber": 139
  },
  {
    "__docId__": 402,
    "kind": "test",
    "name": "it97",
    "testId": 97,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it97",
    "access": null,
    "description": "Transform X509 Self Signed RSA-PSS Explicit Parameter PEM to JWK, and verify it",
    "lineNumber": 154
  },
  {
    "__docId__": 403,
    "kind": "test",
    "name": "it98",
    "testId": 98,
    "memberof": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92",
    "testDepth": 1,
    "static": true,
    "longname": "packages/js-x509-utils/test/x509.rsa.spec.js~describe92.it98",
    "access": null,
    "description": "Transform X509 Self Signed RSA-PSS Empty Parameter PEM to JWK, and verify it",
    "lineNumber": 201
  }
]