[
  {
    "kind": "index",
    "content": "jscu: A Universal Cryptographic Library for JavaScript\n--\n\n[![CircleCI](https://circleci.com/gh/junkurihara/jscu.svg?style=svg)](https://circleci.com/gh/junkurihara/jscu)\n[![codecov](https://codecov.io/gh/junkurihara/jscu/branch/develop/graph/badge.svg)](https://codecov.io/gh/junkurihara/jscu)\n[![Maintainability](https://api.codeclimate.com/v1/badges/3e20cff0e8e062363a13/maintainability.svg)](https://codeclimate.com/github/junkurihara/jscu/maintainability)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n> **NOTE**: This repository is a *monorepo* of a universal cryptographic library for JavaScript called `js-crypto-utils` (`jscu`), which is designed so as to work in most modern browsers and Node.js. The detailed explanation would be given in each package repository. The root package is given [here](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-utils) (in `develop` branch).\n\n> **Terminated to support MS IE11 and released v1.0 (Sep. 30, 2020).**\n\n# Introduction and Overview of this monorepo\nThis project called `jscu` is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nIn particular, this library provides unified APIs of the following cryptographic functions that works in most modern browsers and Node.js.\n\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\n\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. This implies the `jscu` is composed of the several subpackages and can be seen as a cryptographic suite like [`openpgpjs`](https://openpgpjs.org/). The root package, `js-crypto-utils`, of the suite and its subpackages are listed as follows.\n\n- [`crypto-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-utils): Root cryptographic package providing unified APIs.\n- [`x509-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils): Subpackage handling X509 certificates.\n- [`key-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils): Subpackage handling various key formats like PEM, DER, and JWK.\n- [`ec`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec): Subpackage providing naive encryption and signing of elliptic curve cryptography.\n- [`rsa`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa): Subpackage providing naive encryption and signing of RSA cryptography. \n- [`aes`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes): Subpackage for AES encryption.\n- [`random`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random): Subpackage for cryptographic random generator.\n- [`hash`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash): Subpackage providing hash functions including SHA-2 and SHA-3.\n- [`hkdf`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf): Subpackage providing hash-based key derivation function.\n- [`pbkdf`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf): Subpackage providing password-based key derivation function 1 and 2.\n- [`hmac`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac): Subpackage providing hash-based message authentication code.\n\nThe structure of the package is described in the README.md of the [root package](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypt-utils), and hence we should start from there. But we can use various cryptographic functions not only via the root package, [`js-crypto-utils`](https://github.com/junkurihara/jscu/tree/develop/packages/js-crypt-utils), but also by directly importing subpackages of intended functions. We should refer to README.md of each subpackage for its detailed usage.\n\n# For Developers and Contributors\n\nUsing `npm` package is the simplest way to fully leverage `jscu` functions. Considering you fork, develop, and update `jscu` packages themselves, i.e., as developers and contributors, usage of this monorepo and procedures for NPM deployment are summarized as follows.\n\n- This monorepo is managed via [Yarn Workspace](https://yarnpkg.com/en/docs/workspaces) and [Lerna](https://github.com/lerna/lerna). After cloning this Git repo, just do `yarn install` at the root of the cloned folder. Then the setup is all done.\n- Versioning pattern of each package is completely independent, but the version of this Git repository specified in the root `package.json` is tied with the root package, i.e., `packages/js-crypto-utils`. The name of root package is also given in the root `package.json`.\n- Deployment of packages to NPM must be done through CircleCI, and **the deployment operation is only triggered by tags associated with Git repo version**. Any commits to any branch and any tags of individual package version won't kicks the deployment mechanism. The versioning and tagging would be done through the following combination of GitFlow and Lerna procedures.\n  1. First execute `yarn flow:version` and bump a version of each package that has been modified on `develop` branch. Here we note that for each updated package, the updated tag would be committed (not pushed), and hence we should almost finalize the release operation at least for each package. This simultaneously update the repo version specified in the root `package.json` without committing.\n  2. Add final changes for release at the level of GitHub repo. Then, commit changes and then execute `yarn release:start` to start release process on a release branch. Here we note the release version will be the updated Git repo version.\n  3. To finalize the release operation, execute `yarn release:finish` to merge the release branch to `master`, and then merge `master` to `develop`. It will also tag the `master` branch with the updated Git repo version, i.e., the root package (`packages/js-crypto-utils`) version.\n  4. Execute `yarn release:push` and push all branches and the generated tag of Git repo version to GitHub.\n\n# Contributing\n\n`jscu` is free, open source software licensed under MIT License.\n\nYou can open issues for bugs you've found or features you think are missing. You can also submit pull requests to this repository.\n\nContributors are more than welcome!\n\n# Documentation\nThe [`jscu` documentation](https://junkurihara.github.io/jscu-webpage/) is a dynamically generated site from this monorepo via [esdoc](https://esdoc.org/). You can submit pull requests to 'docs' of this monorepo for document update.\n",
    "longname": "/home/circleci/repo/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils\n- `aes`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes\n- `random`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random\n- `hash`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypto-utils // yarn\n  ```\n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  $ cd js-crypto-utils/packages/js-crypto-utils\n  & yarn build\n  ```\n\nThen you should import the package as follows.\n\n```shell\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'path/to/js-crypto-utils/dist/index.js'; // for github\n```\n\nThe bundled file is also given as `js-crypto-utils/dist/jscu.bundle.js` for a use case where the module is imported as a `window.jscu` object via `script` tags.\n\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message, if message is a key, 'AES-KW' can be used as well.\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message. 'AES-KW' can be used as well\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  \n  IE is completely out of our scope now.\n  \n  Especially for Hash functions, we shall use the following pure JS implementation for some browsers (WebCrypto does not support SHA-3 yet). SHA-1 doesn't work in Edge. I believe Edge should be discarded ASAP.\n  * [sha3](https://www.npmjs.com/package/sha3) for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 for browsers\n  * [hash.js](https://www.npmjs.com/package/hash.js) for SHA-1, SHA-256, SHA-384, SHA-512 for some legacy browsers\n  * [md5](https://www.npmjs.com/package/md5) for MD5 for some legacy browsers\n\n# License\nLicensed under the MIT license, see `LICENSE` file.\n",
    "longname": "/home/circleci/repo/docs/js-crypto-utils.md",
    "name": "./docs/js-crypto-utils.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/circleci/repo/docs/js-crypto-utils.md",
    "name": "./docs/js-crypto-utils.md",
    "content": "JavaScript Cryptographic Utilities for Browsers and Node.js Crypto-Suite Compatibility\n--\n[![npm version](https://badge.fury.io/js/js-crypto-utils.svg)](https://badge.fury.io/js/js-crypto-utils)\n[![Dependencies](https://david-dm.org/junkurihara/jscu.svg?path=packages/js-crypto-utils)](https://david-dm.org/junkurihara/jscu?path=packages/js-crypto-utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Overview\nThis library is being developed to provide unified cryptographic APIs for browsers and Node.js. There currently exist various sophisticated cryptographic suites for JavaScript that are implemented as native functions, e.g., WebCrypto API and `crypto` in Node.js. However, they have different interfaces and are NOT supported at all platforms. For instance, FireFox cannot be fed PKCS8-formatted private key in WebCrypto API but Chrome does. On the other hand, such suites have not been designed to keep compatibility to existing non-Web cryptographic suites like OpenSSL. This can be seen from the fact that WebCrypto API does not support PEM-formatted keys. Hence we (actually I!) need to write ugly codes so as to enable apps to work in various environments. From this observation, we aim that this library provides support functions to fill such gaps among JS cryptographic suites and that between JavaScript and other popular crypto suites.\n\nFirstly, this library provides following functions that works in most modern browsers and Node.js.\n- ECDSA signing, verification, key generation (P-256/P-384/P-521/P-256K)\n- RSA-PSS/RSASSA-PKCS1-v1_5 signing, verification, key generation.\n- Encryption using ECDH and HKDF.\n- Encryption using RSA-OAEP. \n- Public/private key format conversion between JWK and PEM/DER (SPKI for public/PKCS8 for private)\n- Generation of JWK Thumbprint\n- Generation of X.509 public key certificate from JWK and extraction of JWK public key from X.509 public key certificate.\nAdditionally, this library provides random, hash, AES, HMAC, HKDF, and PBKDF functions. \n\n# Module structure\nThe module structure of this library can be illustrated as follows.\n```\n/**\n * index.js\n * Structure of API\n *  |-- Key (Key object handling EC and RSA public/private keys)\n *  |\n *  |-- pkc (public key crypto, EC and RSA)\n *  |    |-- generateKey\n *  |    |-- encrypt\n *  |    |-- decrypt\n *  |    |-- sign\n *  |    |-- verify\n *  |\n *  |-- x509\n *  |    |-- toJwk\n *  |    |-- fromJwk\n *  |    |-- parse (to verify)\n *  |\n *  |-- aes\n *  |-- random\n *  |-- hash\n *  |-- hmac\n *  |-- hkdf\n *  |-- pbkdf\n */\n```\n\nWe should note that most of this library's functions are independently available through NPM and GitHub as modules. In other words, this library is being developed as an integrated wrapper of those independent modules. The independent modules are listed as follows:\n\n- `Key`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-key-utils\n- `pkc` (EC): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-ec\n- `pkc` (RSA): https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-rsa\n- `x509`: https://github.com/junkurihara/jscu/tree/develop/packages/js-x509-utils\n- `aes`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-aes\n- `random`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-random\n- `hash`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hash\n- `hkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hkdf\n- `pbkdf`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-pbkdf\n- `hmac`: https://github.com/junkurihara/jscu/tree/develop/packages/js-crypto-hmac\n\nPlease refer to the above repos for further information.\n\n**NOTE**: If you would use only few modules and employ neither `Key` nor `pkc`, we highly recommend use our independent modules since those independent ones are relatively small and this library would be overkill. \n\n\n# Installation\nAt your project directory, do either one of the following.\n\n- From npm/yarn:\n  ```shell\n  $ npm install --save js-crypto-utils // npm\n  $ yarn add js-crypto-utils // yarn\n  ```\n- From GitHub:\n  ```shell\n  $ git clone https://github.com/junkurihara/jscu.git\n  $ cd js-crypto-utils/packages/js-crypto-utils\n  & yarn build\n  ```\n\nThen you should import the package as follows.\n\n```shell\nimport jscu from 'js-crypto-utils'; // for npm\nimport jscu from 'path/to/js-crypto-utils/dist/index.js'; // for github\n```\n\nThe bundled file is also given as `js-crypto-utils/dist/jscu.bundle.js` for a use case where the module is imported as a `window.jscu` object via `script` tags.\n\n\n# Usage\n**NOTE:** This library always uses `jscu.Key` objects as instances of public and private keys, and the `Key` object can be instantiated from and can export ones in various formats. For the detailed usage of `Key` object, please refer to [another GitHub repo](https://github.com/junkurihara/js-crypto-key-utils).\n\n## Key generation, sign and verify\n```javascript\n// case of ECDSA\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256'); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256'); // true or false\n});\n```\n\n```javascript\n// case of RSA\njscu.pkc.generateKey(  // key generation\n  'RSA', // RSA key pair\n  {modulusLength: 2048}\n)\n.then( async (keyPair) => { // get a key pair in jscu.Key object\n  const msg = new Uint8Array(32);\n  for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n  \n  // case of RSA-PSS\n  // RSASSA-PKCS1-v1_5 is supported as well. see test files.\n  const sig = await jscu.pkc.sign(msg, keyPair.privateKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // uint8array\n  const result = await jscu.pkc.verify(msg, sig, keyPair.publicKey, 'SHA-256', {name: 'RSA-PSS', saltLength: 32}); // true or false\n});\n```\n\n## Encryption and decryption through ECDH with AES-GCM of 256 bits key and SHA-256 based HKDF\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst remotePublicKey = {...}; // destination's publicKey in jscu.Key object\nconst remotePrivateKey = {...}; // destination's privateKey in jscu.Key object\n\njscu.pkc.generateKey(  // key generation\n  'EC', // ECDSA or ECDH key pair\n  {namedCurve: 'P-256'} // or 'P-384', 'P-521', 'P-256K'\n).then( async (keyPair) => { // get a key pair in jscu.Key object\n  ////////////////////////////\n  // encryption at my side\n  ////////////////////////////\n  const optionsEncryption = {\n    privateKey: keyPair.privateKey, // for ECDH, my private key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message, if message is a key, 'AES-KW' can be used as well.\n    keyLength: 32, // key length of AES\n    info: '' // for HKDF\n  };\n  const encrypted = await jscu.pkc.encrypt(msg, remotePublicKey, optionsEncryption);\n  // now you get the encrypted message\n  \n  ////////////////////////////\n  // decryption at remote side\n  ////////////////////////////\n  const optionsDecryption = {\n    publicKey: keyPair.publicKey, // for ECDH, my public key\n    hash: 'SHA-256', // for HKDF\n    encrypt: 'AES-GCM', // for encryption of message. 'AES-KW' can be used as well\n    keyLength: 32, // key length of AES\n    info: '', // for HKDF\n    salt: encrypted.salt, // for HKDF\n    iv: encrypted.iv // for AES\n  };\n  const decrypted = await jscu.pkc.decrypt(encrypted.data, remotePrivateKey, optionsDecryption);\n  // now you get decrypted message\n});\n```\nNote that AES and HKDF are independently available from `jscu.aes` and `jscu.hkdf` as well as `random` and `hash`. Also note that the HKDF employed in this library is the one specified in RFC5869 (https://tools.ietf.org/html/rfc5869). \n\n\n## RSA-OAEP encryption and decryption\n```javascript\nconst msg = new Uint8Array(32);\nfor(let i = 0; i < 32; i++) msg[i] = 0xFF & i;\n\nconst publicKey = {...}; // publicKey in jscu.Key object\nconst privateKey = {...}; // privateKey in jscu.Key object\n\njscu.pkc.encrypt(\n  msg,\n  publicKey,\n  {hash: 'SHA-256'} // for OAEP\n).then( (encrypted) => {\n // now you get the encrypted message\n return jscu.pkc.decrypt(\n   encrypted, \n   privateKey,\n   {hash: 'SHA-256'}); // for OAEP\n}).then( (decrypted) => {\n  // now you get the decrypted message\n})\n```\n\n## Converting between Json Web Key (JWK) and SPKI-formatted (public key) or PKCS8-formatted (private key) PEM/DER\nWe shall explain the conversion using an example of elliptic curve cryptography keys. First let an elliptic curve crypto public key is given in the form of JWK ([RFC7517](https://tools.ietf.org/html/rfc7517)) as follows:\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'};\n```\n\nGiven JWKs can be converted to the PEM/DER formatted keys in the following procedure.\n```javascript\nconst publicKeyObject = new jscu.Key('jwk', publicJwk);\nconst publicAsn = await publicKeyObject.export(\n  'pem', // output format is in string PEM, 'der' is also available\n  {\n    compact: false // if true, compressed form of keys are obtained\n  });\n```\n\nThis library also re-convert keys in PEM/DER to JWK as follows.\n```javascript\nconst publicKeyObjectR = new jscu.Key('pem', publicASN);\nconst publicJwkR = publicKeyObjectR.export('jwk');\n```\nNote that JWK/DER/PEM-formatted RSA keys can be handled in the similar manner to the above. \n\n## Generation of self-signed X.509 certificate from JWK-formatted public key\n```javascript\nconst publicJwk = {kty: 'EC', crv: 'P-256', x: '...', y: '...'}; // public key to be signed\nconst privateJwk = {ktyp: 'EC', crv: 'P-256', x: '...', y: '...', d: '...'}; // private key\n\nconst name = { // this is optional\n      countryName: 'JP',\n      stateOrProvinceName: 'Tokyo',\n      localityName: 'Chiyoda',\n      organizationName: 'example',\n      organizationalUnitName: 'Research',\n      commonName: 'example.com'\n    };\n\n// generation from JWK\njscu.keyUtil.x509.fromJwk(\n  publicJwk,\n  privateJwk,\n  'pem',\n  {\n    signature: 'ecdsa-with-sha256', // signature algorithm\n    days: 365, // expired in days\n    issuer: name, // issuer\n    subject: name // assume that issuer = subject, i.e., self-signed certificate\n  },\n  'pem' // output signature is in PEM. DER-encoded signature is available with 'der'.\n).then( (cert) => {\n  // now you get the certificate in PEM string\n});\n```\nFor `signature`, `rsassaPss` (RSA-PSS) and `sha*WithRSAEncryption` (RSASSA-PKCS1-v1_5) are available as well. When `rsassaPss` is specified, `saltLength` and `hash` are required as its params. \n\n## Extract JWK from X.509 certificate\n```javascript\nconst crtsample = '-----BEGIN CERTIFICATE-----...'; \nconst jwkey = jscu.keyUtil.x509.toJwk(crtsample, 'pem');\n// now you get JWK public key from PEM-formatted certificate     \n```\n  \n# Notes\nOne of the listed APIs/libraries is automatically chosen and leveraged for each implemented function, and unified interfaces are provided for browsers and Node.js.\n\n- ECDSA and ECDH:\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js \n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- RSA-PSS, RSASSA-PKCS1-v1_5, RSA-OAEP (RSA-PSSS does not work in Edge)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Key format conversion:\n  * WebCrypto API for browsers\n  * [asn1.js](https://github.com/indutny/asn1.js) for browsers and Node.js\n- X.509 generation from JWK, and extraction of JWK from X.509\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  * [elliptic](https://github.com/indutny/elliptic) for browsers\n- AES: (may not work in IE)\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n- Random, hash, HKDF, HMAC, JWK Thumbprint\n  * WebCrypto API for browsers\n  * NodeCrypto for Node.js\n  \n  IE is completely out of our scope now.\n  \n  Especially for Hash functions, we shall use the following pure JS implementation for some browsers (WebCrypto does not support SHA-3 yet). SHA-1 doesn't work in Edge. I believe Edge should be discarded ASAP.\n  * [sha3](https://www.npmjs.com/package/sha3) for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 for browsers\n  * [hash.js](https://www.npmjs.com/package/hash.js) for SHA-1, SHA-256, SHA-384, SHA-512 for some legacy browsers\n  * [md5](https://www.npmjs.com/package/md5) for MD5 for some legacy browsers\n\n# License\nLicensed under the MIT license, see `LICENSE` file.\n",
    "static": true,
    "access": "public"
  }
]